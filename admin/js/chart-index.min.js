(() => { "use strict"; var e = { "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js": (e, t, i) => { i.r(t), i.d(t, { XYChart: () => _ }); var s = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js"), p = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), g = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), b = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); class _ extends n.SerialChart { constructor() { super(...arguments), Object.defineProperty(this, "xAxes", { enumerable: !0, configurable: !0, writable: !0, value: new o.ListAutoDispose }), Object.defineProperty(this, "yAxes", { enumerable: !0, configurable: !0, writable: !0, value: new o.ListAutoDispose }), Object.defineProperty(this, "topAxesContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.chartContainer.children.push(a.Container.new(this._root, { width: l.p100, layout: this._root.verticalLayout })) }), Object.defineProperty(this, "yAxesAndPlotContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.chartContainer.children.push(a.Container.new(this._root, { width: l.p100, height: l.p100, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "bottomAxesContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.chartContainer.children.push(a.Container.new(this._root, { width: l.p100, layout: this._root.verticalLayout })) }), Object.defineProperty(this, "leftAxesContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.yAxesAndPlotContainer.children.push(a.Container.new(this._root, { height: l.p100, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "plotsContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.yAxesAndPlotContainer.children.push(a.Container.new(this._root, { width: l.p100, height: l.p100, maskContent: !1 })) }), Object.defineProperty(this, "plotContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.plotsContainer.children.push(a.Container.new(this._root, { width: l.p100, height: l.p100 })) }), Object.defineProperty(this, "topPlotContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.plotsContainer.children.push(a.Container.new(this._root, { width: l.p100, height: l.p100 })) }), Object.defineProperty(this, "gridContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.plotContainer.children.push(a.Container.new(this._root, { width: l.p100, height: l.p100, isMeasured: !1 })) }), Object.defineProperty(this, "topGridContainer", { enumerable: !0, configurable: !0, writable: !0, value: a.Container.new(this._root, { width: l.p100, height: l.p100, isMeasured: !1 }) }), Object.defineProperty(this, "rightAxesContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.yAxesAndPlotContainer.children.push(a.Container.new(this._root, { height: l.p100, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "axisHeadersContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.plotContainer.children.push(a.Container.new(this._root, {})) }), Object.defineProperty(this, "zoomOutButton", { enumerable: !0, configurable: !0, writable: !0, value: this.topPlotContainer.children.push(h.Button.new(this._root, { themeTags: ["zoom"], icon: c.Graphics.new(this._root, { themeTags: ["button", "icon"] }) })) }), Object.defineProperty(this, "_movePoint", { enumerable: !0, configurable: !0, writable: !0, value: { x: 0, y: 0 } }), Object.defineProperty(this, "_wheelDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_otherCharts", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_movePoints", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_downStartX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downEndX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downStartY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downEndY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _afterNew() { this._defaultThemes.push(s.XYChartDefaultTheme.new(this._root)), super._afterNew(), this._disposers.push(this.xAxes), this._disposers.push(this.yAxes); const e = this._root; let t = this._root.verticalLayout; const i = this.zoomOutButton; i.events.on("click", (() => { this.zoomOut() })), i.hide(0), i.states.lookup("default").set("opacity", 1), this.chartContainer.set("layout", t); const a = this.plotContainer; a.children.push(this.seriesContainer), this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer)), this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer)), a.children.push(this.topGridContainer), a.children.push(this.bulletsContainer), a.set("interactive", !0), a.set("interactiveChildren", !1), a.set("background", r.Rectangle.new(e, { themeTags: ["plotbackground", "xy", "background"] })), this._disposers.push(a.events.on("pointerdown", (e => { this._handlePlotDown(e) }))), this._disposers.push(a.events.on("globalpointerup", (e => { this._handlePlotUp(e) }))), this._disposers.push(a.events.on("globalpointermove", (e => { this._handlePlotMove(e) }))), this._maskGrid(), this._setUpTouch() } _beforeChanged() { super._beforeChanged(), (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) && this._setUpTouch() } _setUpTouch() { this.plotContainer._display.cancelTouch || (this.plotContainer._display.cancelTouch = !!(this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY"))) } _maskGrid() { this.gridContainer.set("maskContent", !0), this.topGridContainer.set("maskContent", !0) } _removeSeries(e) { e._unstack(), e._posXDp && e._posXDp.dispose(), e._posYDp && e._posYDp.dispose(), e.set("baseAxis", void 0); const t = e.get("xAxis"); t && (u.remove(t.series, e), t.markDirtyExtremes()); const i = e.get("yAxis"); i && (u.remove(i.series, e), i.markDirtyExtremes()); const s = this.get("cursor"); if (s) { const t = s.get("snapToSeries"); t && u.remove(t, e) } super._removeSeries(e) } handleWheel(e) { const t = this.get("wheelX"), i = this.get("wheelY"), s = this.plotContainer, a = e.originalEvent; if (!g.isLocalEvent(a, this)) return; a.preventDefault(); const r = s.toLocal(e.point), n = this.get("wheelStep", .2), o = a.deltaY / 100, l = a.deltaX / 100, h = this.get("wheelZoomPositionX"), c = this.get("wheelZoomPositionY"); "zoomX" !== t && "zoomXY" !== t || 0 == l || this.xAxes.each((e => { if (e.get("zoomX")) { let t = e.get("start"), i = e.get("end"), a = e.fixPosition(r.x / s.width()); null != h && (a = h); let o = e.get("maxDeviation", 0), c = Math.min(1 + o, Math.max(-o, t - n * (i - t) * l * a)), u = Math.max(-o, Math.min(1 + o, i + n * (i - t) * l * (1 - a))); 1 / (u - c) < e.getPrivate("maxZoomFactor", 1 / 0) / e.get("minZoomCount", 1) && this._handleWheelAnimation(e.zoom(c, u)) } })), "zoomX" !== i && "zoomXY" !== i || 0 == o || this.xAxes.each((e => { if (e.get("zoomX")) { let t = e.get("start"), i = e.get("end"), a = e.fixPosition(r.x / s.width()); null != h && (a = h); let l = e.get("maxDeviation", 0), c = Math.min(1 + l, Math.max(-l, t - n * (i - t) * o * a)), u = Math.max(-l, Math.min(1 + l, i + n * (i - t) * o * (1 - a))); 1 / (u - c) < e.getPrivate("maxZoomFactor", 1 / 0) / e.get("minZoomCount", 1) && this._handleWheelAnimation(e.zoom(c, u)) } })), "zoomY" !== t && "zoomXY" !== t || 0 == l || this.yAxes.each((e => { if (e.get("zoomY")) { let t = e.get("start"), i = e.get("end"), a = e.fixPosition(r.y / s.height()); null != c && (a = c); let o = e.get("maxDeviation", 0), h = Math.min(1 + o, Math.max(-o, t - n * (i - t) * l * a)), u = Math.max(-o, Math.min(1 + o, i + n * (i - t) * l * (1 - a))); 1 / (u - h) < e.getPrivate("maxZoomFactor", 1 / 0) / e.get("minZoomCount", 1) && this._handleWheelAnimation(e.zoom(h, u)) } })), "zoomY" !== i && "zoomXY" !== i || 0 == o || this.yAxes.each((e => { if (e.get("zoomY")) { let t = e.get("start"), i = e.get("end"), a = e.fixPosition(r.y / s.height()); null != c && (a = c); let l = e.get("maxDeviation", 0), h = Math.min(1 + l, Math.max(-l, t - n * (i - t) * o * a)), u = Math.max(-l, Math.min(1 + l, i + n * (i - t) * o * (1 - a))); 1 / (u - h) < e.getPrivate("maxZoomFactor", 1 / 0) / e.get("minZoomCount", 1) && this._handleWheelAnimation(e.zoom(h, u)) } })), "panX" !== t && "panXY" !== t || 0 == l || this.xAxes.each((e => { if (e.get("panX")) { let t = e.get("start"), i = e.get("end"), s = this._getWheelSign(e) * n * (i - t) * l, a = t + s, r = i + s, o = this._fixWheel(a, r); a = o[0], r = o[1], this._handleWheelAnimation(e.zoom(a, r)) } })), "panX" !== i && "panXY" !== i || 0 == o || this.xAxes.each((e => { if (e.get("panX")) { let t = e.get("start"), i = e.get("end"), s = this._getWheelSign(e) * n * (i - t) * o, a = t + s, r = i + s, l = this._fixWheel(a, r); a = l[0], r = l[1], this._handleWheelAnimation(e.zoom(a, r)) } })), "panY" !== t && "panXY" !== t || 0 == l || this.yAxes.each((e => { if (e.get("panY")) { let t = e.get("start"), i = e.get("end"), s = this._getWheelSign(e) * n * (i - t) * l, a = t + s, r = i + s, o = this._fixWheel(a, r); a = o[0], r = o[1], this._handleWheelAnimation(e.zoom(a, r)) } })), "panY" !== i && "panXY" !== i || 0 == o || this.yAxes.each((e => { if (e.get("panY")) { let t = e.get("start"), i = e.get("end"), s = this._getWheelSign(e) * n * (i - t) * o, a = t - s, r = i - s, l = this._fixWheel(a, r); a = l[0], r = l[1], this._handleWheelAnimation(e.zoom(a, r)) } })) } _handleSetWheel() { const e = this.get("wheelX"), t = this.get("wheelY"), i = this.plotContainer; "none" !== e || "none" !== t ? (this._wheelDp = i.events.on("wheel", (i => { const s = i.originalEvent; ("none" !== e && 0 != Math.abs(s.deltaX) || "none" !== t && 0 != Math.abs(s.deltaY)) && this.handleWheel(i) })), this._disposers.push(this._wheelDp)) : this._wheelDp && this._wheelDp.dispose() } _getWheelSign(e) { let t = 1; return e.get("renderer").get("inversed") && (t = -1), t } _fixWheel(e, t) { const i = t - e; return e < 0 && (t = (e = 0) + i), t > 1 && (e = (t = 1) - i), [e, t] } _handlePlotDown(e) { const t = e.originalEvent; if (2 == t.button) return; const i = this.plotContainer; let s = i.toLocal(e.point); if (this.get("pinchZoomX") || this.get("pinchZoomY")) { if (t.pointerId && p.keys(i._downPoints).length > 0) { const e = this.xAxes.getIndex(0), t = this.yAxes.getIndex(0); e && (this._downStartX = e.get("start", 0), this._downEndX = e.get("end", 1)), t && (this._downStartY = t.get("start", 0), this._downEndY = t.get("end", 1)) } } if ((this.get("panX") || this.get("panY")) && s.x >= 0 && s.y >= 0 && s.x <= i.width() && s.y <= this.height()) { this._downPoint = { x: t.clientX, y: t.clientY }; const i = this.get("panX"), s = this.get("panY"); i && this.xAxes.each((e => { e._panStart = e.get("start"), e._panEnd = e.get("end") })), s && this.yAxes.each((e => { e._panStart = e.get("start"), e._panEnd = e.get("end") })); const a = "panstarted"; this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this, originalEvent: e.originalEvent }) } } _handleWheelAnimation(e) { e ? e.events.on("stopped", (() => { this._dispatchWheelAnimation() })) : this._dispatchWheelAnimation() } _dispatchWheelAnimation() { const e = "wheelended"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }) } _handlePlotUp(e) { const t = this._downPoint; if (t && (this.get("panX") || this.get("panY"))) { if (e.originalEvent.clientX == t.x && e.originalEvent.clientY == t.y) { const t = "pancancelled"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent }) } const i = "panended"; this.events.isEnabled(i) && this.events.dispatch(i, { type: i, target: this, originalEvent: e.originalEvent }) } this._downPoint = void 0, this.xAxes.each((e => { e._isPanning = !1 })), this.yAxes.each((e => { e._isPanning = !1 })) } _handlePlotMove(e) { const t = this.plotContainer; if (this.get("pinchZoomX") || this.get("pinchZoomY")) { const i = e.originalEvent.pointerId; if (i && (this._movePoints[i] = e.point, p.keys(t._downPoints).length > 1)) return void this._handlePinch() } let i = this._downPoint; if (i) { i = t.toLocal(this._root.documentPointToRoot(i)); let s = t.toLocal(e.point); const a = this.get("panX"), r = this.get("panY"); if (a) { let e = this.get("scrollbarX"); e && e.events.disableType("rangechanged"), this.xAxes.each((e => { if (e.get("panX")) { e._isPanning = !0; let a = e._panStart, r = e._panEnd, n = (r - a) * (i.x - s.x) / t.width(); e.get("renderer").get("inversed") && (n *= -1); let o = a + n, l = r + n; l - o < 1 + 2 * e.get("maxDeviation", 1) && (e.set("start", o), e.set("end", l)) } })), e && e.events.enableType("rangechanged") } if (r) { let e = this.get("scrollbarY"); e && e.events.disableType("rangechanged"), this.yAxes.each((e => { if (e.get("panY")) { e._isPanning = !0; let a = e._panStart, r = e._panEnd, n = (r - a) * (i.y - s.y) / t.height(); e.get("renderer").get("inversed") && (n *= -1); let o = a - n, l = r - n; l - o < 1 + 2 * e.get("maxDeviation", 1) && (e.set("start", o), e.set("end", l)) } })), e && e.events.enableType("rangechanged") } } } _handlePinch() { const e = this.plotContainer; let t = 0, i = [], s = []; if (p.each(e._downPoints, ((e, a) => { i[t] = a; let r = this._movePoints[e]; r && (s[t] = r), t++ })), i.length > 1 && s.length > 1) { const t = e.width(), a = e.height(); let r = i[0], n = i[1], o = s[0], l = s[1]; if (r && n && o && l) { if (o = e.toLocal(o), l = e.toLocal(l), r = e.toLocal(r), n = e.toLocal(n), this.get("pinchZoomX")) { const e = this._downStartX, i = this._downEndX; if (null != e && null != i) { r.x > n.x && ([r, n] = [n, r], [o, l] = [l, o]); let s = e + r.x / t * (i - e), a = e + n.x / t * (i - e), h = e + o.x / t * (i - e), c = e + l.x / t * (i - e), u = Math.max(.001, a - s) / Math.max(.001, c - h), d = e * u + s - h * u, m = i * u + a - c * u; this.xAxes.each((e => { let t = e.fixPosition(d), i = e.fixPosition(m); e.zoom(t, i, 0) })) } } if (this.get("pinchZoomY")) { const e = this._downStartY, t = this._downEndY; if (null != e && null != t) { r.y < n.y && ([r, n] = [n, r], [o, l] = [l, o]); let i = e + (1 - r.y / a) * (t - e), s = e + (1 - n.y / a) * (t - e), h = e + (1 - o.y / a) * (t - e), c = e + (1 - l.y / a) * (t - e), u = Math.max(.001, s - i) / Math.max(.001, c - h), d = e * u + i - h * u, m = t * u + s - c * u; this.yAxes.each((e => { let t = e.fixPosition(d), i = e.fixPosition(m); e.zoom(t, i, 0) })) } } } } } _handleCursorPosition() { const e = this.get("cursor"); if (e) { const t = e.getPrivate("point"); let i = e.get("snapToSeries"); if (e._downPoint && (i = void 0), i && t) { const s = e.get("snapToSeriesBy"), a = []; u.each(i, (e => { if (!e.isHidden() && !e.isHiding()) if ("x!" != s && "y!" != s) { const t = e.startIndex(), i = e.endIndex(); for (let s = t; s < i; s++) { const t = e.dataItems[s]; t && !t.isHidden() && a.push(t) } } else { const t = e.get("tooltipDataItem"); t && a.push(t) } })); let r, n = 1 / 0; if (u.each(a, (e => { const i = e.get("point"); if (i) { let a = 0; a = "x" == s || "x!" == s ? Math.abs(t.x - i.x) : "y" == s || "y!" == s ? Math.abs(t.y - i.y) : Math.hypot(t.x - i.x, t.y - i.y), a < n && (n = a, r = e) } })), u.each(i, (e => { const t = e.get("tooltip"); t && t._setDataItem(void 0) })), r) { let t = r.component; t.showDataItemTooltip(r), t.setRaw("tooltipDataItem", r); const i = r.get("point"); i && e.handleMove(t.toGlobal({ x: i.x - t.x(), y: i.y - t.y() }), !0) } } } } _updateCursor() { let e = this.get("cursor"); e && e.updateCursor() } _addCursor(e) { this.plotContainer.children.push(e) } _prepareChildren() { if (super._prepareChildren(), this.series.each((e => { this._colorize(e) })), (this.isDirty("wheelX") || this.isDirty("wheelY")) && this._handleSetWheel(), this.isDirty("cursor")) { const e = this._prevSettings.cursor, t = this.get("cursor"); t !== e && (this._disposeProperty("cursor"), e && e.dispose(), t && (t._setChart(this), this._addCursor(t), this._pushPropertyDisposer("cursor", t.events.on("selectended", (() => { this._handleCursorSelectEnd() })))), this._prevSettings.cursor = t) } if (this.isDirty("scrollbarX")) { const e = this._prevSettings.scrollbarX, t = this.get("scrollbarX"); t !== e && (this._disposeProperty("scrollbarX"), e && e.dispose(), t && (t.parent || this.topAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarX", t.events.on("rangechanged", (e => { this._handleScrollbar(this.xAxes, e.start, e.end, e.grip) }))), this._pushPropertyDisposer("scrollbarX", t.events.on("released", (() => { this.xAxes.each((e => { e.get("zoomable") && this._handleAxisSelection(e) })) }))), t.setPrivate("positionTextFunction", (e => { const t = this.xAxes.getIndex(0); return t && t.getTooltipText(e, !1) || "" }))), this._prevSettings.scrollbarX = t) } if (this.isDirty("scrollbarY")) { const e = this._prevSettings.scrollbarY, t = this.get("scrollbarY"); t !== e && (this._disposeProperty("scrollbarY"), e && e.dispose(), t && (t.parent || this.rightAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarY", t.events.on("rangechanged", (e => { this._handleScrollbar(this.yAxes, e.start, e.end, e.grip) }))), this._pushPropertyDisposer("scrollbarY", t.events.on("released", (() => { this.yAxes.each((e => { e.get("zoomable") && this._handleAxisSelection(e) })) }))), t.setPrivate("positionTextFunction", (e => { const t = this.yAxes.getIndex(0); return t && t.getTooltipText(e, !1) || "" }))), this._prevSettings.scrollbarY = t) } this._handleZoomOut() } _processSeries(e) { super._processSeries(e); const t = e.get("xAxis"), i = e.get("yAxis"); u.move(t.series, e), u.move(i.series, e), e._posXDp = e.addDisposer(t.events.on("positionchanged", (() => { e._fixPosition() }))), e._posXDp = e.addDisposer(i.events.on("positionchanged", (() => { e._fixPosition() }))), e.get("baseAxis") || (i.isType("CategoryAxis") || i.isType("DateAxis") ? e.set("baseAxis", i) : e.set("baseAxis", t)), e.get("stacked") && (e._markDirtyKey("stacked"), u.each(e.dataItems, (e => { e.set("stackToItemY", void 0), e.set("stackToItemX", void 0) }))), e._markDirtyAxes(), i.markDirtyExtremes(), t.markDirtyExtremes(), t._seriesAdded = !0, i._seriesAdded = !0, this._colorize(e) } _colorize(e) { const t = this.get("colors"); if (t && null == e.get("fill")) { const i = t.next(); e._setSoft("stroke", i), e._setSoft("fill", i) } const i = this.get("patterns"); if (i && null == e.get("fillPattern")) { const t = i.next(); e._setSoft("fillPattern", t) } } _handleCursorSelectEnd() { const e = this.get("cursor"), t = e.get("behavior"), i = e.getPrivate("downPositionX", 0), s = e.getPrivate("downPositionY", 0), a = Math.min(1, Math.max(0, e.getPrivate("positionX", .5))), r = Math.min(1, Math.max(0, e.getPrivate("positionY", .5))); this.xAxes.each((e => { if ("zoomX" === t || "zoomXY" === t) { let t = e.toAxisPosition(i), s = e.toAxisPosition(a); e.zoom(t, s) } e.setPrivate("updateScrollbar", !0) })), this.yAxes.each((e => { if ("zoomY" === t || "zoomXY" === t) { let t = e.toAxisPosition(s), i = e.toAxisPosition(r); e.zoom(t, i) } e.setPrivate("updateScrollbar", !0) })) } _handleScrollbar(e, t, i, s) { e.each((e => { let a = e.fixPosition(t), r = e.fixPosition(i), n = e.zoom(a, r, void 0, s); const o = "updateScrollbar"; e.setPrivateRaw(o, !1), n ? n.events.on("stopped", (() => { e.setPrivateRaw(o, !0) })) : e.setPrivateRaw(o, !0) })) } _processAxis(e, t) { return e.events.onAll((e => { if ("clear" === e.type) u.each(e.oldValues, (e => { this._removeAxis(e) })); else if ("push" === e.type) t.children.push(e.newValue), e.newValue.processChart(this); else if ("setIndex" === e.type) t.children.setIndex(e.index, e.newValue), e.newValue.processChart(this); else if ("insertIndex" === e.type) t.children.insertIndex(e.index, e.newValue), e.newValue.processChart(this); else if ("removeIndex" === e.type) this._removeAxis(e.oldValue); else { if ("moveIndex" !== e.type) throw new Error("Unknown IListEvent type"); t.children.moveValue(e.value, e.newIndex), e.value.processChart(this) } })) } _removeAxis(e) { if (!e.isDisposed()) { const t = e.parent; t && t.children.removeValue(e); const i = e.gridContainer, s = i.parent; s && s.children.removeValue(i); const a = e.topGridContainer, r = a.parent; r && r.children.removeValue(a) } } _updateChartLayout() { const e = this.leftAxesContainer.width(), t = this.rightAxesContainer.width(), i = this.bottomAxesContainer; i.set("paddingLeft", e), i.set("paddingRight", t); const s = this.topAxesContainer; s.set("paddingLeft", e), s.set("paddingRight", t) } processAxis(e) { this.get("cursor") && (this.addDisposer(e.on("start", (() => { this._updateCursor() }))), this.addDisposer(e.on("end", (() => { this._updateCursor() })))) } _handleAxisSelection(e, t) { let i = e.fixPosition(e.get("start", 0)), s = e.fixPosition(e.get("end", 1)); if (i > s && ([i, s] = [s, i]), -1 != this.xAxes.indexOf(e)) { if (t || e.getPrivate("updateScrollbar")) { let e = this.get("scrollbarX"); !e || e.getPrivate("isBusy") && !t || (e.setRaw("start", i), e.setRaw("end", s), e.updateGrips()) } } else if (-1 != this.yAxes.indexOf(e) && (t || e.getPrivate("updateScrollbar"))) { let e = this.get("scrollbarY"); !e || e.getPrivate("isBusy") && !t || (e.setRaw("start", i), e.setRaw("end", s), e.updateGrips()) } this._handleZoomOut() } _handleZoomOut() { let e = this.zoomOutButton; if (e && e.parent) { let t = !1; this.xAxes.each((e => { 0 == b.round(e.get("start", 0), 6) && 1 == b.round(e.get("end", 1), 6) || (t = !0) })), this.yAxes.each((e => { 0 == b.round(e.get("start", 0), 6) && 1 == b.round(e.get("end", 1), 6) || (t = !0) })), t ? e.isHidden() && e.show() : e.hide() } } inPlot(e) { const t = this.plotContainer, i = this.getPrivate("otherCharts", this._otherCharts), s = t.toGlobal(e); if (e.x >= -.5 && e.y >= -.5 && e.x <= t.width() + .5 && e.y <= t.height() + .5) return !0; if (i) for (let e = i.length - 1; e >= 0; e--) { const t = i[e]; if (t != this) { const e = t.plotContainer, i = this._root.rootPointToDocument(s), a = t._root.documentPointToRoot(i), r = e.toLocal(a); if (r.x >= -.1 && r.y >= -.1 && r.x <= e.width() + .1 && r.y <= e.height() + .1) return !0 } } return !1 } arrangeTooltips() { const e = this.plotContainer, t = e.width(), i = e.height(), s = this.height(); let a = e._display.toGlobal({ x: 0, y: 0 }), r = e._display.toGlobal({ x: t, y: i }); const n = []; let o, h, c = 0, p = 1 / 0, g = this._movePoint, b = this.get("maxTooltipDistance"), _ = this.get("maxTooltipDistanceBy", "xy"); d.isNumber(b) && this.series.each((e => { if (!e.isHidden()) { const t = e.get("tooltip"); if (t) { let i = t.get("pointTo"); if (i) { let t = Math.hypot(g.x - i.x, g.y - i.y); "x" == _ ? t = Math.abs(g.x - i.x) : "y" == _ && (t = Math.abs(g.y - i.y)), t < p && (p = t, o = e, h = i) } } } })); const f = []; if (this.series.each((e => { const t = e.get("tooltip"); if (t && !t.get("forceHidden")) { let i = !1, s = t.get("pointTo"); if (s) { if (b >= 0) { let s = t.get("pointTo"); if (s && h && e != o) { let e = Math.hypot(h.x - s.x, h.y - s.y); "x" == _ ? e = Math.abs(h.x - s.x) : "y" == _ && (e = Math.abs(h.y - s.y)), e > b && (i = !0) } } else -1 == b && e != o && (i = !0); this.inPlot(this._tooltipToLocal(s)) && t.dataItem ? i || (c += s.y) : i = !0, i || e.isHidden() || e.isHiding() ? t.hide(0) : (t.show(), n.push(t), f.push(e)) } } })), this.setPrivate("tooltipSeries", f), this.get("arrangeTooltips")) { const e = this._root.tooltipContainer, t = n.length; if (c / t > i / 2 + a.y) { n.sort(((e, t) => m.compareNumber(t.get("pointTo").y, e.get("pointTo").y))); let t = r.y; if (u.each(n, (i => { let s = i.height(), n = i.get("centerY"); n instanceof l.Percent && (s *= n.value), s += i.get("marginBottom", 0), i.set("bounds", { left: a.x, top: a.y, right: r.x, bottom: t }), i.setPrivate("customData", { left: a.x, top: a.y, right: r.x, bottom: t }), t = Math.min(t - s, i._fy - s), i.parent == e && e.children.moveValue(i, 0) })), t < 0) { n.reverse(); let e = t; u.each(n, (i => { let s = i.get("bounds"); if (s) { let a = s.top - t, r = s.bottom - t; a < e && (a = e, r = a + i.height()), i.set("bounds", { left: s.left, top: a, right: s.right, bottom: r }), e = s.bottom - t + i.get("marginBottom", 0) } })) } } else { n.reverse(), n.sort(((e, t) => m.compareNumber(e.get("pointTo").y, t.get("pointTo").y))); let t = 0; if (u.each(n, (i => { let n = i.height(), o = i.get("centerY"); o instanceof l.Percent && (n *= o.value), n += i.get("marginBottom", 0), i.set("bounds", { left: a.x, top: t, right: r.x, bottom: Math.max(a.y + s, t + n) }), i.parent == e && e.children.moveValue(i, 0), t = Math.max(t + n, i._fy + n) })), t > s) { n.reverse(); let e = s; u.each(n, (i => { let a = i.get("bounds"); if (a) { let r = a.top - (s - t), n = a.bottom - (s - t); n > e && (n = e, r = n - i.height()), i.set("bounds", { left: a.left, top: r, right: a.right, bottom: n }), e = n - i.height() - i.get("marginBottom", 0) } })) } } } } _tooltipToLocal(e) { return this.plotContainer.toLocal(e) } zoomOut() { this.xAxes.each((e => { e.setPrivate("updateScrollbar", !0), e.zoom(0, 1) })), this.yAxes.each((e => { e.setPrivate("updateScrollbar", !0), e.zoom(0, 1) })) } _dispose() { super._dispose(); const e = this.get("cursor"); e && e.dispose() } } Object.defineProperty(_, "className", { enumerable: !0, configurable: !0, writable: !0, value: "XYChart" }), Object.defineProperty(_, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: n.SerialChart.classNames.concat([_.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChartDefaultTheme.js": (e, t, i) => { i.r(t), i.d(t, { XYChartDefaultTheme: () => m }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/Theme.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); class m extends s.Theme { setupDefaultRules() { super.setupDefaultRules(); const e = this._root.interfaceColors, t = this._root.language, i = this.rule.bind(this); i("XYChart").setAll({ colors: n.ColorSet.new(this._root, {}), paddingLeft: 20, paddingRight: 20, paddingTop: 16, paddingBottom: 16, panX: !1, panY: !1, wheelStep: .25, arrangeTooltips: !0, pinchZoomX: !1, pinchZoomY: !1 }), i("XYSeries").setAll({ legendLabelText: "{name}" }), i("Rectangle", ["plotbackground", "xy", "background"]).setAll({ fill: r.Color.fromHex(0), fillOpacity: 0 }), i("XYChart", ["scrollbar", "chart"]).setAll({ paddingBottom: 0, paddingLeft: 0, paddingTop: 0, paddingRight: 0, colors: n.ColorSet.new(this._root, { saturation: 0 }) }); { const t = i("Graphics", ["scrollbar", "overlay"]); t.setAll({ fillOpacity: .5 }), (0, o.setColor)(t, "fill", e, "background") } i("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({ cornerRadiusTR: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusBL: 0, fillOpacity: 0, focusable: !0 }), i("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: .4 }), i("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({ cornerRadiusTL: 0, cornerRadiusBL: 0, cornerRadiusTR: 0, cornerRadiusBR: 0 }), i("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({ cornerRadiusBL: 40, cornerRadiusBR: 40, cornerRadiusTL: 40, cornerRadiusTR: 40 }), i("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({ strokeOpacity: 0, inside: !0 }), i("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({ strokeOpacity: 0, inside: !0, minGridDistance: 5 }), i("AxisLabel", ["xy", "scrollbar", "x"]).setAll({ opacity: .5, centerY: a.p100, minPosition: .01, maxPosition: .99, fontSize: "0.8em" }), i("AxisLabel", ["category"]).setAll({ text: "{category}", populateText: !0 }), i("AxisLabel", ["x"]).setAll({ centerY: 0 }), i("AxisLabel", ["x", "inside"]).setAll({ centerY: a.p100 }), i("AxisLabel", ["x", "inside", "opposite"]).setAll({ centerY: 0 }), i("AxisLabel", ["x", "opposite"]).setAll({ centerY: a.p100 }), i("AxisLabel", ["y"]).setAll({ centerX: a.p100 }), i("AxisLabel", ["y", "inside"]).setAll({ centerX: 0 }), i("AxisLabel", ["y", "inside", "opposite"]).setAll({ centerX: a.p100 }), i("AxisLabel", ["y", "opposite"]).setAll({ centerX: 0 }), i("AxisLabel", ["minor"]).setAll({ fontSize: "0.6em" }), i("AxisLabel", ["xy", "scrollbar", "y"]).setAll({ visible: !1 }), i("Grid", ["xy", "scrollbar", "y"]).setAll({ visible: !1 }), i("Grid", ["xy", "scrollbar", "x"]).setAll({ opacity: .5 }), i("XYCursor").setAll({ behavior: "none", layer: 30, exportable: !1, snapToSeriesBy: "xy", moveThreshold: 1 }); { const s = i("Grid", ["cursor", "x"]); s.setAll({ forceInactive: !0, strokeOpacity: .8, strokeDasharray: [2, 2], role: "slider", ariaLabel: t.translate("Use left and right arrows to move selection") }), (0, o.setColor)(s, "stroke", e, "alternativeBackground") } { const s = i("Grid", ["cursor", "y"]); s.setAll({ forceInactive: !0, strokeOpacity: .8, strokeDasharray: [2, 2], role: "slider", ariaLabel: t.translate("Use up and down arrows to move selection") }), (0, o.setColor)(s, "stroke", e, "alternativeBackground") } { const t = i("Graphics", ["cursor", "selection"]); t.setAll({ fillOpacity: .15 }), (0, o.setColor)(t, "fill", e, "alternativeBackground") } i("Axis").setAll({ start: 0, end: 1, minZoomCount: 1, maxZoomCount: 1 / 0, maxZoomFactor: 1e3, maxDeviation: .1, snapTooltip: !0, tooltipLocation: .5, panX: !0, panY: !0, zoomX: !0, zoomY: !0, fixAxisSize: !0 }), i("AxisLabel").setAll({ location: .5, multiLocation: 0, centerX: a.p50, centerY: a.p50, paddingTop: 3, paddingBottom: 3, paddingLeft: 5, paddingRight: 5 }), i("Container", ["axis", "header"]).setAll({ layer: 30 }), i("Rectangle", ["axis", "header", "background"]).setAll({ crisp: !0 }); { const t = i("AxisRenderer"); t.setAll({ crisp: !0, strokeOpacity: 0 }), (0, o.setColor)(t, "stroke", e, "grid") } i("AxisRendererX").setAll({ minGridDistance: 120, opposite: !1, inversed: !1, cellStartLocation: 0, cellEndLocation: 1, width: a.p100 }), i("AxisRendererY").setAll({ minGridDistance: 40, opposite: !1, inversed: !1, cellStartLocation: 0, cellEndLocation: 1, height: a.p100 }); { const t = i("Rectangle", ["axis", "thumb"]); t.setAll({ fillOpacity: 0 }), (0, o.setColor)(t, "fill", e, "alternativeBackground"), t.states.create("hover", { fillOpacity: .1 }) } i("Rectangle", ["axis", "thumb", "x"]).setAll({ cursorOverStyle: "ew-resize" }), i("Rectangle", ["axis", "thumb", "y"]).setAll({ cursorOverStyle: "ns-resize" }); { const t = i("Grid"); t.setAll({ location: 0, strokeOpacity: .15, crisp: !0 }), (0, o.setColor)(t, "stroke", e, "grid") } { const t = i("Grid", ["minor"]); t.setAll({ location: 0, strokeOpacity: .07, crisp: !0 }), (0, o.setColor)(t, "stroke", e, "grid") } i("Grid", ["base"]).setAll({ strokeOpacity: .3 }); { const t = i("Graphics", ["axis", "fill"]); t.setAll({ visible: !1, isMeasured: !1, position: "absolute", fillOpacity: .05 }), (0, o.setColor)(t, "fill", e, "alternativeBackground") } i("Graphics", ["axis", "fill", "range"]).setAll({ isMeasured: !0 }), i("Graphics", ["series", "fill", "range"]).setAll({ visible: !1, isMeasured: !0 }), i("Grid", ["series", "range"]).setAll({ visible: !1 }), i("AxisTick", ["series", "range"]).setAll({ visible: !1 }), i("AxisLabel", ["series", "range"]).setAll({ visible: !1 }); { const t = i("AxisTick"); t.setAll({ location: .5, multiLocation: 0, strokeOpacity: 1, isMeasured: !1, position: "absolute", visible: !1 }), (0, o.setColor)(t, "stroke", e, "grid") } i("CategoryAxis").setAll({ startLocation: 0, endLocation: 1, fillRule: (e, t) => { const i = e.get("axisFill"); i && (h.isNumber(t) && t % 2 != 0 ? i.setPrivate("visible", !1) : i.setPrivate("visible", !0)) } }); const s = [{ timeUnit: "millisecond", count: 1 }, { timeUnit: "millisecond", count: 5 }, { timeUnit: "millisecond", count: 10 }, { timeUnit: "millisecond", count: 50 }, { timeUnit: "millisecond", count: 100 }, { timeUnit: "millisecond", count: 500 }, { timeUnit: "second", count: 1 }, { timeUnit: "second", count: 5 }, { timeUnit: "second", count: 10 }, { timeUnit: "second", count: 30 }, { timeUnit: "minute", count: 1 }, { timeUnit: "minute", count: 5 }, { timeUnit: "minute", count: 10 }, { timeUnit: "minute", count: 15 }, { timeUnit: "minute", count: 30 }, { timeUnit: "hour", count: 1 }, { timeUnit: "hour", count: 3 }, { timeUnit: "hour", count: 6 }, { timeUnit: "hour", count: 12 }, { timeUnit: "day", count: 1 }, { timeUnit: "day", count: 2 }, { timeUnit: "day", count: 3 }, { timeUnit: "day", count: 4 }, { timeUnit: "day", count: 5 }, { timeUnit: "week", count: 1 }, { timeUnit: "month", count: 1 }, { timeUnit: "month", count: 2 }, { timeUnit: "month", count: 3 }, { timeUnit: "month", count: 6 }, { timeUnit: "year", count: 1 }, { timeUnit: "year", count: 2 }, { timeUnit: "year", count: 5 }, { timeUnit: "year", count: 10 }, { timeUnit: "year", count: 50 }, { timeUnit: "year", count: 100 }, { timeUnit: "year", count: 200 }, { timeUnit: "year", count: 500 }, { timeUnit: "year", count: 1e3 }, { timeUnit: "year", count: 2e3 }, { timeUnit: "year", count: 5e3 }, { timeUnit: "year", count: 1e4 }, { timeUnit: "year", count: 1e5 }], m = { millisecond: t.translate("_date_millisecond"), second: t.translate("_date_second"), minute: t.translate("_date_minute"), hour: t.translate("_date_hour"), day: t.translate("_date_day"), week: t.translate("_date_day"), month: t.translate("_date_month"), year: t.translate("_date_year") }, p = { millisecond: t.translate("_date_millisecond"), second: t.translate("_date_second"), minute: t.translate("_date_minute"), hour: t.translate("_date_day"), day: t.translate("_date_day"), week: t.translate("_date_day"), month: t.translate("_date_month") + " " + t.translate("_date_year"), year: t.translate("_date_year") }, g = { millisecond: t.translate("_date_millisecond_full"), second: t.translate("_date_second_full"), minute: t.translate("_date_minute_full"), hour: t.translate("_date_hour_full"), day: t.translate("_date_day_full"), week: t.translate("_date_week_full"), month: t.translate("_date_month_full"), year: t.translate("_date_year") }; i("CategoryDateAxis").setAll({ markUnitChange: !0, gridIntervals: d.copy(s), dateFormats: u.copy(m), periodChangeDateFormats: u.copy(p) }), i("DateAxis").setAll({ maxZoomFactor: null, strictMinMax: !0, startLocation: 0, endLocation: 1, markUnitChange: !0, groupData: !1, groupCount: 500, gridIntervals: d.copy(s), dateFormats: u.copy(m), periodChangeDateFormats: u.copy(p), tooltipDateFormats: g, groupIntervals: [{ timeUnit: "millisecond", count: 1 }, { timeUnit: "millisecond", count: 10 }, { timeUnit: "millisecond", count: 100 }, { timeUnit: "second", count: 1 }, { timeUnit: "second", count: 10 }, { timeUnit: "minute", count: 1 }, { timeUnit: "minute", count: 10 }, { timeUnit: "hour", count: 1 }, { timeUnit: "day", count: 1 }, { timeUnit: "week", count: 1 }, { timeUnit: "month", count: 1 }, { timeUnit: "year", count: 1 }], fillRule: e => { const t = e.get("axisFill"); if (t) { const i = e.component, s = e.get("value"), a = e.get("endValue"), r = i.intervalDuration(), n = i.getPrivate("baseInterval"), o = i.getPrivate("gridInterval", n); let h = i.getPrivate("min", 0); if (h = l.round(new Date(h), o.timeUnit, o.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), null != s && null != a) { const e = Math.round(Math.round((s - h) / r)) / 2; e == Math.round(e) ? t.setPrivate("visible", !0) : t.setPrivate("visible", !1) } } } }), i("GaplessDateAxis").setAll({ fillRule: e => { const t = e.get("axisFill"); if (t) { const i = e.get("index"); let s = !1; h.isNumber(i) && i % 2 != 0 || (s = !0), t.setPrivate("visible", s) } } }), i("ValueAxis").setAll({ baseValue: 0, logarithmic: !1, strictMinMax: !1, autoZoom: !0, fillRule: e => { const t = e.get("axisFill"); if (t) { const i = e.component, s = e.get("value"), a = i.getPrivate("step"); h.isNumber(s) && h.isNumber(a) && (c.round(s / a / 2, 5) == Math.round(s / a / 2) ? t.setPrivate("visible", !1) : t.setPrivate("visible", !0)) } } }), i("DurationAxis").setAll({ baseUnit: "second" }), i("XYSeries").setAll({ maskBullets: !0, stackToNegative: !0, locationX: .5, locationY: .5, snapTooltip: !1, openValueXGrouped: "open", openValueYGrouped: "open", valueXGrouped: "close", valueYGrouped: "close", seriesTooltipTarget: "series" }), i("BaseColumnSeries").setAll({ adjustBulletPosition: !0 }), i("ColumnSeries").setAll({ clustered: !0 }), i("RoundedRectangle", ["series", "column"]).setAll({ position: "absolute", isMeasured: !1, width: (0, a.percent)(70), height: (0, a.percent)(70), strokeWidth: 1, strokeOpacity: 1, cornerRadiusBL: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusTR: 0, fillOpacity: 1, role: "figure" }), i("LineSeries").setAll({ connect: !0, autoGapCount: 1.1, stackToNegative: !1 }), i("Graphics", ["series", "stroke"]).setAll({ position: "absolute", strokeWidth: 1, strokeOpacity: 1, isMeasured: !1 }), i("Graphics", ["series", "fill"]).setAll({ visible: !1, fillOpacity: 0, position: "absolute", strokeWidth: 0, strokeOpacity: 0, isMeasured: !1 }), i("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({ draw: (e, t) => { const i = t.parent; if (i) { const t = i.height(), s = i.width(); e.moveTo(0, t / 2), e.lineTo(s, t / 2) } } }); { const t = i("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {}); (0, o.setColor)(t, "stroke", e, "disabled") } i("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({ draw: (e, t) => { const i = t.parent; if (i) { const t = i.height(), s = i.width(); e.moveTo(0, 0), e.lineTo(s, 0), e.lineTo(s, t), e.lineTo(0, t), e.lineTo(0, 0) } } }); { const t = i("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {}); (0, o.setColor)(t, "stroke", e, "disabled") } i("SmoothedXYLineSeries").setAll({ tension: .5 }), i("SmoothedXLineSeries").setAll({ tension: .5 }), i("SmoothedYLineSeries").setAll({ tension: .5 }), i("Candlestick").setAll({ position: "absolute", isMeasured: !1, width: (0, a.percent)(50), height: (0, a.percent)(50), strokeWidth: 1, strokeOpacity: 1, cornerRadiusBL: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusTR: 0, fillOpacity: 1, role: "figure" }), i("OHLC").setAll({ width: (0, a.percent)(80), height: (0, a.percent)(80) }), i("CandlestickSeries").setAll({ lowValueXGrouped: "low", lowValueYGrouped: "low", highValueXGrouped: "high", highValueYGrouped: "high", openValueXGrouped: "open", openValueYGrouped: "open", valueXGrouped: "close", valueYGrouped: "close" }); { const t = i("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {}); (0, o.setColor)(t, "fill", e, "positive"), (0, o.setColor)(t, "stroke", e, "positive") } { const t = i("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {}); (0, o.setColor)(t, "fill", e, "negative"), (0, o.setColor)(t, "stroke", e, "negative") } i("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 }), i("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 }); { const t = i("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {}); (0, o.setColor)(t, "fill", e, "positive"), (0, o.setColor)(t, "stroke", e, "positive") } { const t = i("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {}); (0, o.setColor)(t, "fill", e, "negative"), (0, o.setColor)(t, "stroke", e, "negative") } i("RoundedRectangle", ["rangegrip"]).setAll({ strokeOpacity: 0, fillOpacity: 0, strokeWidth: 1, width: 12, height: 12 }); { const t = i("Graphics", ["rangegrip", "button", "icon"]); t.setAll({ interactive: !1, crisp: !0, strokeOpacity: .5, draw: e => { e.moveTo(0, .5), e.lineTo(0, 12.5), e.moveTo(2, .5), e.lineTo(2, 12.5), e.moveTo(4, .5), e.lineTo(4, 12.5) } }), (0, o.setColor)(t, "stroke", e, "secondaryButtonText") } i("Button", ["rangegrip"]).setAll({ draggable: !0, paddingTop: 0, paddingBottom: 0 }), i("Button", ["rangegrip", "vertical"]).setAll({ rotation: 90, cursorOverStyle: "ns-resize", centerX: a.p50 }), i("Button", ["rangegrip", "horizontal"]).setAll({ cursorOverStyle: "ew-resize", centerX: a.p50 }), i("Button", ["rangegrip", "vertical", "left"]).setAll({ centerY: a.p100 }), i("Button", ["rangegrip", "vertical", "right"]).setAll({ centerY: 0 }), i("Button", ["rangegrip", "horizontal", "top"]).setAll({ centerY: 0 }), i("Button", ["rangegrip", "horizontal", "bottom"]).setAll({ centerY: a.p100 }) } } }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js": (e, t, i) => { i.r(t), i.d(t, { XYCursor: () => d }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"); class d extends s.Container { constructor() { super(...arguments), Object.defineProperty(this, "_alwaysShow", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "lineX", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(n.Grid.new(this._root, { themeTags: ["x"] })) }), Object.defineProperty(this, "lineY", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(n.Grid.new(this._root, { themeTags: ["y"] })) }), Object.defineProperty(this, "selection", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(r.Graphics.new(this._root, { themeTags: ["selection", "cursor"], layer: 30 })) }), Object.defineProperty(this, "_movePoint", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_lastPoint", { enumerable: !0, configurable: !0, writable: !0, value: { x: 0, y: 0 } }), Object.defineProperty(this, "_lastPoint2", { enumerable: !0, configurable: !0, writable: !0, value: { x: 0, y: 0 } }), Object.defineProperty(this, "_tooltipX", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_tooltipY", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "chart", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_toX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_toY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _afterNew() { this._settings.themeTags = l.mergeTags(this._settings.themeTags, ["xy", "cursor"]), super._afterNew(), this.setAll({ width: a.p100, height: a.p100, isMeasured: !0, position: "absolute" }), this.states.create("hidden", { visible: !0, opacity: 0 }), this._drawLines(), this.setPrivateRaw("visible", !1), this._disposers.push(this.setTimeout((() => { this.setPrivate("visible", !0) }), 500)), this._disposers.push(this.lineX.events.on("positionchanged", (() => { this._handleXLine() }))), this._disposers.push(this.lineY.events.on("positionchanged", (() => { this._handleYLine() }))), this._disposers.push(this.lineX.events.on("focus", (() => this._handleLineFocus()))), this._disposers.push(this.lineX.events.on("blur", (() => this._handleLineBlur()))), this._disposers.push(this.lineY.events.on("focus", (() => this._handleLineFocus()))), this._disposers.push(this.lineY.events.on("blur", (() => this._handleLineBlur()))), l.supports("keyboardevents") && this._disposers.push(l.addEventListener(document, "keydown", (e => { this._handleLineMove(l.getEventKey(e), e.ctrlKey) }))) } _setUpTouch() { const e = this.chart; e && (e.plotContainer._display.cancelTouch = "none" != this.get("behavior")) } _handleXLine() { let e = this.lineX.x(), t = !0; (e < 0 || e > this.width()) && (t = !1), this.lineX.setPrivate("visible", t) } _handleYLine() { let e = this.lineY.y(), t = !0; (e < 0 || e > this.height()) && (t = !1), this.lineY.setPrivate("visible", t) } _handleLineMove(e, t) { let i = ""; const s = this.chart; let a; if (s && s.xAxes.length) { this._root.focused(this.lineX) ? (i = "positionX", a = s.xAxes.getIndex(0)) : this._root.focused(this.lineY) && (a = s.yAxes.getIndex(0), i = "positionY"); let r = 1; if (t && (r = 5), a) { let t, s = a.get("renderer").get("inversed", !1); "ArrowRight" == e || "ArrowDown" == e ? t = 1 : "ArrowLeft" == e || "ArrowUp" == e ? t = -1 : "Tab" == e && (t = 0), null != t && (s && (t *= -1), this.set(i, a.nextPosition(t * r))) } } } _handleLineFocus() { this._alwaysShow = this.get("alwaysShow", !1), this.setAll({ positionX: this.getPrivate("positionX", 0), positionY: this.getPrivate("positionY", 0), alwaysShow: !0 }), this._handleLineMove("Tab") } _handleLineBlur() { (this.lineX.isFocus() || this.lineY.isFocus()) && this.setAll({ positionX: void 0, positionY: void 0, alwaysShow: this._alwaysShow }) } _prepareChildren() { if (super._prepareChildren(), this.isDirty("xAxis")) { this._tooltipX = !1; const e = this.get("xAxis"); if (e) { const t = e.get("tooltip"); t && (this._tooltipX = !0, this._disposers.push(t.on("pointTo", (() => { this._updateXLine(t) })))) } } if (this.isDirty("yAxis")) { this._tooltipY = !1; const e = this.get("yAxis"); if (e) { const t = e.get("tooltip"); t && (this._tooltipY = !0, this._disposers.push(t.on("pointTo", (() => { this._updateYLine(t) })))) } } } _handleSyncWith() { const e = this.chart; if (e) { const t = this.get("syncWith"), i = []; t && c.each(t, (e => { const t = e.chart; t && i.push(t) })), e._otherCharts = i } } _updateChildren() { if (super._updateChildren(), this._handleSyncWith(), this.isDirty("positionX") || this.isDirty("positionY")) { const e = this.get("positionX"), t = this.get("positionY"); null == e && null == t ? this.hide(0) : (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove()) } } _updateXLine(e) { let t = h.round(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).x, 3); this._toX != t && (this.lineX.animate({ key: "x", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toX = t) } _updateYLine(e) { let t = h.round(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).y, 3); this._toY != t && (this.lineY.animate({ key: "y", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toY = t) } _drawLines() { this.lineX.set("draw", (e => { e.moveTo(0, 0), e.lineTo(0, this.height()) })), this.lineY.set("draw", (e => { e.moveTo(0, 0), e.lineTo(this.width(), 0) })) } updateCursor() { this.get("alwaysShow") && (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0)))), this.handleMove() } _setChart(e) { this.chart = e, this._handleSyncWith(); const t = e.plotContainer; this.events.on("boundschanged", (() => { this._disposers.push(this.setTimeout((() => { this.updateCursor() }), 50)) })), l.supports("touchevents") && (this._disposers.push(t.events.on("click", (e => { l.isTouchEvent(e.originalEvent) && this._handleMove(e) }))), this._setUpTouch()), this._disposers.push(t.events.on("pointerdown", (e => { this._handleCursorDown(e) }))), this._disposers.push(t.events.on("globalpointerup", (e => { this._handleCursorUp(e), e.native || this.isHidden() || this._handleMove(e) }))), this._disposers.push(t.events.on("globalpointermove", (e => { (this.get("syncWith") || 0 != u.keys(t._downPoints).length || e.native || !this.isHidden()) && (this._handleMove(e), Math.hypot(this._lastPoint2.x - e.point.x, this._lastPoint2.y - e.point.y) > 1 && (this._handleLineBlur(), this._lastPoint2 = e.point)) }))); const i = this.parent; i && i.children.moveValue(this.selection) } _inPlot(e) { const t = this.chart; return !!t && t.inPlot(e) } _handleCursorDown(e) { if (2 == e.originalEvent.button) return; const t = e.point; let i = this._display.toLocal(t); const s = this.chart; if (this.selection.set("draw", (() => { })), s && this._inPlot(i)) { if (this._downPoint = i, "none" != this.get("behavior")) { this.selection.show(); const t = "selectstarted"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent }) } let t = this._getPosition(i).x, s = this._getPosition(i).y; this.setPrivate("downPositionX", t), this.setPrivate("downPositionY", s) } } _handleCursorUp(e) { if (this._downPoint) { const t = this.get("behavior", "none"); if ("none" != t) { "z" === t.charAt(0) && this.selection.hide(); const i = e.point; let s = this._display.toLocal(i); const a = this._downPoint, r = this.get("moveThreshold", 1); if (s && a) { let i = !1; if ("zoomX" !== t && "zoomXY" !== t && "selectX" !== t && "selectXY" !== t || Math.abs(s.x - a.x) > r && (i = !0), "zoomY" !== t && "zoomXY" !== t && "selectY" !== t && "selectXY" !== t || Math.abs(s.y - a.y) > r && (i = !0), i) { const t = "selectended"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent }) } else { const t = "selectcancelled"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent }) } } } } this._downPoint = void 0 } _handleMove(e) { if (this.getPrivate("visible")) { const t = this.chart; if (t && u.keys(t.plotContainer._downPoints).length > 1) return void this.set("forceHidden", !0); this.set("forceHidden", !1); const i = e.point, s = this._lastPoint; if (Math.round(s.x) === Math.round(i.x) && Math.round(s.y) === Math.round(i.y)) return; this._lastPoint = i, this.setPrivate("lastPoint", i), this.handleMove({ x: i.x, y: i.y }, !1, e.originalEvent) } } _getPosition(e) { return { x: e.x / this.width(), y: e.y / this.height() } } handleMove(e, t, i) { e || (e = this._movePoint); const s = this.get("alwaysShow"); if (!e) return void this.hide(0); this._movePoint = e; let a = this._display.toLocal(e), r = this.chart; if (r && (this._inPlot(a) || this._downPoint)) { if (r._movePoint = e, this.isHidden()) { this.show(); "z" == this.get("behavior", "").charAt(0) && this.selection.set("draw", (() => { })) } let n = a.x, l = a.y, h = this._getPosition(a); this.setPrivate("point", a); let c = this.get("snapToSeries"); this._downPoint && (c = void 0); let u = this.get("positionX"), d = h.x; o.isNumber(u) && (d = u); let m = this.get("positionY"), p = h.y; o.isNumber(m) && (p = m), this.setPrivate("positionX", d), this.setPrivate("positionY", p); const g = this._getPoint(d, p); if (n = g.x, l = g.y, r.xAxes.each((e => { e._handleCursorPosition(d, c), s && e.handleCursorShow() })), r.yAxes.each((e => { e._handleCursorPosition(p, c), s && e.handleCursorShow() })), !t) { r._handleCursorPosition(); const t = "cursormoved"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, point: e, originalEvent: i }) } this._updateLines(n, l), r.arrangeTooltips() } else if (!this._downPoint && !s) { this.hide(0); const e = "cursorhidden"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }) } this._downPoint && "none" != this.get("behavior") && this._updateSelection(a) } _getPoint(e, t) { return { x: this.width() * e, y: this.height() * t } } _updateLines(e, t) { this._tooltipX || this.lineX.set("x", e), this._tooltipY || this.lineY.set("y", t), this._drawLines() } _updateSelection(e) { const t = this.selection, i = this.get("behavior"), s = this.width(), a = this.height(); e.x < 0 && (e.x = 0), e.x > s && (e.x = s), e.y < 0 && (e.y = 0), e.y > a && (e.y = a), t.set("draw", (t => { const r = this._downPoint; r && ("zoomXY" === i || "selectXY" === i ? (t.moveTo(r.x, r.y), t.lineTo(r.x, e.y), t.lineTo(e.x, e.y), t.lineTo(e.x, r.y), t.lineTo(r.x, r.y)) : "zoomX" === i || "selectX" === i ? (t.moveTo(r.x, 0), t.lineTo(r.x, a), t.lineTo(e.x, a), t.lineTo(e.x, 0), t.lineTo(r.x, 0)) : "zoomY" !== i && "selectY" !== i || (t.moveTo(0, r.y), t.lineTo(s, r.y), t.lineTo(s, e.y), t.lineTo(0, e.y), t.lineTo(0, r.y))) })) } _onHide() { if (this.isHidden()) { let e = this.chart; e && (e.xAxes.each((e => { e.handleCursorHide() })), e.yAxes.each((e => { e.handleCursorHide() })), e.series.each((e => { e.handleCursorHide() }))) } super._onHide() } _onShow() { if (!this.isHidden()) { let e = this.chart; e && (e.xAxes.each((e => { e.handleCursorShow() })), e.yAxes.each((e => { e.handleCursorShow() }))) } super._onShow() } _dispose() { super._dispose(), this.selection.dispose() } } Object.defineProperty(d, "className", { enumerable: !0, configurable: !0, writable: !0, value: "XYCursor" }), Object.defineProperty(d, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Container.classNames.concat([d.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js": (e, t, i) => { i.r(t), i.d(t, { Axis: () => u }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class u extends s.Component { constructor() { super(...arguments), Object.defineProperty(this, "_series", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_isPanning", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "minorDataItems", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "labelsContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(a.Container.new(this._root, {})) }), Object.defineProperty(this, "gridContainer", { enumerable: !0, configurable: !0, writable: !0, value: a.Container.new(this._root, { width: r.p100, height: r.p100 }) }), Object.defineProperty(this, "topGridContainer", { enumerable: !0, configurable: !0, writable: !0, value: a.Container.new(this._root, { width: r.p100, height: r.p100 }) }), Object.defineProperty(this, "bulletsContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(a.Container.new(this._root, { isMeasured: !1, width: r.p100, height: r.p100, position: "absolute" })) }), Object.defineProperty(this, "chart", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_rangesDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_panStart", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_panEnd", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_sAnimation", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_eAnimation", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_skipSync", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "axisRanges", { enumerable: !0, configurable: !0, writable: !0, value: new n.List }), Object.defineProperty(this, "_seriesAxisRanges", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "ghostLabel", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_cursorPosition", { enumerable: !0, configurable: !0, writable: !0, value: -1 }), Object.defineProperty(this, "_snapToSeries", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_seriesValuesDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_seriesAdded", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "axisHeader", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(a.Container.new(this._root, { themeTags: ["axis", "header"], position: "absolute", background: o.Rectangle.new(this._root, { themeTags: ["header", "background"], fill: this._root.interfaceColors.get("background") }) })) }), Object.defineProperty(this, "_bullets", { enumerable: !0, configurable: !0, writable: !0, value: {} }) } _dispose() { this.gridContainer.dispose(), this.topGridContainer.dispose(), this.bulletsContainer.dispose(), this.labelsContainer.dispose(), this.axisHeader.dispose(), super._dispose() } _afterNew() { super._afterNew(), this.setPrivate("updateScrollbar", !0), this._disposers.push(this.axisRanges.events.onAll((e => { if ("clear" === e.type) l.each(e.oldValues, (e => { this.disposeDataItem(e) })); else if ("push" === e.type) this._processAxisRange(e.newValue, ["range"]); else if ("setIndex" === e.type) this._processAxisRange(e.newValue, ["range"]); else if ("insertIndex" === e.type) this._processAxisRange(e.newValue, ["range"]); else if ("removeIndex" === e.type) this.disposeDataItem(e.oldValue); else { if ("moveIndex" !== e.type) throw new Error("Unknown IStreamEvent type"); this._processAxisRange(e.value, ["range"]) } }))); const e = this.get("renderer"); e && (e.axis = this, e.processAxis()), this.children.push(e), this.ghostLabel = e.makeLabel(new s.DataItem(this, void 0, {}), []), this.ghostLabel.adapters.disable("text"), this.ghostLabel.setAll({ opacity: 0, tooltipText: void 0, tooltipHTML: void 0, interactive: !1 }), this.ghostLabel.events.disable() } _updateFinals(e, t) { } zoom(e, t, i, s) { if (this.get("zoomable", !0)) if (this._updateFinals(e, t), this.get("start") !== e || this.get("end") != t) { let a = this._sAnimation, r = this._eAnimation, n = this.get("maxDeviation", .5) * Math.min(1, t - e); e < -n && (e = -n), t > 1 + n && (t = 1 + n), e > t && ([e, t] = [t, e]), h.isNumber(i) || (i = this.get("interpolationDuration", 0)), s || (s = "end"); let o = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100)), l = o; 1 === t && 0 !== e && (s = e < this.get("start", 0) ? "start" : "end"), 0 === e && 1 !== t && (s = t > this.get("end", 1) ? "end" : "start"); let c = this.get("minZoomCount", 0), u = this.get("maxZoomCount", 1 / 0); h.isNumber(c) && (o = l / c); let d = 1; if (h.isNumber(u) && (d = l / u), "start" === s ? (u > 0 && 1 / (t - e) < d && (t = e + 1 / d), 1 / (t - e) > o && (t = e + 1 / o), t > 1 && t - e < 1 / o && (e = t - 1 / o)) : (u > 0 && 1 / (t - e) < d && (e = t - 1 / d), 1 / (t - e) > o && (e = t - 1 / o), e < 0 && t - e < 1 / o && (t = e + 1 / o)), 1 / (t - e) > o && (t = e + 1 / o), 1 / (t - e) > o && (e = t - 1 / o), null != u && null != c && e == this.get("start") && t == this.get("end")) { const e = this.chart; e && e._handleAxisSelection(this, !0) } if ((a && a.playing && a.to == e || this.get("start") == e) && (r && r.playing && r.to == t || this.get("end") == t)) return; if (i > 0) { let s, a, r = this.get("interpolationEasing"); if (this.get("start") != e && (s = this.animate({ key: "start", to: e, duration: i, easing: r })), this.get("end") != t && (a = this.animate({ key: "end", to: t, duration: i, easing: r })), this._sAnimation = s, this._eAnimation = a, s) return s; if (a) return a } else this.set("start", e), this.set("end", t) } else this._sAnimation && this._sAnimation.stop(), this._eAnimation && this._eAnimation.stop() } get series() { return this._series } _processAxisRange(e, t) { e.setRaw("isRange", !0), this._createAssets(e, t), this._rangesDirty = !0, this._prepareDataItem(e); const i = e.get("above"), s = this.topGridContainer, a = e.get("grid"); i && a && s.children.moveValue(a); const r = e.get("axisFill"); i && r && s.children.moveValue(r) } _prepareDataItem(e, t) { } markDirtyExtremes() { } markDirtySelectionExtremes() { } _calculateTotals() { } _updateAxisRanges() { this._bullets = {}, this.axisRanges.each((e => { this._prepareDataItem(e) })), l.each(this._seriesAxisRanges, (e => { this._prepareDataItem(e) })) } _prepareChildren() { if (super._prepareChildren(), this.get("fixAxisSize") ? this.ghostLabel.set("visible", !0) : this.ghostLabel.set("visible", !1), this.isDirty("start") || this.isDirty("end")) { const e = this.chart; e && e._updateCursor(); let t = this.get("start", 0), i = this.get("end", 1), s = this.get("maxDeviation", .5) * Math.min(1, i - t); if (t < -s) { let e = t + s; t = -s, this.setRaw("start", t), this.isDirty("end") && this.setRaw("end", i - e) } if (i > 1 + s) { let e = i - 1 - s; i = 1 + s, this.setRaw("end", i), this.isDirty("start") && this.setRaw("start", t - e) } } const e = this.get("renderer"); if (e._start = this.get("start"), e._end = this.get("end"), e._inversed = e.get("inversed", !1), e._axisLength = e.axisLength() / (e._end - e._start), e._updateLC(), this.isDirty("tooltip")) { const t = this.get("tooltip"); if (t) { const i = e.get("themeTags"); t.addTag("axis"), t.addTag(this.className.toLowerCase()), t._applyThemes(), i && (t.set("themeTags", c.mergeTags(t.get("themeTags"), i)), t.label._applyThemes()) } } } _updateTooltipBounds() { const e = this.get("tooltip"); e && this.get("renderer").updateTooltipBounds(e) } _updateBounds() { super._updateBounds(), this._updateTooltipBounds() } processChart(e) { this.chart = e; this.get("renderer").chart = e, e.gridContainer.children.push(this.gridContainer), e.topGridContainer.children.push(this.topGridContainer), e.axisHeadersContainer.children.push(this.axisHeader), this.on("start", (() => { e._handleAxisSelection(this) })), this.on("end", (() => { e._handleAxisSelection(this) })), e.plotContainer.onPrivate("width", (() => { this.markDirtySize() })), e.plotContainer.onPrivate("height", (() => { this.markDirtySize() })), e.processAxis(this) } hideDataItem(e) { return this._toggleFHDataItem(e, !0), super.hideDataItem(e) } showDataItem(e) { return this._toggleFHDataItem(e, !1), super.showDataItem(e) } _toggleFHDataItem(e, t) { const i = "forceHidden", s = e.get("label"); s && s.set(i, t); const a = e.get("grid"); a && a.set(i, t); const r = e.get("tick"); r && r.set(i, t); const n = e.get("axisFill"); n && n.set(i, t); const o = e.get("bullet"); if (o) { const e = o.get("sprite"); e && e.set(i, t) } } _toggleDataItem(e, t) { const i = e.get("label"), s = "visible"; i && i.setPrivate(s, t); const a = e.get("grid"); a && a.setPrivate(s, t); const r = e.get("tick"); r && r.setPrivate(s, t); const n = e.get("axisFill"); n && n.setPrivate(s, t); const o = e.get("bullet"); if (o) { const e = o.get("sprite"); e && e.setPrivate(s, t) } } _createAssets(e, t, i) { var s, a, r; const n = this.get("renderer"); let o = "minor"; const l = e.get("label"); if (l) { let a = l.get("themeTags"), r = !1; i ? -1 == (null == a ? void 0 : a.indexOf(o)) && (r = !0) : -1 != (null == a ? void 0 : a.indexOf(o)) && (r = !0), r && (null === (s = l.parent) || void 0 === s || s.children.removeValue(l), n.makeLabel(e, t), l.dispose(), n.labels.removeValue(l)) } else n.makeLabel(e, t); const h = e.get("grid"); if (h) { let s = h.get("themeTags"), r = !1; i ? -1 == (null == s ? void 0 : s.indexOf(o)) && (r = !0) : -1 != (null == s ? void 0 : s.indexOf(o)) && (r = !0), r && (null === (a = h.parent) || void 0 === a || a.children.removeValue(h), n.makeGrid(e, t), h.dispose(), n.grid.removeValue(h)) } else n.makeGrid(e, t); const c = e.get("tick"); if (c) { let s = !1, a = c.get("themeTags"); i ? -1 == (null == a ? void 0 : a.indexOf(o)) && (s = !0) : -1 != (null == a ? void 0 : a.indexOf(o)) && (s = !0), s && (null === (r = c.parent) || void 0 === r || r.children.removeValue(c), n.makeTick(e, t), c.dispose(), n.ticks.removeValue(c)) } else n.makeTick(e, t); i || e.get("axisFill") || n.makeAxisFill(e, t), this._processBullet(e) } _processBullet(e) { let t = e.get("bullet"), i = this.get("bullet"); if (t || !i || e.get("isRange") || (t = i(this._root, this, e)), t) { t.axis = this; const i = t.get("sprite"); i && (i._setDataItem(e), e.setRaw("bullet", t), i.parent || this.bulletsContainer.children.push(i)) } } _afterChanged() { super._afterChanged(); const e = this.chart; e && (e._updateChartLayout(), e.axisHeadersContainer.markDirtySize()), this.get("renderer")._updatePositions(), this._seriesAdded = !1 } disposeDataItem(e) { super.disposeDataItem(e); const t = this.get("renderer"), i = e.get("label"); i && (t.labels.removeValue(i), i.dispose()); const s = e.get("tick"); s && (t.ticks.removeValue(s), s.dispose()); const a = e.get("grid"); a && (t.grid.removeValue(a), a.dispose()); const r = e.get("axisFill"); r && (t.axisFills.removeValue(r), r.dispose()); const n = e.get("bullet"); n && n.dispose() } _updateGhost() { this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength()); const e = this.ghostLabel; if (!e.isHidden()) { const t = e.localBounds(), i = Math.ceil(t.right - t.left); let s = e.get("text"); l.each(this.dataItems, (e => { const t = e.get("label"); if (t && !t.isHidden()) { const e = t.localBounds(); Math.ceil(e.right - e.left) > i && (s = t.text._getText()) } })), e.set("text", s) } let t = this.get("start", 0), i = this.get("end", 1); this.get("renderer").updateLabel(e, t + .5 * (i - t)) } _handleCursorPosition(e, t) { e = this.get("renderer").toAxisPosition(e), this._cursorPosition = e, this._snapToSeries = t, this.updateTooltip() } updateTooltip() { const e = this._snapToSeries; let t = this._cursorPosition; const i = this.get("tooltip"), s = this.get("renderer"); h.isNumber(t) && (l.each(this.series, (i => { if (i.get("baseAxis") === this) { const s = this.getSeriesItem(i, t, this.get("tooltipLocation")); e && -1 != e.indexOf(i) ? (i.updateLegendMarker(s), i.updateLegendValue(s), i._settings.tooltipDataItem = s) : (i.showDataItemTooltip(s), i.setRaw("tooltipDataItem", s)) } })), this.get("snapTooltip") && (t = this.roundAxisPosition(t, this.get("tooltipLocation", .5))), this.setPrivateRaw("tooltipPosition", t), i && (s.updateTooltipBounds(i), h.isNaN(t) ? i.hide(0) : (this._updateTooltipText(i, t), s.positionTooltip(i, t), t < this.get("start", 0) || t > this.get("end", 1) ? i.hide(0) : i.show(0)))) } _updateTooltipText(e, t) { e.label.set("text", this.getTooltipText(t)) } roundAxisPosition(e, t) { return e } handleCursorShow() { let e = this.get("tooltip"); e && e.show() } handleCursorHide() { let e = this.get("tooltip"); e && e.hide() } processSeriesDataItem(e, t) { } _clearDirty() { super._clearDirty(), this._sizeDirty = !1, this._rangesDirty = !1 } coordinateToPosition(e) { const t = this.get("renderer"); return t.toAxisPosition(e / t.axisLength()) } toAxisPosition(e) { return this.get("renderer").toAxisPosition(e) } toGlobalPosition(e) { return this.get("renderer").toGlobalPosition(e) } fixPosition(e) { return this.get("renderer").fixPosition(e) } shouldGap(e, t, i, s) { return !1 } createAxisRange(e) { return this.axisRanges.push(e) } _groupSeriesData(e) { } getCellWidthPosition() { return .05 } } Object.defineProperty(u, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Axis" }), Object.defineProperty(u, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Component.classNames.concat([u.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js": (e, t, i) => { i.r(t), i.d(t, { AxisLabel: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js"); class a extends s.Label { constructor() { super(...arguments), Object.defineProperty(this, "_tickPoints", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "AxisLabel" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Label.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js": (e, t, i) => { i.r(t), i.d(t, { AxisRenderer: () => c }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisLabel.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class c extends s.Graphics { constructor() { super(...arguments), Object.defineProperty(this, "_axisLength", { enumerable: !0, configurable: !0, writable: !0, value: 100 }), Object.defineProperty(this, "_start", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_end", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_inversed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_minSize", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "chart", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_lc", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_ls", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_thumbDownPoint", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downStart", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downEnd", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "ticks", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListTemplate(a.Template.new({}), (() => n.AxisTick._new(this._root, { themeTags: h.mergeTags(this.ticks.template.get("themeTags", []), this.get("themeTags", [])) }, [this.ticks.template]))) }), Object.defineProperty(this, "grid", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListTemplate(a.Template.new({}), (() => o.Grid._new(this._root, { themeTags: h.mergeTags(this.grid.template.get("themeTags", []), this.get("themeTags", [])) }, [this.grid.template]))) }), Object.defineProperty(this, "axisFills", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListTemplate(a.Template.new({}), (() => s.Graphics._new(this._root, { themeTags: h.mergeTags(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", [])) }, [this.axisFills.template]))) }), Object.defineProperty(this, "labels", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListTemplate(a.Template.new({}), (() => l.AxisLabel._new(this._root, { themeTags: h.mergeTags(this.labels.template.get("themeTags", []), this.get("themeTags", [])) }, [this.labels.template]))) }), Object.defineProperty(this, "axis", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "thumb", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } makeTick(e, t) { const i = this.ticks.make(); return i._setDataItem(e), e.setRaw("tick", i), i.set("themeTags", h.mergeTags(i.get("themeTags"), t)), this.axis.labelsContainer.children.push(i), this.ticks.push(i), i } makeGrid(e, t) { const i = this.grid.make(); return i._setDataItem(e), e.setRaw("grid", i), i.set("themeTags", h.mergeTags(i.get("themeTags"), t)), this.axis.gridContainer.children.push(i), this.grid.push(i), i } makeAxisFill(e, t) { const i = this.axisFills.make(); return i._setDataItem(e), i.set("themeTags", h.mergeTags(i.get("themeTags"), t)), this.axis.gridContainer.children.push(i), e.setRaw("axisFill", i), this.axisFills.push(i), i } makeLabel(e, t) { const i = this.labels.make(); return i.set("themeTags", h.mergeTags(i.get("themeTags"), t)), this.axis.labelsContainer.children.moveValue(i, 0), i._setDataItem(e), e.setRaw("label", i), this.labels.push(i), i } axisLength() { return 0 } gridCount() { return this.axisLength() / this.get("minGridDistance", 50) } _updatePositions() { } _afterNew() { super._afterNew(), this.set("isMeasured", !1); const e = this.thumb; e && (this._disposers.push(e.events.on("pointerdown", (e => { this._handleThumbDown(e) }))), this._disposers.push(e.events.on("globalpointerup", (e => { this._handleThumbUp(e) }))), this._disposers.push(e.events.on("globalpointermove", (e => { this._handleThumbMove(e) })))) } _beforeChanged() { super._beforeChanged(), this.isDirty("minGridDistance") && this.root.events.once("frameended", (() => { this.axis.markDirtySize() })) } _changed() { if (super._changed(), this.isDirty("pan")) { const e = this.thumb; if (e) { const t = this.axis.labelsContainer, i = this.get("pan"); "zoom" == i ? t.children.push(e) : "none" == i && t.children.removeValue(e) } } } _handleThumbDown(e) { this._thumbDownPoint = this.toLocal(e.point); const t = this.axis; this._downStart = t.get("start"), this._downEnd = t.get("end") } _handleThumbUp(e) { this._thumbDownPoint = void 0 } _handleThumbMove(e) { const t = this._thumbDownPoint; if (t) { const i = this.toLocal(e.point), s = this._downStart, a = this._downEnd, r = this._getPan(i, t) * Math.min(1, a - s) / 2 * this.get("panSensitivity", 1); this.axis.zoom(s - r, a + r, 0) } } _getPan(e, t) { return 0 } positionToCoordinate(e) { return this._inversed ? (this._end - e) * this._axisLength : (e - this._start) * this._axisLength } updateTooltipBounds(e) { } _updateSize() { this.markDirty(), this._clear = !0 } toAxisPosition(e) { const t = this._start || 0, i = this._end || 1; return e *= i - t, e = this.get("inversed") ? i - e : t + e } toGlobalPosition(e) { const t = this._start || 0, i = this._end || 1; return this.get("inversed") ? e = i - e : e -= t, e /= i - t } fixPosition(e) { return this.get("inversed") ? 1 - e : e } _updateLC() { } toggleVisibility(e, t, i, s) { let a = this.axis; const r = a.get("start", 0), n = a.get("end", 1); t < r + (n - r) * (i - 1e-4) || t > r + (n - r) * (s + 1e-4) ? e.setPrivate("visible", !1) : e.setPrivate("visible", !0) } _positionTooltip(e, t) { const i = this.chart; i && (e.set("pointTo", this._display.toGlobal(t)), i.inPlot(t) || e.hide()) } processAxis() { } } Object.defineProperty(c, "className", { enumerable: !0, configurable: !0, writable: !0, value: "AxisRenderer" }), Object.defineProperty(c, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Graphics.classNames.concat([c.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js": (e, t, i) => { i.r(t), i.d(t, { AxisRendererX: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"); class l extends s.AxisRenderer { constructor() { super(...arguments), Object.defineProperty(this, "thumb", { enumerable: !0, configurable: !0, writable: !0, value: o.Rectangle.new(this._root, { width: a.p100, isMeasured: !1, themeTags: ["axis", "x", "thumb"] }) }) } _afterNew() { this._settings.themeTags = n.mergeTags(this._settings.themeTags, ["renderer", "x"]), super._afterNew(), this.setPrivateRaw("letter", "X"); const e = this.grid.template; e.set("height", a.p100), e.set("width", 0), e.set("draw", ((e, t) => { e.moveTo(0, 0), e.lineTo(0, t.height()) })), this.set("draw", ((e, t) => { e.moveTo(0, 0), e.lineTo(t.width(), 0) })) } _changed() { super._changed(); const e = this.axis; e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("x", -1e3); const t = "opposite", i = "inside"; if (this.isDirty(t) || this.isDirty(i)) { const s = this.chart, a = e.children; if (this.get(i) ? e.addTag(i) : e.removeTag(i), s) { if (this.get(t)) { const i = s.topAxesContainer.children; -1 == i.indexOf(e) && i.insertIndex(0, e), e.addTag(t), a.moveValue(this) } else { const i = s.bottomAxesContainer.children; -1 == i.indexOf(e) && i.moveValue(e), e.removeTag(t), a.moveValue(this, 0) } e.ghostLabel._applyThemes(), this.labels.each((e => { e._applyThemes() })), this.root._markDirtyRedraw() } e.markDirtySize() } this.thumb.setPrivate("height", e.labelsContainer.height()) } _getPan(e, t) { return (t.x - e.x) / this.width() } toAxisPosition(e) { const t = this._start || 0, i = this._end || 1; return e = (e -= this._ls) * (i - t) / this._lc, e = this.get("inversed") ? i - e : t + e } toGlobalPosition(e) { const t = this._start || 0, i = this._end || 1; return this.get("inversed") ? e = i - e : e -= t, e = e / (i - t) * this._lc, e += this._ls } _updateLC() { const e = this.axis, t = e.parent; if (t) { const i = t.innerWidth(); this._lc = this.axisLength() / i, this._ls = (e.x() - t.get("paddingLeft", 0)) / i } } _updatePositions() { const e = this.axis, t = e.x() - n.relativeToValue(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0); e.gridContainer.set("x", t), e.topGridContainer.set("x", t), e.bulletsContainer.set("y", this.y()); const i = e.chart; if (i) { const t = i.plotContainer, s = e.axisHeader; let a = e.get("marginLeft", 0), r = e.x() - a; const n = e.parent; n && (r -= n.get("paddingLeft", 0)), s.children.length > 0 ? (a = e.axisHeader.width(), e.set("marginLeft", a + 1)) : s.set("width", a), s.setAll({ x: r, y: -1, height: t.height() + 2 }) } } processAxis() { super.processAxis(); const e = this.axis; null == e.get("width") && e.set("width", a.p100); const t = this._root.verticalLayout; e.set("layout", t), e.labelsContainer.set("width", a.p100), e.axisHeader.setAll({ layout: t }) } axisLength() { return this.axis.width() } positionToPoint(e) { return { x: this.positionToCoordinate(e), y: 0 } } updateTick(e, t, i, s) { if (e) { r.isNumber(t) || (t = 0); let n = .5; n = r.isNumber(s) && s > 1 ? e.get("multiLocation", n) : e.get("location", n), r.isNumber(i) && i != t && (t += (i - t) * n), e.set("x", this.positionToCoordinate(t)); let o = e.get("length", 0); const l = e.get("inside", this.get("inside", !1)); this.get("opposite") ? (e.set("y", a.p100), l || (o *= -1)) : (e.set("y", 0), l && (o *= -1)), e.set("draw", (e => { e.moveTo(0, 0), e.lineTo(0, o) })), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1)) } } updateLabel(e, t, i, s) { if (e) { let n = .5; n = r.isNumber(s) && s > 1 ? e.get("multiLocation", n) : e.get("location", n), r.isNumber(t) || (t = 0); const o = e.get("inside", this.get("inside", !1)); this.get("opposite") ? o ? (e.set("position", "absolute"), e.set("y", 0)) : (e.set("position", "relative"), e.set("y", a.p100)) : o ? (e.set("y", 0), e.set("position", "absolute")) : (e.set("y", void 0), e.set("position", "relative")), r.isNumber(i) && i != t && (t += (i - t) * n), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1)) } } updateGrid(e, t, i) { if (e) { r.isNumber(t) || (t = 0); let s = e.get("location", .5); r.isNumber(i) && i != t && (t += (i - t) * s), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1) } } updateBullet(e, t, i) { if (e) { const s = e.get("sprite"); if (s) { r.isNumber(t) || (t = 0); let a = e.get("location", .5); r.isNumber(i) && i != t && (t += (i - t) * a); let n = this.axis.roundAxisPosition(t, a), o = this.axis._bullets[n], l = -1; if (this.get("opposite") && (l = 1), e.get("stacked")) if (o) { let e = o.get("sprite"); e && s.set("y", e.y() + e.height() * l) } else s.set("y", 0); this.axis._bullets[n] = e, s.set("x", this.positionToCoordinate(t)), this.toggleVisibility(s, t, 0, 1) } } } updateFill(e, t, i) { if (e) { r.isNumber(t) || (t = 0), r.isNumber(i) || (i = 1); let s = this.positionToCoordinate(t), a = this.positionToCoordinate(i); this.fillDrawMethod(e, s, a) } } fillDrawMethod(e, t, i) { e.set("draw", (e => { const s = this.axis.gridContainer.height(), a = this.width(); i < t && ([i, t] = [t, i]), t > a || i < 0 || (e.moveTo(t, 0), e.lineTo(i, 0), e.lineTo(i, s), e.lineTo(t, s), e.lineTo(t, 0)) })) } positionTooltip(e, t) { this._positionTooltip(e, { x: this.positionToCoordinate(t), y: 0 }) } updateTooltipBounds(e) { const t = this.get("inside"), i = 1e5; let s = this._display.toGlobal({ x: 0, y: 0 }), a = s.x, r = 0, o = this.axisLength(), l = i, h = "up"; this.get("opposite") ? t ? (h = "up", r = s.y, l = i) : (h = "down", r = s.y - i, l = i) : t ? (h = "down", r = s.y - i, l = i) : (h = "up", r = s.y, l = i); const c = { left: a, right: a + o, top: r, bottom: r + l }, u = e.get("bounds"); n.sameBounds(c, u) || (e.set("bounds", c), e.set("pointerOrientation", h)) } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "AxisRendererX" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.AxisRenderer.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js": (e, t, i) => { i.r(t), i.d(t, { AxisRendererY: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRenderer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"); class l extends s.AxisRenderer { constructor() { super(...arguments), Object.defineProperty(this, "_downY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "thumb", { enumerable: !0, configurable: !0, writable: !0, value: o.Rectangle.new(this._root, { height: a.p100, isMeasured: !1, themeTags: ["axis", "y", "thumb"] }) }) } _afterNew() { this._settings.themeTags = n.mergeTags(this._settings.themeTags, ["renderer", "y"]), this._settings.opposite && this._settings.themeTags.push("opposite"), super._afterNew(), this.setPrivateRaw("letter", "Y"); const e = this.grid.template; e.set("width", a.p100), e.set("height", 0), e.set("draw", ((e, t) => { e.moveTo(0, 0), e.lineTo(t.width(), 0) })), this.set("draw", ((e, t) => { e.moveTo(0, 0), e.lineTo(0, t.height()) })) } _getPan(e, t) { return (e.y - t.y) / this.height() } _changed() { super._changed(); const e = this.axis; e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("y", -1e3); const t = this.thumb, i = "opposite", s = "inside", a = this.chart; if (this.isDirty(i) || this.isDirty(s)) { const t = e.children; if (this.get(s) ? e.addTag(s) : e.removeTag(s), a) { if (this.get(i)) { const s = a.rightAxesContainer.children; -1 == s.indexOf(e) && s.moveValue(e, 0), e.addTag(i), t.moveValue(this, 0) } else { const s = a.leftAxesContainer.children; -1 == s.indexOf(e) && s.moveValue(e), e.removeTag(i), t.moveValue(this) } e.ghostLabel._applyThemes(), this.labels.each((e => { e._applyThemes() })), this.root._markDirtyRedraw() } e.markDirtySize() } const r = e.labelsContainer.width(); a && (this.get(i) ? t.set("centerX", 0) : t.set("centerX", r)), t.setPrivate("width", r) } processAxis() { super.processAxis(); const e = this.axis; null == e.get("height") && e.set("height", a.p100); const t = this._root.horizontalLayout; e.set("layout", t), e.labelsContainer.set("height", a.p100), e.axisHeader.set("layout", t) } _updatePositions() { const e = this.axis, t = e.y() - n.relativeToValue(e.get("centerY", 0), e.height()); e.gridContainer.set("y", t), e.topGridContainer.set("y", t), e.bulletsContainer.set("x", this.x()); const i = e.chart; if (i) { const t = i.plotContainer, s = e.axisHeader; let a = e.get("marginTop", 0); s.children.length > 0 ? (a = e.axisHeader.height(), e.set("marginTop", a + 1)) : s.set("height", a), s.setAll({ y: e.y() - a, x: -1, width: t.width() + 2 }) } } axisLength() { return this.axis.innerHeight() } positionToPoint(e) { return { x: 0, y: this.positionToCoordinate(e) } } updateLabel(e, t, i, s) { if (e) { r.isNumber(t) || (t = 0); let a = .5; a = r.isNumber(s) && s > 1 ? e.get("multiLocation", a) : e.get("location", a); const n = this.get("opposite"), o = e.get("inside", this.get("inside", !1)); n ? (e.set("x", 0), o ? e.set("position", "absolute") : e.set("position", "relative")) : o ? (e.set("x", 0), e.set("position", "absolute")) : (e.set("x", void 0), e.set("position", "relative")), r.isNumber(i) && i != t && (t += (i - t) * a), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1)) } } updateGrid(e, t, i) { if (e) { r.isNumber(t) || (t = 0); let s = e.get("location", .5); r.isNumber(i) && i != t && (t += (i - t) * s), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1) } } updateTick(e, t, i, s) { if (e) { r.isNumber(t) || (t = 0); let a = .5; a = r.isNumber(s) && s > 1 ? e.get("multiLocation", a) : e.get("location", a), r.isNumber(i) && i != t && (t += (i - t) * a), e.set("y", this.positionToCoordinate(t)); let n = e.get("length", 0); const o = e.get("inside", this.get("inside", !1)); this.get("opposite") ? (e.set("x", 0), o && (n *= -1)) : o || (n *= -1), e.set("draw", (e => { e.moveTo(0, 0), e.lineTo(n, 0) })), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1)) } } updateBullet(e, t, i) { if (e) { const s = e.get("sprite"); if (s) { r.isNumber(t) || (t = 0); let a = e.get("location", .5); r.isNumber(i) && i != t && (t += (i - t) * a); let n = this.axis.roundAxisPosition(t, a), o = this.axis._bullets[n], l = 1; if (this.get("opposite") && (l = -1), e.get("stacked")) if (o) { let e = o.get("sprite"); e && s.set("x", e.x() + e.width() * l) } else s.set("x", 0); this.axis._bullets[n] = e, s.set("y", this.positionToCoordinate(t)), this.toggleVisibility(s, t, 0, 1) } } } updateFill(e, t, i) { if (e) { r.isNumber(t) || (t = 0), r.isNumber(i) || (i = 1); let s = this.positionToCoordinate(t), a = this.positionToCoordinate(i); this.fillDrawMethod(e, s, a) } } fillDrawMethod(e, t, i) { e.set("draw", (e => { const s = this.axis.gridContainer.width(), a = this.height(); i < t && ([i, t] = [t, i]), t > a || i < 0 || (e.moveTo(0, t), e.lineTo(s, t), e.lineTo(s, i), e.lineTo(0, i), e.lineTo(0, t)) })) } positionToCoordinate(e) { return this._inversed ? (e - this._start) * this._axisLength : (this._end - e) * this._axisLength } positionTooltip(e, t) { this._positionTooltip(e, { x: 0, y: this.positionToCoordinate(t) }) } updateTooltipBounds(e) { const t = this.get("inside"), i = 1e5; let s = this._display.toGlobal({ x: 0, y: 0 }), a = s.y, r = 0, o = this.axisLength(), l = i, h = "right"; this.get("opposite") ? t ? (h = "right", r = s.x - i, l = i) : (h = "left", r = s.x, l = i) : t ? (h = "left", r = s.x, l = i) : (h = "right", r = s.x - i, l = i); const c = { left: r, right: r + l, top: a, bottom: a + o }, u = e.get("bounds"); n.sameBounds(c, u) || (e.set("bounds", c), e.set("pointerOrientation", h)) } _updateLC() { const e = this.axis, t = e.parent; if (t) { const i = t.innerHeight(); this._lc = this.axisLength() / i, this._ls = e.y() / i } } toAxisPosition(e) { const t = this._start || 0, i = this._end || 1; return e = (e -= this._ls) * (i - t) / this._lc, e = this.get("inversed") ? t + e : i - e } toGlobalPosition(e) { const t = this._start || 0, i = this._end || 1; return this.get("inversed") ? e -= t : e = i - e, e = e / (i - t) * this._lc, e += this._ls } fixPosition(e) { return this.get("inversed") ? e : 1 - e } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "AxisRendererY" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.AxisRenderer.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisTick.js": (e, t, i) => { i.r(t), i.d(t, { AxisTick: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js"); class a extends s.Tick { constructor() { super(...arguments), Object.defineProperty(this, "_tickPoints", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "AxisTick" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Tick.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js": (e, t, i) => { i.r(t), i.d(t, { CategoryAxis: () => c }); var s = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js"); class c extends s.Axis { constructor() { super(...arguments), Object.defineProperty(this, "_frequency", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_itemMap", { enumerable: !0, configurable: !0, writable: !0, value: {} }) } _afterNew() { this._settings.themeTags = o.mergeTags(this._settings.themeTags, ["axis"]), this.fields.push("category"), this.setPrivateRaw("name", "category"), this.addTag("category"), super._afterNew() } _prepareChildren() { super._prepareChildren(); const e = this.dataItems.length; let t = 0; this._valuesDirty && (this._itemMap = {}, a.each(this.dataItems, (e => { e.setRaw("index", t), this._itemMap[e.get("category")] = e, t++ })), this.setPrivateRaw("maxZoomFactor", e)), this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * e), 0)), this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * e), e)), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && this.dataItems.length > 0 && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()) } _handleRangeChange() { a.each(this.series, (e => { let t = this.dataItems[this.startIndex()].get("category"), i = this.dataItems[this.endIndex() - 1].get("category"), s = e.get("baseAxis"), r = e.get("xAxis"), n = e.get("yAxis"); if (r instanceof c && n instanceof c) e._markDirtyAxes(); else if (s === this) { let o, l, c = n; if (r === s ? (e.get("categoryXField") && (o = "categoryX"), e.get("openCategoryXField") && (l = "openCategoryX")) : n === s && (e.get("categoryYField") && (o = "categoryY"), e.get("openCategoryYField") && (l = "openCategoryY"), c = r), c instanceof h.ValueAxis && (o || l)) { let s, r; for (let i = 0, a = e.dataItems.length; i < a; i++) { let a = e.dataItems[i]; if (o && a.get(o) === t) { s = a; break } if (l && a.get(l) === t) { s = a; break } } for (let t = e.dataItems.length - 1; t >= 0; t--) { let s = e.dataItems[t]; if (o && s.get(o) === i) { r = s; break } if (l && s.get(l) === i) { r = s; break } } let n = 0, h = e.dataItems.length; s && (n = e.dataItems.indexOf(s)), r && (h = e.dataItems.indexOf(r) + 1), e.setPrivate("startIndex", n), e.setPrivate("endIndex", h); let c = !1; for (let t = n; t < h; t++) { const i = e.dataItems[t]; if (a.each(e.__valueXShowFields, (e => { null != i.get(e) && (c = !0) })), a.each(e.__valueYShowFields, (e => { null != i.get(e) && (c = !0) })), c) break } e.setPrivate("outOfSelection", !c) } e._markDirtyAxes() } })) } _prepareAxisItems() { var e; const t = this.get("renderer"), i = this.dataItems.length; let s = this.startIndex(); s > 0 && s--; let a = this.endIndex(); a < i && a++; const r = t.get("minorLabelsEnabled"), n = t.get("minorGridEnabled", r); let o = t.axisLength() / Math.max(t.get("minGridDistance"), 1), l = Math.max(1, Math.min(i, Math.ceil((a - s) / o))); s = Math.floor(s / l) * l, this._frequency = l; for (let e = 0; e < i; e++)this._toggleDataItem(this.dataItems[e], !1); let h = this.dataItems[s].get("index", 0); for (let e = s; e < a; e += l) { let t = this.dataItems[e]; this._createAssets(t, []), this._toggleDataItem(t, !0); let i = l; n && (i = 1), this._prepareDataItem(t, h, i), h++ } if (t.get("minorGridEnabled")) for (let t = s; t < a; t++) { let i = this.dataItems[t]; t % l != 0 && (this._createAssets(i, ["minor"], !0), this._toggleDataItem(i, !0), this._prepareDataItem(i, 0, 1), r || null === (e = i.get("label")) || void 0 === e || e.setPrivate("visible", !1)) } this._updateGhost() } _prepareDataItem(e, t, i) { let s = this.get("renderer"), a = e.get("categoryLocation", 0), n = e.get("endCategoryLocation", 1), o = e.get("index"); r.isNumber(o) || (o = this.categoryToIndex(e.get("category"))); let l, h = this.indexToPosition(o, a), c = e.get("endCategory"); c ? (l = this.categoryToIndex(c), r.isNumber(l) || (l = o)) : l = o; let u, d, m = this.indexToPosition(l, n); u = e.get("isRange") ? l : o + this._frequency - 1, d = this.indexToPosition(u, n), s.updateLabel(e.get("label"), h, m, i), s.updateGrid(e.get("grid"), h, m), s.updateTick(e.get("tick"), h, m, i), s.updateFill(e.get("axisFill"), h, d), this._processBullet(e), s.updateBullet(e.get("bullet"), h, m); const p = this.get("fillRule"); p && p(e, t) } startIndex() { let e = this.dataItems.length; return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), e - 1) } endIndex() { let e = this.dataItems.length; return Math.max(1, Math.min(this.getPrivate("endIndex", e), e)) } baseValue() { } basePosition() { return 0 } getX(e) { let t = this._itemMap[e]; return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN } getY(e) { let t = this._itemMap[e]; return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN } getDataItemPositionX(e, t, i, s) { const a = e.get(t), r = this._itemMap[a]; return r ? this.indexToPosition(r.get("index", 0), i) : NaN } getDataItemCoordinateX(e, t, i, s) { return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, i, s)) } getDataItemPositionY(e, t, i, s) { const a = e.get(t), r = this._itemMap[a]; return r ? this.indexToPosition(r.get("index", 0), i) : NaN } getDataItemCoordinateY(e, t, i, s) { return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, i, s)) } indexToPosition(e, t) { r.isNumber(t) || (t = .5); let i = this.dataItems.length, s = this.get("startLocation", 0); i -= s, i -= 1 - this.get("endLocation", 1); let a = (e + t - s) / i, n = this.dataItems[e]; return n && (a += n.get("deltaPosition", 0)), a } categoryToIndex(e) { let t = this._itemMap[e]; return t ? t.get("index") : NaN } dataItemToPosition(e) { return this.indexToPosition(e.get("index")) } roundAxisPosition(e, t) { return e += (.5 - t) / this.dataItems.length, this.indexToPosition(this.axisPositionToIndex(e), t) } axisPositionToIndex(e) { let t = this.dataItems.length; return n.fitToRange(Math.floor(e * t), 0, t - 1) } getTooltipText(e, t) { const i = this.dataItems[this.axisPositionToIndex(e)]; if (i) { const e = i.get("label"); if (e) return (0, l.populateString)(e, this.get("tooltipText", "")) } } _updateTooltipText(e, t) { e._setDataItem(this.dataItems[this.axisPositionToIndex(t)]), e.label.text.markDirtyText() } getSeriesItem(e, t) { if (this.dataItems.length > 0) { let i = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), s = this.axisPositionToIndex(t), a = e.dataItems[s], r = this.dataItems[s], n = r.get("category"); if (a && r && a.get(i) === n) return a; for (let t = 0, s = e.dataItems.length; t < s; t++) { let s = e.dataItems[t]; if (s.get(i) === n) return s } } } zoomToIndexes(e, t, i) { let s = this.dataItems.length; this.zoom(e / s, t / s, i) } zoomToCategories(e, t, i) { this.zoomToIndexes(this.categoryToIndex(e), this.categoryToIndex(t) + 1, i) } getCellWidthPosition() { return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0)) } nextPosition(e) { null == e && (e = 1), "Y" == this.get("renderer").getPrivate("letter") && (e *= -1); const t = this.getPrivate("tooltipPosition", 0), i = n.fitToRange(this.axisPositionToIndex(t) + e, 0, this.dataItems.length - 1); return this.toGlobalPosition(this.indexToPosition(i)) } } Object.defineProperty(c, "className", { enumerable: !0, configurable: !0, writable: !0, value: "CategoryAxis" }), Object.defineProperty(c, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Axis.classNames.concat([c.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Grid.js": (e, t, i) => { i.r(t), i.d(t, { Grid: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"); class a extends s.Graphics { _beforeChanged() { super._beforeChanged(), (this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0) } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Grid" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Graphics.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js": (e, t, i) => { i.r(t), i.d(t, { ValueAxis: () => c }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/Axis.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class c extends a.Axis { constructor() { super(...arguments), Object.defineProperty(this, "_dirtyExtremes", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dirtySelectionExtremes", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dseHandled", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_deltaMinMax", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_minReal", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_maxReal", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_minRealLog", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_baseValue", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_syncDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_minLogAdjusted", { enumerable: !0, configurable: !0, writable: !0, value: 1 }) } markDirtyExtremes() { this._dirtyExtremes = !0, this.markDirty() } markDirtySelectionExtremes() { this._dirtySelectionExtremes = !0, this.markDirty() } _afterNew() { this._settings.themeTags = h.mergeTags(this._settings.themeTags, ["axis"]), this.setPrivateRaw("name", "value"), this.addTag("value"), super._afterNew() } _prepareChildren() { if (super._prepareChildren(), this.isDirty("syncWithAxis")) { this._prevSettings.syncWithAxis && this._syncDp && this._syncDp.dispose(); let e = this.get("syncWithAxis"); e && (this._syncDp = new r.MultiDisposer([e.onPrivate("selectionMinFinal", (() => { this._dirtySelectionExtremes = !0 })), e.onPrivate("selectionMaxFinal", (() => { this._dirtySelectionExtremes = !0 }))])) } let e = !1; if ((this.isDirty("min") || this.isDirty("max") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) && (e = !0, this.ghostLabel.set("text", "")), (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || e || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection")) && (this._getMinMax(), this._dirtyExtremes = !1), this._handleSizeDirty(), this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", !0)) { const e = this.chart; let t = !1; if (e) { const i = this.get("renderer").getPrivate("letter"); "Y" == i ? e.xAxes.each((e => { "ValueAxis" != e.className && (t = !0) })) : "X" == i && e.yAxes.each((e => { "ValueAxis" != e.className && (t = !0) })) } t && this._getSelectionMinMax(), this._dirtySelectionExtremes = !1 } this._groupData(), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()), this._baseValue = this.baseValue() } _handleSizeDirty() { this._sizeDirty && !this._dseHandled && (this._dirtySelectionExtremes = !0, this._dseHandled = !0) } _clearDirty() { super._clearDirty(), this._dseHandled = !1 } _groupData() { } _formatText(e) { const t = this.get("numberFormat"), i = this.getNumberFormatter(); let s = ""; return s = t ? i.format(e, t) : i.format(e, void 0, this.getPrivate("stepDecimalPlaces")), s } _prepareAxisItems() { const e = this.getPrivate("min"), t = this.getPrivate("max"); if (n.isNumber(e) && n.isNumber(t)) { const t = this.get("logarithmic"), i = this.getPrivate("step"), a = this.getPrivate("selectionMin"), r = this.getPrivate("selectionMax") + i; let h = a - i, c = 1, u = e; if (t) { if (h = this._minLogAdjusted, h < a) for (; h < a;)h += i; u = h, u <= 0 && (u = 1, i < 1 && (u = n.isNumber(this._minRealLog) ? this._minRealLog : Math.pow(10, -50))), c = Math.log(r - i) * Math.LOG10E - Math.log(u) * Math.LOG10E, c > 2 && (h = Math.pow(10, Math.log(u) * Math.LOG10E - 50)) } const d = this.get("renderer"), m = d.get("minorLabelsEnabled"), p = d.get("minorGridEnabled", m); let g = Math.pow(10, Math.floor(Math.log(Math.abs(i)) * Math.LOG10E)); const b = Math.round(i / g); let _ = 2; l.round(b / 5, 10) % 1 == 0 && (_ = 5), l.round(b / 10, 10) % 1 == 0 && (_ = 10); let f = i / _, y = 0, v = 0, x = -1 / 0; for (; h < r;) { let e; this.dataItems.length < y + 1 ? (e = new s.DataItem(this, void 0, {}), this._dataItems.push(e), this.processDataItem(e)) : e = this.dataItems[y], this._createAssets(e, []), this._toggleDataItem(e, !0), e.setRaw("value", h); const a = e.get("label"); a && a.set("text", this._formatText(h)), this._prepareDataItem(e); let r = h; if (t && c > 2 ? r = Math.pow(10, Math.log(u) * Math.LOG10E + y - 50) : r += i, p) { let e = h + f; if (t) { if (c > 2) { f = this._adjustMinMax(h, r, 10).step } e = h + f } for (; e < r - 1e-11 * i;) { let t; this.minorDataItems.length < v + 1 ? (t = new s.DataItem(this, void 0, {}), this.minorDataItems.push(t), this.processDataItem(t)) : t = this.minorDataItems[v], this._createAssets(t, ["minor"], !0), this._toggleDataItem(t, !0), t.setRaw("value", e); const i = t.get("label"); i && (m ? i.set("text", this._formatText(e)) : i.setPrivate("visible", !1)), this._prepareDataItem(t), e += f, v++ } } if (h = r, x == h) break; let n = Math.pow(10, Math.floor(Math.log(Math.abs(i)) * Math.LOG10E)); if (n < 1 && !t) { let e = Math.round(Math.abs(Math.log(Math.abs(n)) * Math.LOG10E)) + 2; h = l.round(h, e) } y++, x = h } for (let e = y; e < this.dataItems.length; e++)this._toggleDataItem(this.dataItems[e], !1); for (let e = v; e < this.minorDataItems.length; e++)this._toggleDataItem(this.minorDataItems[e], !1); o.each(this.series, (e => { e.inited && e._markDirtyAxes() })), this._updateGhost() } } _prepareDataItem(e, t) { let i = this.get("renderer"), s = e.get("value"), a = e.get("endValue"), r = this.valueToPosition(s), o = r, l = this.valueToPosition(s + this.getPrivate("step")); n.isNumber(a) && (o = this.valueToPosition(a), l = o), e.get("isRange") && null == a && (l = r); let h = o, c = e.get("labelEndValue"); null != c && (h = this.valueToPosition(c)), i.updateLabel(e.get("label"), r, h, t); const u = e.get("grid"); if (i.updateGrid(u, r, o), u && (s == this.get("baseValue", 0) ? (u.addTag("base"), u._applyThemes()) : u.hasTag("base") && (u.removeTag("base"), u._applyThemes())), i.updateTick(e.get("tick"), r, h, t), i.updateFill(e.get("axisFill"), r, l), this._processBullet(e), i.updateBullet(e.get("bullet"), r, o), !e.get("isRange")) { const t = this.get("fillRule"); t && t(e) } } _handleRangeChange() { let e = this.positionToValue(this.get("start", 0)), t = this.positionToValue(this.get("end", 1)); const i = this.get("renderer").gridCount(); let s = this._adjustMinMax(e, t, i, !0), a = h.decimalPlaces(s.step); this.setPrivateRaw("stepDecimalPlaces", a), e = l.round(e, a), t = l.round(t, a), s = this._adjustMinMax(e, t, i, !0); let r = s.step; e = s.min, t = s.max, this.getPrivate("selectionMin") === e && this.getPrivate("selectionMax") === t && this.getPrivate("step") === r || (this.setPrivateRaw("selectionMin", e), this.setPrivateRaw("selectionMax", t), this.setPrivateRaw("step", r)) } positionToValue(e) { const t = this.getPrivate("min"), i = this.getPrivate("max"); return this.get("logarithmic") ? Math.pow(Math.E, (e * (Math.log(i) * Math.LOG10E - Math.log(t) * Math.LOG10E) + Math.log(t) * Math.LOG10E) / Math.LOG10E) : e * (i - t) + t } valueToPosition(e) { const t = this.getPrivate("min"), i = this.getPrivate("max"); if (this.get("logarithmic")) { if (e <= 0) { let t = this.get("treatZeroAs"); n.isNumber(t) && (e = t) } return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(t) * Math.LOG10E) } return (e - t) / (i - t) } valueToFinalPosition(e) { const t = this.getPrivate("minFinal"), i = this.getPrivate("maxFinal"); if (this.get("logarithmic")) { if (e <= 0) { let t = this.get("treatZeroAs"); n.isNumber(t) && (e = t) } return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(t) * Math.LOG10E) } return (e - t) / (i - t) } getX(e, t, i) { e = i + (e - i) * t; const s = this.valueToPosition(e); return this._settings.renderer.positionToCoordinate(s) } getY(e, t, i) { e = i + (e - i) * t; const s = this.valueToPosition(e); return this._settings.renderer.positionToCoordinate(s) } getDataItemCoordinateX(e, t, i, s) { return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, i, s)) } getDataItemPositionX(e, t, i, s) { let a = e.get(t); if (e.get("stackToItemX")) { a = a * s + e.component.getStackedXValueWorking(e, t) } else a = this._baseValue + (a - this._baseValue) * s; return this.valueToPosition(a) } getDataItemCoordinateY(e, t, i, s) { return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, i, s)) } getDataItemPositionY(e, t, i, s) { let a = e.get(t); if (e.get("stackToItemY")) { a = a * s + e.component.getStackedYValueWorking(e, t) } else a = this._baseValue + (a - this._baseValue) * s; return this.valueToPosition(a) } basePosition() { return this.valueToPosition(this.baseValue()) } baseValue() { const e = Math.min(this.getPrivate("minFinal", -1 / 0), this.getPrivate("selectionMin", -1 / 0)), t = Math.max(this.getPrivate("maxFinal", 1 / 0), this.getPrivate("selectionMax", 1 / 0)); let i = this.get("baseValue", 0); return i < e && (i = e), i > t && (i = t), i } cellEndValue(e) { return e } fixSmallStep(e) { return 1 + e === 1 ? (e *= 2, this.fixSmallStep(e)) : e } _fixMin(e) { return e } _fixMax(e) { return e } _calculateTotals() { if (this.get("calculateTotals")) { let e = this.series[0]; if (e) { let t = e.startIndex(); if (e.dataItems.length > 0) { t > 0 && t--; let i, s, a = e.endIndex(); a < e.dataItems.length && a++, e.get("yAxis") == this ? (i = "valueY", s = "vcy") : e.get("xAxis") == this && (i = "valueX", s = "vcx"); let r = i + "Working"; if (i) for (let e = t; e < a; e++) { let t = 0, a = 0; o.each(this.series, (i => { if (!i.get("excludeFromTotal")) { let o = i.dataItems[e]; if (o) { let e = o.get(r) * i.get(s); n.isNaN(e) || (t += e, a += Math.abs(e)) } } })), o.each(this.series, (o => { if (!o.get("excludeFromTotal")) { let l = o.dataItems[e]; if (l) { let e = l.get(r) * o.get(s); n.isNaN(e) || (l.set(i + "Total", a), l.set(i + "Sum", t), l.set(i + "TotalPercent", e / a * 100)) } } })) } } } } } _getSelectionMinMax() { const e = this.getPrivate("minFinal"), t = this.getPrivate("maxFinal"), i = this.get("min"), s = this.get("max"); let a = this.get("extraMin", 0), r = this.get("extraMax", 0); this.get("logarithmic") && (null == this.get("extraMin") && (a = .1), null == this.get("extraMax") && (r = .2)); const h = this.get("renderer").gridCount(), c = this.get("strictMinMaxSelection"); let u = this.get("strictMinMax"); if (n.isNumber(e) && n.isNumber(t)) { let d = t, m = e; if (o.each(this.series, (e => { if (!e.get("ignoreMinMax")) { let t, i; const s = e.getPrivate("outOfSelection"); if (e.get("xAxis") === this) { if (!s) { let s = e.getPrivate("minX"), a = e.getPrivate("maxX"); 0 == e.startIndex() && e.endIndex() == e.dataItems.length || (s = void 0, a = void 0), t = e.getPrivate("selectionMinX", s), i = e.getPrivate("selectionMaxX", a) } } else if (e.get("yAxis") === this && !s) { let s = e.getPrivate("minY"), a = e.getPrivate("maxY"); 0 == e.startIndex() && e.endIndex() == e.dataItems.length || (s = void 0, a = void 0), t = e.getPrivate("selectionMinY", s), i = e.getPrivate("selectionMaxY", a) } e.isHidden() || e.isShowing() || (n.isNumber(t) && (d = Math.min(d, t)), n.isNumber(i) && (m = Math.max(m, i))) } })), this.axisRanges.each((e => { if (e.get("affectsMinMax")) { let t = e.get("value"); null != t && (d = Math.min(d, t), m = Math.max(m, t)), t = e.get("endValue"), null != t && (d = Math.min(d, t), m = Math.max(m, t)) } })), d > m && ([d, m] = [m, d]), n.isNumber(i) ? d = u ? i : e : u && n.isNumber(this._minReal) && (d = this._minReal), n.isNumber(s) ? m = u ? s : t : u && n.isNumber(this._maxReal) && (m = this._maxReal), d === m) { let t = d; if (d -= this._deltaMinMax, m += this._deltaMinMax, d < e) { let i = t - e; 0 == i && (i = this._deltaMinMax), d = t - i, m = t + i, u = !0 } let i = this._adjustMinMax(d, m, h, u); d = i.min, m = i.max } let p = d, g = m, b = m - d; d -= b * a, m += b * r; let _ = this._adjustMinMax(d, m, h); d = _.min, m = _.max, d = l.fitToRange(d, e, t), m = l.fitToRange(m, e, t), _ = this._adjustMinMax(d, m, h, !0), u || (d = _.min, m = _.max); const f = this.get("syncWithAxis"); if (f && (_ = this._syncAxes(d, m, _.step, f.getPrivate("selectionMinFinal", f.getPrivate("minFinal", 0)), f.getPrivate("selectionMaxFinal", f.getPrivate("maxFinal", 1)), f.getPrivate("selectionStepFinal", f.getPrivate("step", 1))), _.min < e && (_.min = e), _.max > t && (_.max = t), d = _.min, m = _.max), u && (n.isNumber(i) && (d = Math.max(d, i)), n.isNumber(s) && (m = Math.min(m, s))), c && (d = p - (g - p) * a, m = g + (g - p) * r), u) { d = n.isNumber(i) ? i : p, m = n.isNumber(s) ? s : g, m - d <= 1e-8 && (d -= this._deltaMinMax, m += this._deltaMinMax); let e = m - d; d -= e * a, m += e * r } this.get("logarithmic") && (d <= 0 && (d = p * (1 - Math.min(a, .99))), d < e && (d = e), m > t && (m = t)); let y = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2), v = l.round(this.valueToFinalPosition(d), y), x = l.round(this.valueToFinalPosition(m), y); this.setPrivateRaw("selectionMinFinal", d), this.setPrivateRaw("selectionMaxFinal", m), this.setPrivateRaw("selectionStepFinal", _.step), this.zoom(v, x) } } _getMinMax() { let e = this.get("min"), t = this.get("max"), i = 1 / 0, s = -1 / 0, a = this.get("extraMin", 0), r = this.get("extraMax", 0); this.get("logarithmic") && (null == this.get("extraMin") && (a = .1), null == this.get("extraMax") && (r = .2)); let h = 1 / 0; if (o.each(this.series, (e => { if (!e.get("ignoreMinMax")) { let t, a; if (e.get("xAxis") === this ? (t = e.getPrivate("minX"), a = e.getPrivate("maxX")) : e.get("yAxis") === this && (t = e.getPrivate("minY"), a = e.getPrivate("maxY")), n.isNumber(t) && n.isNumber(a)) { i = Math.min(i, t), s = Math.max(s, a); let e = a - t; e <= 0 && (e = Math.abs(a / 100)), e < h && (h = e) } } })), this.axisRanges.each((e => { if (e.get("affectsMinMax")) { let t = e.get("value"); null != t && (i = Math.min(i, t), s = Math.max(s, t)), t = e.get("endValue"), null != t && (i = Math.min(i, t), s = Math.max(s, t)) } })), this.get("logarithmic")) { let e = this.get("treatZeroAs"); n.isNumber(e) && i <= 0 && (i = e), i <= 0 && new Error("Logarithmic value axis can not have values <= 0.") } if (0 === i && 0 === s && (s = .9, i = -.9), n.isNumber(e) && (i = e), n.isNumber(t) && (s = t), i === 1 / 0 || s === -1 / 0) return this.setPrivate("minFinal", void 0), void this.setPrivate("maxFinal", void 0); i > s && ([i, s] = [s, i]); const c = i, u = s; let d = this.adapters.fold("min", i), m = this.adapters.fold("max", s); this._minRealLog = i, n.isNumber(d) && (i = d), n.isNumber(m) && (s = m), i = this._fixMin(i), s = this._fixMax(s), s - i <= 1 / Math.pow(10, 15) && (s - i != 0 ? this._deltaMinMax = (s - i) / 2 : this._getDelta(s), i -= this._deltaMinMax, s += this._deltaMinMax), i -= (s - i) * a, s += (s - i) * r, this.get("logarithmic") && (i < 0 && c >= 0 && (i = 0), s > 0 && u <= 0 && (s = 0)), this._minReal = i, this._maxReal = s; let p = this.get("strictMinMax"), g = this.get("strictMinMaxSelection", !1); g && (p = g); let b = p; n.isNumber(t) && (b = !0); let _ = this.get("renderer").gridCount(), f = this._adjustMinMax(i, s, _, b); if (i = f.min, s = f.max, f = this._adjustMinMax(i, s, _, !0), i = f.min, s = f.max, p) { i = n.isNumber(e) ? e : this._minReal, s = n.isNumber(t) ? t : this._maxReal, s - i <= 1e-8 && (i -= this._deltaMinMax, s += this._deltaMinMax); let o = s - i; i -= o * a, s += o * r } d = this.adapters.fold("min", i), m = this.adapters.fold("max", s), n.isNumber(d) && (i = d), n.isNumber(m) && (s = m), h == 1 / 0 && (h = s - i); let y = Math.round(Math.abs(Math.log(Math.abs(s - i)) * Math.LOG10E)) + 5; i = l.round(i, y), s = l.round(s, y); const v = this.get("syncWithAxis"); if (v && (f = this._syncAxes(i, s, f.step, v.getPrivate("minFinal", v.getPrivate("min", 0)), v.getPrivate("maxFinal", v.getPrivate("max", 1)), v.getPrivate("step", 1)), i = f.min, s = f.max), this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((s - i) / h * this.get("maxZoomFactor", 100)))), this._fixZoomFactor(), this.get("logarithmic") && (this._minLogAdjusted = i, i = this._minReal, s = this._maxReal, i <= 0 && (i = c * (1 - Math.min(a, .99)))), n.isNumber(i) && n.isNumber(s) && (this.getPrivate("minFinal") !== i || this.getPrivate("maxFinal") !== s)) { this.setPrivate("minFinal", i), this.setPrivate("maxFinal", s), this._saveMinMax(i, s); const e = this.get("interpolationDuration", 0), t = this.get("interpolationEasing"); this.animatePrivate({ key: "min", to: i, duration: e, easing: t }), this.animatePrivate({ key: "max", to: s, duration: e, easing: t }) } } _fixZoomFactor() { } _getDelta(e) { let t = Math.log(Math.abs(e)) * Math.LOG10E, i = Math.pow(10, Math.floor(t)); i /= 10, this._deltaMinMax = i } _saveMinMax(e, t) { } _adjustMinMax(e, t, i, s) { i <= 1 && (i = 1), i = Math.round(i); let a = e, r = t, o = t - e; 0 === o && (o = Math.abs(t)); let h = Math.log(Math.abs(o)) * Math.LOG10E, c = Math.pow(10, Math.floor(h)); c /= 10; let u = c; s && (u = 0), s ? (e = Math.floor(e / c) * c, t = Math.ceil(t / c) * c) : (e = Math.ceil(e / c) * c - u, t = Math.floor(t / c) * c + u), e < 0 && a >= 0 && (e = 0), t > 0 && r <= 0 && (t = 0), h = Math.log(Math.abs(o)) * Math.LOG10E, c = Math.pow(10, Math.floor(h)), c /= 100; let d = Math.ceil(o / i / c) * c, m = Math.pow(10, Math.floor(Math.log(Math.abs(d)) * Math.LOG10E)), p = Math.ceil(d / m); p > 5 ? p = 10 : p <= 5 && p > 2 && (p = 5), d = Math.ceil(d / (m * p)) * m * p; let g = this.get("maxPrecision"); if (n.isNumber(g)) { let e = l.ceil(d, g); g < Number.MAX_VALUE && d !== e && (d = e, 0 == d && (d = 1)) } let b = 0; m < 1 && (b = Math.round(Math.abs(Math.log(Math.abs(m)) * Math.LOG10E)) + 1, d = l.round(d, b)); let _, f = Math.floor(e / d); return e = l.round(d * f, b), _ = s ? Math.floor(t / d) : Math.ceil(t / d), _ === f && _++, (t = l.round(d * _, b)) < r && (t += d), e > a && (e -= d), d = this.fixSmallStep(d), { min: e, max: t, step: d } } getTooltipText(e, t) { const i = this.get("tooltipNumberFormat", this.get("numberFormat")), s = this.getNumberFormatter(), a = this.get("extraTooltipPrecision", 0), r = this.getPrivate("stepDecimalPlaces", 0) + a, n = l.round(this.positionToValue(e), r); return i ? s.format(n, i) : s.format(n, void 0, r) } getSeriesItem(e, t) { let i, s, a = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.positionToValue(t); if (o.each(e.dataItems, ((e, t) => { const n = Math.abs(e.get(a) - r); (void 0 === i || n < s) && (i = t, s = n) })), null != i) return e.dataItems[i] } zoomToValues(e, t, i) { const s = this.getPrivate("minFinal", 0), a = this.getPrivate("maxFinal", 0); null != this.getPrivate("min") && null != this.getPrivate("max") && this.zoom((e - s) / (a - s), (t - s) / (a - s), i) } _syncAxes(e, t, i, s, a, r) { if (this.get("syncWithAxis")) { let o = Math.round(a - s) / r, l = Math.round((t - e) / i), h = this.get("renderer").gridCount(); if (n.isNumber(o) && n.isNumber(l)) { let s = !1, a = 0, r = .01 * (t - e), n = e, l = t, c = i; for (; 1 != s;)if (s = this._checkSync(n, l, c, o), a++, a > 500 && (s = !0), s) e = n, t = l, i = c; else { a / 3 == Math.round(a / 3) ? (n = e - r * a, e >= 0 && n < 0 && (n = 0)) : (l = t + r * a, l <= 0 && l > 0 && (l = 0)); let i = this._adjustMinMax(n, l, h, !0); n = i.min, l = i.max, c = i.step } } } return { min: e, max: t, step: i } } _checkSync(e, t, i, s) { let a = (t - e) / i; for (let e = 1; e < s; e++)if (l.round(a / e, 1) == s || a * e == s) return !0; return !1 } getCellWidthPosition() { let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min")); return n.isNumber(e) && n.isNumber(t) ? this.getPrivate("step", 1) / (e - t) : .05 } nextPosition(e) { null == e && (e = 1), "Y" == this.get("renderer").getPrivate("letter") && (e *= -1); let t = this.positionToValue(this.getPrivate("tooltipPosition", 0)); return t += this.getPrivate("step", 1) * e, t = l.fitToRange(t, this.getPrivate("selectionMin", 0), this.getPrivate("selectionMax", 1)), this.toGlobalPosition(this.valueToPosition(t)) } } Object.defineProperty(c, "className", { enumerable: !0, configurable: !0, writable: !0, value: "ValueAxis" }), Object.defineProperty(c, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.Axis.classNames.concat([c.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js": (e, t, i) => { i.r(t), i.d(t, { BaseColumnSeries: () => h }); var s = i("./node_modules/tslib/tslib.es6.mjs"), a = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class h extends a.XYSeries { constructor() { super(...arguments), Object.defineProperty(this, "_ph", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_pw", { enumerable: !0, configurable: !0, writable: !0, value: 0 }) } _makeGraphics(e, t) { return this.makeColumn(t, e) } _makeFieldNames() { super._makeFieldNames(); const e = this.get("xAxis"), t = this.get("yAxis"), i = "CategoryAxis", s = "ValueAxis"; e.isType(i) && (this.get("openCategoryXField") || (this._xOpenField = this._xField)), e.isType(s) && (this.get("openValueXField") || (this._xOpenField = this._xField)), t.isType(i) && (this.get("openCategoryYField") || (this._yOpenField = this._yField)), t.isType(s) && (this.get("openValueYField") || (this._yOpenField = this._yField)) } _prepareChildren() { super._prepareChildren(); const e = this.get("xAxis"), t = this.get("yAxis"), i = this.dataItems.length, s = Math.max(0, this.startIndex() - 2), a = Math.min(this.endIndex() + 2, i - 1); if (e.inited && t.inited) for (let e = s; e <= a; e++) { let t = this.dataItems[e]; this._createGraphics(t) } } _updateChildren() { const e = this.chart; e && (this._ph = e.plotContainer.height(), this._pw = e.plotContainer.width()); const t = this.get("xAxis"), i = this.get("yAxis"), s = this.get("baseAxis"), a = this.columns.template; this.isDirty("fill") && null == a.get("fill") && a.set("fill", this.get("fill")), this.isDirty("fillPattern") && null == a.get("fillPattern") && a.set("fillPattern", this.get("fillPattern")), this.isDirty("stroke") && null == a.get("stroke") && a.set("stroke", this.get("stroke")); let r = 0, n = 0, l = 0; o.each(s.series, (e => { if (e instanceof h) { const t = e.get("stacked"); t && 0 == l && n++, !t && e.get("clustered") && n++ } e === this && (r = n - 1), l++ })), this.get("clustered") || (r = 0, n = 1), 0 === n && (n = 1, r = 0); const c = t.get("renderer"), u = i.get("renderer"), d = "cellStartLocation", m = "cellEndLocation", p = c.get(d, 0), g = c.get(m, 1), b = u.get(d, 0), _ = u.get(m, 1); if (this._aLocationX0 = p + r / n * (g - p), this._aLocationX1 = p + (r + 1) / n * (g - p), this._aLocationY0 = b + r / n * (_ - b), this._aLocationY1 = b + (r + 1) / n * (_ - b), t.inited && i.inited) { if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) { const e = this.dataItems.length; let t = Math.max(0, this.startIndex() - 2), i = Math.min(this.endIndex() + 2, e - 1); for (let e = 0; e < t; e++)this._toggleColumn(this.dataItems[e], !1); let s = this.dataItems[t]; for (let e = t; e <= i; e++) { let i = this.dataItems[e]; if (null != i.get("valueX") && null != i.get("valueY")) { if (s = i, e > 0 && t > 0) for (let t = e - 1; t >= 0; t--) { let e = this.dataItems[t]; if (null != e.get("valueX") && null != e.get("valueY")) { s = e; break } } break } this._toggleColumn(i, !1) } for (let e = t; e <= i; e++) { let t = this.dataItems[e]; this._updateGraphics(t, s), null != t.get("valueX") && null != t.get("valueY") && (s = t) } for (let t = i + 1; t < e; t++)this._toggleColumn(this.dataItems[t], !1) } } else this._skipped = !0; this.updateLegendMarker(this.get("tooltipDataItem")), super._updateChildren() } _createGraphics(e) { let t = e.get("graphics"); if (!t) { t = this._makeGraphics(this.columns, e), e.set("graphics", t), t._setDataItem(e); const i = e.get("legendDataItem"); if (i) { const e = i.get("markerRectangle"); if (e) { const i = e.states.lookup("default"); o.each(n.visualSettings, (s => { const a = t.get(s, this.get(s)); e.set(s, a), i.set(s, a) })) } } let s = e.get("rangeGraphics"); s && o.each(s, (e => { e.dispose() })), s = [], e.setRaw("rangeGraphics", s), this.axisRanges.each((t => { const i = t.container, a = this._makeGraphics(t.columns, e); s && s.push(a), a.setPrivate("list", t.columns), i.children.push(a) })) } } createAxisRange(e) { return o.each(this.dataItems, (e => { const t = e.get("graphics"); t && (t.dispose(), e.set("graphics", void 0)) })), super.createAxisRange(e) } _updateGraphics(e, t) { let i = e.get("graphics"); const s = this._xField, a = this._yField, n = e.get(s), h = e.get(a); if (null != n && null != h) { const n = this._xOpenField, h = this._yOpenField, c = this.get("locationX", e.get("locationX", .5)), u = this.get("locationY", e.get("locationY", .5)), d = this.get("openLocationX", e.get("openLocationX", c)), m = this.get("openLocationY", e.get("openLocationY", u)), p = i.get("width"), g = i.get("height"), b = this.get("stacked"), _ = this.get("xAxis"), f = this.get("yAxis"), y = this.get("baseAxis"), v = _.get("start"), x = _.get("end"), w = f.get("start"), P = f.get("end"); let T, D, k, j, C = this.get("vcy", 1), O = this.get("vcx", 1), S = !1, A = !1; if (f.isType("CategoryAxis") && _.isType("CategoryAxis")) { let t = this._aLocationX0 + d - .5, i = this._aLocationX1 + c - .5; if (p instanceof r.Percent) { let e = (i - t) * (1 - p.value) / 2; t += e, i -= e } if (T = _.getDataItemPositionX(e, n, t, O), D = _.getDataItemPositionX(e, s, i, O), t = this._aLocationY0 + m - .5, i = this._aLocationY1 + u - .5, g instanceof r.Percent) { let e = (i - t) * (1 - g.value) / 2; t += e, i -= e } k = f.getDataItemPositionY(e, h, t, C), j = f.getDataItemPositionY(e, a, i, C), e.setRaw("point", { x: T + (D - T) / 2, y: k + (j - k) / 2 }) } else if (_ === y) { let t = this._aLocationX0 + d - .5, i = this._aLocationX1 + c - .5; if (p instanceof r.Percent) { let e = (i - t) * (1 - p.value) / 2; t += e, i -= e } if (T = _.getDataItemPositionX(e, n, t, O), D = _.getDataItemPositionX(e, s, i, O), k = f.getDataItemPositionY(e, a, u, C), this._yOpenField !== this._yField) j = f.getDataItemPositionY(e, h, m, C); else if (b) { let t = e.get("stackToItemY"); j = t ? f.getDataItemPositionY(t, a, m, t.component.get("vcy")) : f.basePosition() } else j = f.basePosition(); e.setRaw("point", { x: T + (D - T) / 2, y: k }), A = !0 } else if (f === y) { let t = this._aLocationY0 + m - .5, i = this._aLocationY1 + u - .5; if (g instanceof r.Percent) { let e = (i - t) * (1 - g.value) / 2; t += e, i -= e } if (k = f.getDataItemPositionY(e, h, t, C), j = f.getDataItemPositionY(e, a, i, C), D = _.getDataItemPositionX(e, s, c, O), this._xOpenField !== this._xField) T = _.getDataItemPositionX(e, n, d, O); else if (b) { let t = e.get("stackToItemX"); T = t ? _.getDataItemPositionX(t, s, d, t.component.get("vcx")) : _.basePosition() } else T = _.basePosition(); S = !0, e.setRaw("point", { x: D, y: k + (j - k) / 2 }) } this._updateSeriesGraphics(e, i, T, D, k, j, S, A), T < v && D < v || T > x && D > x || k < w && j <= w || k >= P && j > P || l.isNaN(T) || l.isNaN(k) ? this._toggleColumn(e, !1) : this._toggleColumn(e, !0); let M = e.get("rangeGraphics"); M && o.each(M, (t => { this._updateSeriesGraphics(e, t, T, D, k, j, S, A) })), this._applyGraphicsStates(e, t) } } _updateSeriesGraphics(e, t, i, s, a, r, n, o) { const h = t.get("width"), c = t.get("height"), u = t.get("maxWidth"), d = t.get("maxHeight"), m = this.getPoint(i, a), p = this.getPoint(s, r), g = e.get("point"); if (g) { const e = this.getPoint(g.x, g.y); g.x = e.x + this._x, g.y = e.y + this._y } if (i = m.x, s = p.x, a = m.y, r = p.y, l.isNumber(h)) { const e = (s - i - h) / 2; i += e, s -= e } if (l.isNumber(u) && u < Math.abs(s - i)) { const e = (s - i - u) / 2; i += e, s -= e } if (l.isNumber(c)) { const e = (r - a - c) / 2; a += e, r -= e } if (l.isNumber(d) && d < Math.abs(r - a)) { const e = (r - a - d) / 2; a += e, r -= e } this.get("adjustBulletPosition") && (n && (s = Math.min(Math.max(0, s), this._pw), i = Math.min(Math.max(0, i), this._pw)), o && (a = Math.min(Math.max(0, a), this._ph), r = Math.min(Math.max(0, r), this._ph))), e.setRaw("left", i), e.setRaw("right", s), e.setRaw("top", a), e.setRaw("bottom", r), t.setPrivate("width", s - i), t.setPrivate("height", r - a), t.set("x", i), t.set("y", r - (r - a)) } _handleDataSetChange() { super._handleDataSetChange(), o.each(this._dataItems, (e => { this._toggleColumn(e, !1) })) } _applyGraphicsStates(e, t) { const i = e.get("graphics"), s = i.states.lookup("dropFromOpen"), a = i.states.lookup("riseFromOpen"), r = i.states.lookup("dropFromPrevious"), n = i.states.lookup("riseFromPrevious"); if (s || r || a || n) { const i = this.get("xAxis"), o = this.get("yAxis"), h = this.get("baseAxis"); let c, u, d; h === i && o.isType("ValueAxis") ? (c = e.get(this._yOpenField), u = e.get(this._yField), d = t.get(this._yField)) : h === o && i.isType("ValueAxis") && (c = e.get(this._xOpenField), u = e.get(this._xField), d = t.get(this._xField)), l.isNumber(c) && l.isNumber(u) && (u < c ? s && s.apply() : a && a.apply(), l.isNumber(d) && (u < d ? r && r.apply() : n && n.apply())) } } disposeDataItem(e) { super.disposeDataItem(e); const t = e.get("graphics"); t && (this.columns.removeValue(t), t.dispose()); const i = e.get("rangeGraphics"); i && o.each(i, (e => { const t = e.getPrivate("list"); t && t.removeValue(e), e.dispose() })) } hideDataItem(e, t) { const i = Object.create(null, { hideDataItem: { get: () => super.hideDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.hideDataItem.call(this, e, t)], a = e.get("graphics"); a && s.push(a.hide(t)); const r = e.get("rangeGraphics"); r && o.each(r, (e => { s.push(e.hide(t)) })), yield Promise.all(s) })) } _toggleColumn(e, t) { const i = e.get("graphics"); i && i.setPrivate("visible", t); const s = e.get("rangeGraphics"); s && o.each(s, (e => { e.setPrivate("visible", t) })); const a = e.bullets; a && o.each(a, (e => { e.setPrivate("hidden", !t) })) } showDataItem(e, t) { const i = Object.create(null, { showDataItem: { get: () => super.showDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.showDataItem.call(this, e, t)], a = e.get("graphics"); a && s.push(a.show(t)); const r = e.get("rangeGraphics"); r && o.each(r, (e => { s.push(e.show(t)) })), yield Promise.all(s) })) } updateLegendMarker(e) { let t = this.get("legendDataItem"); if (this.get("useLastColorForLegendMarker") && !e) { const t = this.dataItems[this.endIndex() - 1]; t && (e = t) } if (t) { let i = this.columns.template; if (e) { let t = e.get("graphics"); t && (i = t) } const s = t.get("markerRectangle"); if (s && !t.get("itemContainer").get("disabled")) { const e = s.states.lookup("default"); o.each(n.visualSettings, (t => { const a = i.get(t, this.get(t)); s.set(t, a), e.set(t, a) })) } } } _getTooltipTarget(e) { if ("bullet" == this.get("seriesTooltipTarget")) return super._getTooltipTarget(e); let t = e.get("graphics"); return t || this } } Object.defineProperty(h, "className", { enumerable: !0, configurable: !0, writable: !0, value: "BaseColumnSeries" }), Object.defineProperty(h, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.XYSeries.classNames.concat([h.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js": (e, t, i) => { i.r(t), i.d(t, { ColumnSeries: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/BaseColumnSeries.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class l extends s.BaseColumnSeries { constructor() { super(...arguments), Object.defineProperty(this, "columns", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListTemplate(a.Template.new({}), (() => n.RoundedRectangle._new(this._root, { position: "absolute", themeTags: o.mergeTags(this.columns.template.get("themeTags", []), ["series", "column"]) }, [this.columns.template]))) }) } makeColumn(e, t) { const i = this.mainContainer.children.push(t.make()); return i._setDataItem(e), t.push(i), i } _processAxisRange(e) { super._processAxisRange(e), e.columns = new r.ListTemplate(a.Template.new({}), (() => n.RoundedRectangle._new(this._root, { position: "absolute", themeTags: o.mergeTags(e.columns.template.get("themeTags", []), ["series", "column"]) }, [this.columns.template, e.columns.template]))) } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "ColumnSeries" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.BaseColumnSeries.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/XYSeries.js": (e, t, i) => { i.r(t), i.d(t, { XYSeries: () => m }); var s = i("./node_modules/tslib/tslib.es6.mjs"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class m extends r.Series { constructor() { super(...arguments), Object.defineProperty(this, "_xField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_yField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_xOpenField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_yOpenField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_xLowField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_xHighField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_yLowField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_yHighField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_axesDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_stackDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_selectionProcessed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dataSets", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_mainContainerMask", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_x", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_y", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_bullets", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "mainContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(o.Container.new(this._root, {})) }), Object.defineProperty(this, "axisRanges", { enumerable: !0, configurable: !0, writable: !0, value: new n.List }), Object.defineProperty(this, "_skipped", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_couldStackTo", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_reallyStackedTo", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_stackedSeries", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_aLocationX0", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_aLocationX1", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_aLocationY0", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_aLocationY1", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_showBullets", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "valueXFields", { enumerable: !0, configurable: !0, writable: !0, value: ["valueX", "openValueX", "lowValueX", "highValueX"] }), Object.defineProperty(this, "valueYFields", { enumerable: !0, configurable: !0, writable: !0, value: ["valueY", "openValueY", "lowValueY", "highValueY"] }), Object.defineProperty(this, "_valueXFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_valueYFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_valueXShowFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_valueYShowFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "__valueXShowFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "__valueYShowFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_emptyDataItem", { enumerable: !0, configurable: !0, writable: !0, value: new a.DataItem(this, void 0, {}) }), Object.defineProperty(this, "_dataSetId", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipFieldX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipFieldY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_posXDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_posYDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _afterNew() { this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY"), this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY"), this._setRawDefault("vcx", 1), this._setRawDefault("vcy", 1), this._setRawDefault("valueXShow", "valueXWorking"), this._setRawDefault("valueYShow", "valueYWorking"), this._setRawDefault("openValueXShow", "openValueXWorking"), this._setRawDefault("openValueYShow", "openValueYWorking"), this._setRawDefault("lowValueXShow", "lowValueXWorking"), this._setRawDefault("lowValueYShow", "lowValueYWorking"), this._setRawDefault("highValueXShow", "highValueXWorking"), this._setRawDefault("highValueYShow", "highValueYWorking"), this._setRawDefault("lowValueXGrouped", "low"), this._setRawDefault("lowValueYGrouped", "low"), this._setRawDefault("highValueXGrouped", "high"), this._setRawDefault("highValueYGrouped", "high"), super._afterNew(), this.set("maskContent", !0), this._disposers.push(this.axisRanges.events.onAll((e => { if ("clear" === e.type) u.each(e.oldValues, (e => { this._removeAxisRange(e) })); else if ("push" === e.type) this._processAxisRange(e.newValue); else if ("setIndex" === e.type) this._processAxisRange(e.newValue); else if ("insertIndex" === e.type) this._processAxisRange(e.newValue); else if ("removeIndex" === e.type) this._removeAxisRange(e.oldValue); else { if ("moveIndex" !== e.type) throw new Error("Unknown IStreamEvent type"); this._processAxisRange(e.value) } }))), this.states.create("hidden", { opacity: 1, visible: !1 }), this.onPrivate("startIndex", (() => { this.root.events.once("frameended", (() => { this.updateLegendValue() })) })), this.onPrivate("endIndex", (() => { this.root.events.once("frameended", (() => { this.updateLegendValue() })) })), this._makeFieldNames() } _processAxisRange(e) { const t = o.Container.new(this._root, {}); e.container = t, this.children.push(t), e.series = this; const i = e.axisDataItem; i.setRaw("isRange", !0); const s = i.component; if (s) { s._processAxisRange(i, ["range", "series"]); const e = i.get("bullet"); if (e) { const t = e.get("sprite"); t && t.setPrivate("visible", !1) } const a = i.get("axisFill"); a && t.set("mask", a), s._seriesAxisRanges.push(i) } } _removeAxisRange(e) { const t = e.axisDataItem, i = t.component; i.disposeDataItem(t), u.remove(i._seriesAxisRanges, t); const s = e.container; s && s.dispose() } _updateFields() { super._updateFields(), this._valueXFields = [], this._valueYFields = [], this._valueXShowFields = [], this._valueYShowFields = [], this.__valueXShowFields = [], this.__valueYShowFields = [], this.valueXFields && u.each(this.valueXFields, (e => { if (this.get(e + "Field")) { this._valueXFields.push(e); let t = this.get(e + "Show"); this.__valueXShowFields.push(t), -1 != t.indexOf("Working") ? this._valueXShowFields.push(t.split("Working")[0]) : this._valueXShowFields.push(t) } })), this.valueYFields && u.each(this.valueYFields, (e => { if (this.get(e + "Field")) { this._valueYFields.push(e); let t = this.get(e + "Show"); this.__valueYShowFields.push(t), -1 != t.indexOf("Working") ? this._valueYShowFields.push(t.split("Working")[0]) : this._valueYShowFields.push(t) } })) } _dispose() { super._dispose(), this._bullets = {}; const e = this.chart; e && e.series.removeValue(this), u.removeFirst(this.get("xAxis").series, this), u.removeFirst(this.get("yAxis").series, this) } _min(e, t) { let i = (s = this.getPrivate(e), a = t, null == s ? a : null == a ? s : a < s ? a : s); var s, a; this.setPrivate(e, i) } _max(e, t) { let i = (s = this.getPrivate(e), a = t, null == s ? a : null == a ? s : a > s ? a : s); var s, a; this.setPrivate(e, i) } _shouldMakeBullet(e) { const t = this.get("xAxis"), i = this.get("yAxis"), s = this.get("baseAxis"); if (!t.inited || !i.inited) return !1; const a = this.get("minBulletDistance", 0); if (a > 0) { let e = this.startIndex(), r = this.endIndex() - e; if (t == s) { if (t.get("renderer").axisLength() / r < a / 5) return !1 } else if (i == s && i.get("renderer").axisLength() / r < a / 5) return !1 } return null != e.get(this._xField) && null != e.get(this._yField) } _makeFieldNames() { const e = this.get("xAxis"), t = this.get("yAxis"), i = e.getPrivate("name"), s = d.capitalizeFirst(i), a = t.getPrivate("name"), r = d.capitalizeFirst(a), n = e.get("renderer").getPrivate("letter"), o = t.get("renderer").getPrivate("letter"), l = "open", h = "low", c = "high", u = "Show"; "ValueAxis" === e.className ? (this._xField = this.get(i + n + u), this._xOpenField = this.get(l + s + n + u), this._xLowField = this.get(h + s + n + u), this._xHighField = this.get(c + s + n + u)) : (this._xField = i + n, this._xOpenField = l + s + n, this._xLowField = h + s + n, this._xHighField = c + s + n), "ValueAxis" === t.className ? (this._yField = this.get(a + o + u), this._yOpenField = this.get(l + r + o + u), this._yLowField = this.get(h + r + o + u), this._yHighField = this.get(c + r + o + u)) : (this._yField = a + o, this._yOpenField = l + r + o, this._yLowField = h + r + o, this._yHighField = c + r + o) } _fixVC() { const e = this.get("xAxis"), t = this.get("yAxis"), i = this.get("baseAxis"), s = this.states.lookup("hidden"), a = this.get("sequencedInterpolation"); if (s) { let r = 0; a && (r = .999999999999), e === i ? s.set("vcy", r) : (t === i || s.set("vcy", r), s.set("vcx", r)) } } _handleMaskBullets() { this.isDirty("maskBullets") && this.bulletsContainer.set("maskContent", this.get("maskBullets")) } _fixPosition() { const e = this.get("xAxis"), t = this.get("yAxis"); this.set("x", e.x() - d.relativeToValue(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), this.set("y", t.y() - d.relativeToValue(t.get("centerY", 0), t.height()) - t.parent.get("paddingTop", 0)), this.bulletsContainer.set("y", this.y()), this.bulletsContainer.set("x", this.x()) } _prepareChildren() { super._prepareChildren(), this._bullets = {}, (this.isDirty("valueYShow") || this.isDirty("valueXShow") || this.isDirty("openValueYShow") || this.isDirty("openValueXShow") || this.isDirty("lowValueYShow") || this.isDirty("lowValueXShow") || this.isDirty("highValueYShow") || this.isDirty("highValueXShow")) && (this._updateFields(), this._makeFieldNames(), this._valuesDirty = !0), (this.isDirty("xAxis") || this.isDirty("yAxis")) && (this._valuesDirty = !0), this.set("width", this.get("xAxis").width()), this.set("height", this.get("yAxis").height()), this._handleMaskBullets(); const e = this.get("xAxis"), t = this.get("yAxis"), i = this.get("baseAxis"); let s; switch (this.get("tooltipPositionX")) { case "open": s = this._xOpenField; break; case "low": s = this._xLowField; break; case "high": s = this._xHighField; break; default: s = this._xField }this._tooltipFieldX = s; let a; switch (this.get("tooltipPositionY")) { case "open": a = this._yOpenField; break; case "low": a = this._yLowField; break; case "high": a = this._yHighField; break; default: a = this._yField }this._tooltipFieldY = a, this.isDirty("baseAxis") && this._fixVC(), this._fixPosition(); const r = this.get("stacked"); if (this.isDirty("stacked") && (r ? this._valuesDirty && !this._dataProcessed || this._stack() : this._unstack()), this._valuesDirty && !this._dataProcessed && (this._dataProcessed = !0, r && this._stack(), u.each(this.dataItems, (i => { u.each(this._valueXShowFields, (e => { let t = i.get(e); null != t && (r && (t += this.getStackedXValue(i, e)), this._min("minX", t), this._max("maxX", t)) })), u.each(this._valueYShowFields, (e => { let t = i.get(e); null != t && (r && (t += this.getStackedYValue(i, e)), this._min("minY", t), this._max("maxY", t)) })), e.processSeriesDataItem(i, this._valueXFields), t.processSeriesDataItem(i, this._valueYFields) })), e._seriesValuesDirty = !0, t._seriesValuesDirty = !0, this.get("ignoreMinMax") || ((this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) && e.markDirtyExtremes(), (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) && t.markDirtyExtremes()), this._markStakedDirtyStack(), this.get("tooltipDataItem") || this.updateLegendValue(void 0)), (this.isDirty("vcx") || this.isDirty("vcy")) && this._markStakedDirtyStack(), this._dataGrouped || (e._groupSeriesData(this), t._groupSeriesData(this), this._dataGrouped = !0), this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("adjustedStartIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._sizeDirty) { let s = this.startIndex(), a = this.endIndex(), r = this.get("minBulletDistance", 0); if (r > 0 && i && (i.get("renderer").axisLength() / (a - s) > r ? this._showBullets = !0 : this._showBullets = !1), (this._psi != s || this._pei != a || this.isDirty("vcx") || this.isDirty("vcy") || this.isPrivateDirty("adjustedStartIndex") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) { this._selectionProcessed = !0; const r = this.get("vcx", 1), n = this.get("vcy", 1), o = this.get("stacked", !1), l = this.getPrivate("outOfSelection"); if (i === e || !i) if (t._calculateTotals(), this.setPrivateRaw("selectionMinY", void 0), this.setPrivateRaw("selectionMaxY", void 0), l) t.markDirtySelectionExtremes(); else for (let e = s; e < a; e++)this.processYSelectionDataItem(this.dataItems[e], n, o); if (i === t || !i) if (e._calculateTotals(), this.setPrivateRaw("selectionMinX", void 0), this.setPrivateRaw("selectionMaxX", void 0), l) t.markDirtySelectionExtremes(); else for (let e = s; e < a; e++)this.processXSelectionDataItem(this.dataItems[e], r, o); if ((i === e || !i) && "valueYWorking" !== this.get("valueYShow")) { const e = this.getPrivate("selectionMinY"); null != e && (this.setPrivateRaw("minY", e), t.markDirtyExtremes()); const i = this.getPrivate("selectionMaxY"); null != i && (this.setPrivateRaw("maxY", i), t.markDirtyExtremes()) } if ((i === t || !i) && "valueXWorking" !== this.get("valueXShow")) { const i = this.getPrivate("selectionMinX"); null != i && (this.setPrivateRaw("minX", i), t.markDirtyExtremes()); const s = this.getPrivate("selectionMaxX"); null != s && (this.setPrivateRaw("maxX", s), e.markDirtyExtremes()) } (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) && e.markDirtySelectionExtremes(), (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) && t.markDirtySelectionExtremes() } } } _makeRangeMask() { if (this.axisRanges.length > 0) { let e = this._mainContainerMask; null == e && (e = this.children.push(l.Graphics.new(this._root, {})), this._mainContainerMask = e, e.set("draw", ((t, i) => { const s = this.parent; if (s) { const e = this._root.container.width(), a = this._root.container.height(); t.moveTo(-e, -a), t.lineTo(-e, 2 * a), t.lineTo(2 * e, 2 * a), t.lineTo(2 * e, -a), t.lineTo(-e, -a), this.axisRanges.each((e => { const a = e.axisDataItem.get("axisFill"); if (s && a) { let e = a.get("draw"); e && e(t, i) } })) } this.mainContainer._display.mask = e._display }))), e.markDirty(), e._markDirtyKey("fill") } else this.mainContainer._display.mask = null } _updateChildren() { super._updateChildren(), this._x = this.x(), this._y = this.y(), this._makeRangeMask() } _stack() { const e = this.chart; if (e) { const t = e.series.indexOf(this); if (this._couldStackTo = [], t > 0) { let i; for (let s = t - 1; s >= 0 && (i = e.series.getIndex(s), i.get("xAxis") !== this.get("xAxis") || i.get("yAxis") !== this.get("yAxis") || i.className !== this.className || (this._couldStackTo.push(i), i.get("stacked"))); s--); } this._stackDataItems() } } _unstack() { c.each(this._reallyStackedTo, ((e, t) => { delete t._stackedSeries[this.uid] })), this._reallyStackedTo = {}, u.each(this.dataItems, (e => { e.setRaw("stackToItemY", void 0), e.setRaw("stackToItemX", void 0) })) } _stackDataItems() { const e = this.get("baseAxis"), t = this.get("xAxis"), i = this.get("yAxis"); let s, a; e === t ? (s = "valueY", a = "stackToItemY") : e === i && (s = "valueX", a = "stackToItemX"); let r = this._couldStackTo.length, n = 0; const o = this.get("stackToNegative"); this._reallyStackedTo = {}, u.each(this.dataItems, (e => { for (let t = 0; t < r; t++) { let i = this._couldStackTo[t], r = i.dataItems[n], l = e.get(s); if (r) { let t = r.get(s); if (o) { if (!h.isNumber(l)) break; if (h.isNumber(t)) { if (l >= 0 && t >= 0) { e.setRaw(a, r), this._reallyStackedTo[i.uid] = i, i._stackedSeries[this.uid] = this; break } if (l < 0 && t < 0) { e.setRaw(a, r), this._reallyStackedTo[i.uid] = i, i._stackedSeries[this.uid] = this; break } } } else if (h.isNumber(l) && h.isNumber(t)) { e.setRaw(a, r), this._reallyStackedTo[i.uid] = i, i._stackedSeries[this.uid] = this; break } } } n++ })) } processXSelectionDataItem(e, t, i) { u.each(this.__valueXShowFields, (s => { let a = e.get(s); null != a && (i && (a += this.getStackedXValueWorking(e, s)), this._min("selectionMinX", a), this._max("selectionMaxX", a * t)) })) } processYSelectionDataItem(e, t, i) { u.each(this.__valueYShowFields, (s => { let a = e.get(s); null != a && (i && (a += this.getStackedYValueWorking(e, s)), this._min("selectionMinY", a), this._max("selectionMaxY", a * t)) })) } getStackedYValueWorking(e, t) { const i = e.get("stackToItemY"); if (i) { const e = i.component; return i.get(t, 0) * e.get("vcy", 1) + this.getStackedYValueWorking(i, t) } return 0 } getStackedXValueWorking(e, t) { const i = e.get("stackToItemX"); if (i) { const e = i.component; return i.get(t, 0) * e.get("vcx", 1) + this.getStackedXValueWorking(i, t) } return 0 } getStackedYValue(e, t) { const i = e.get("stackToItemY"); return i ? i.get(t, 0) + this.getStackedYValue(i, t) : 0 } getStackedXValue(e, t) { const i = e.get("stackToItemX"); return i ? i.get(t, 0) + this.getStackedXValue(i, t) : 0 } createLegendMarker(e) { this.updateLegendMarker() } _markDirtyAxes() { this._axesDirty = !0, this.markDirty() } _markDataSetDirty() { this._afterDataChange(), this._valuesDirty = !0, this._dataProcessed = !1, this._aggregatesCalculated = !1, this.markDirty() } _clearDirty() { super._clearDirty(), this._axesDirty = !1, this._selectionProcessed = !1, this._stackDirty = !1, this._dataProcessed = !1 } _positionBullet(e) { let t = e.get("sprite"); if (t) { let i = t.dataItem, s = e.get("locationX", i.get("locationX", .5)), a = e.get("locationY", i.get("locationY", .5)), r = this.get("xAxis"), n = this.get("yAxis"), o = r.getDataItemPositionX(i, this._xField, s, this.get("vcx", 1)), l = n.getDataItemPositionY(i, this._yField, a, this.get("vcy", 1)), h = this.getPoint(o, l), c = i.get("left", h.x), u = i.get("right", h.x), d = i.get("top", h.y), m = i.get("bottom", h.y), p = 0, g = 0, b = u - c, _ = m - d; if (this._shouldShowBullet(o, l)) { t.setPrivate("visible", !e.getPrivate("hidden")); let r = e.get("field"); const n = this.get("baseAxis"), u = this.get("xAxis"), d = this.get("yAxis"); if (null != r) { let e; n == u ? ("value" == r ? e = this._yField : "open" == r ? e = this._yOpenField : "high" == r ? e = this._yHighField : "low" == r && (e = this._yLowField), e && (l = d.getDataItemPositionY(i, e, 0, this.get("vcy", 1)), h = d.get("renderer").positionToPoint(l), g = h.y, p = c + b * s)) : ("value" == r ? e = this._xField : "open" == r ? e = this._xOpenField : "high" == r ? e = this._xHighField : "low" == r && (e = this._xLowField), e && (o = u.getDataItemPositionX(i, e, 0, this.get("vcx", 1)), h = u.get("renderer").positionToPoint(o), p = h.x, g = m - _ * a)) } else p = c + b * s, g = m - _ * a; const f = e.get("stacked"); if (f) { const e = this.chart; if (n == u) { let i = this._bullets[o + "_" + l]; if (i) { let s = i.bounds(), a = t.localBounds(), r = g; g = s.top, "down" == f ? g = s.bottom - a.top : "auto" == f ? e && (r < e.plotContainer.height() / 2 ? g = s.bottom - a.top : g += a.bottom) : g += a.bottom } this._bullets[o + "_" + l] = t } else { let i = this._bullets[o + "_" + l]; if (i) { let s = i.bounds(), a = t.localBounds(), r = p; p = s.right, "down" == f ? p = s.left - a.right : "auto" == f ? e && (r < e.plotContainer.width() / 2 ? p = s.left - a.right : p -= a.left) : p -= a.left } this._bullets[o + "_" + l] = t } } t.isType("Label") && (t.setPrivate("maxWidth", Math.abs(b)), t.setPrivate("maxHeight", Math.abs(_))), t.setAll({ x: p, y: g }) } else t.setPrivate("visible", !1) } } _shouldShowBullet(e, t) { return this._showBullets } setDataSet(e) { if (this._dataSets[e]) { this._handleDataSetChange(), this._dataItems = this._dataSets[e], this._markDataSetDirty(), this._dataSetId = e; const t = "datasetchanged"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, id: e }) } } resetGrouping() { c.each(this._dataSets, ((e, t) => { t != this._mainDataItems && u.each(t, (e => { this.disposeDataItem(e) })) })), this._dataSets = {}, this._dataItems = this.mainDataItems } _handleDataSetChange() { u.each(this._dataItems, (e => { let t = e.bullets; t && u.each(t, (e => { if (e) { let t = e.get("sprite"); t && t.setPrivate("visible", !1) } })) })), this._selectionProcessed = !1 } show(e) { const t = Object.create(null, { show: { get: () => super.show } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { this._fixVC(); let i = []; i.push(t.show.call(this, e).then((() => { this._isShowing = !1; let e = this.get("xAxis"), t = this.get("yAxis"), i = this.get("baseAxis"); t !== i && t.markDirtySelectionExtremes(), e !== i && e.markDirtySelectionExtremes() }))), i.push(this.bulletsContainer.show(e)), i.push(this._sequencedShowHide(!0, e)), yield Promise.all(i) })) } hide(e) { const t = Object.create(null, { hide: { get: () => super.hide } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { this._fixVC(); let i = []; i.push(t.hide.call(this, e).then((() => { this._isHiding = !1 }))), i.push(this.bulletsContainer.hide(e)), i.push(this._sequencedShowHide(!1, e)), yield Promise.all(i) })) } showDataItem(e, t) { const i = Object.create(null, { showDataItem: { get: () => super.showDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.showDataItem.call(this, e, t)]; h.isNumber(t) || (t = this.get("stateAnimationDuration", 0)); const a = this.get("stateAnimationEasing"); u.each(this._valueFields, (i => { s.push(e.animate({ key: i + "Working", to: e.get(i), duration: t, easing: a }).waitForStop()) })), yield Promise.all(s) })) } hideDataItem(e, t) { const i = Object.create(null, { hideDataItem: { get: () => super.hideDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.hideDataItem.call(this, e, t)], a = this.states.create("hidden", {}); h.isNumber(t) || (t = a.get("stateAnimationDuration", this.get("stateAnimationDuration", 0))); const r = a.get("stateAnimationEasing", this.get("stateAnimationEasing")), n = this.get("xAxis"), o = this.get("yAxis"), l = this.get("baseAxis"), c = this.get("stacked"); if (l !== n && l || u.each(this._valueYFields, (i => { let a = o.getPrivate("min"), n = o.baseValue(); h.isNumber(a) && a > n && (n = a), c && (n = 0), null != e.get(i) && s.push(e.animate({ key: i + "Working", to: n, duration: t, easing: r }).waitForStop()) })), l === o || !l) { let i = n.getPrivate("min"), a = n.baseValue(); h.isNumber(i) && i > a && (a = i), c && (a = 0), u.each(this._valueXFields, (i => { null != e.get(i) && s.push(e.animate({ key: i + "Working", to: a, duration: t, easing: r }).waitForStop()) })) } yield Promise.all(s) })) } _markDirtyStack() { this._stackDirty = !0, this.markDirty(), this._markStakedDirtyStack() } _markStakedDirtyStack() { const e = this._stackedSeries; e && c.each(e, ((e, t) => { t._stackDirty || t._markDirtyStack() })) } _afterChanged() { super._afterChanged(), this._skipped && (this._markDirtyAxes(), this._skipped = !1) } showDataItemTooltip(e) { this.getPrivate("doNotUpdateLegend") || (this.updateLegendMarker(e), this.updateLegendValue(e)); const t = this.get("tooltip"); if (t) if (!this.isHidden() && this.get("visible")) { if (t._setDataItem(e), e) { let i = this.get("locationX", 0), s = this.get("locationY", 1), a = e.get("locationX", i), r = e.get("locationY", s); const n = this.get("xAxis"), o = this.get("yAxis"), l = this.get("vcx", 1), h = this.get("vcy", 1), c = n.getDataItemPositionX(e, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * a, l), d = o.getDataItemPositionY(e, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * r, h), m = this.getPoint(c, d); let p = !0; if (u.each(this._valueFields, (t => { null == e.get(t) && (p = !1) })), p) { const i = this.chart; i && i.inPlot(m) ? (t.label.text.markDirtyText(), t.set("tooltipTarget", this._getTooltipTarget(e)), t.set("pointTo", this._display.toGlobal({ x: m.x, y: m.y }))) : t._setDataItem(void 0) } else t._setDataItem(void 0) } } else this.hideTooltip() } hideTooltip() { const e = this.get("tooltip"); return e && e.set("tooltipTarget", this), super.hideTooltip() } _getTooltipTarget(e) { if ("bullet" == this.get("seriesTooltipTarget")) { const t = e.bullets; if (t && t.length > 0) { const e = t[0].get("sprite"); if (e) return e } } return this } updateLegendValue(e) { const t = this.get("legendDataItem"); if (t) { const i = t.get("label"); if (i) { let t = ""; e ? (i._setDataItem(e), t = this.get("legendLabelText", i.get("text", this.get("name", "")))) : (i._setDataItem(this._emptyDataItem), t = this.get("legendRangeLabelText", this.get("legendLabelText", i.get("text", this.get("name", ""))))), i.set("text", t) } const s = t.get("valueLabel"); if (s) { let t = ""; e ? (s._setDataItem(e), t = this.get("legendValueText", s.get("text", ""))) : (s._setDataItem(this._emptyDataItem), t = this.get("legendRangeValueText", s.get("text", ""))), s.set("text", t) } } } _getItemReaderLabel() { let e = "X: {" + this._xField; return this.get("xAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}; Y: {" + this._yField, this.get("yAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}", e } getPoint(e, t) { let i = this.get("xAxis").get("renderer").positionToCoordinate(e), s = this.get("yAxis").get("renderer").positionToCoordinate(t), a = 999999999; return s < -a && (s = -a), s > a && (s = a), i < -a && (i = -a), i > a && (i = a), { x: i, y: s } } _shouldInclude(e) { return !0 } handleCursorHide() { this.hideTooltip(), this.updateLegendValue(void 0), this.updateLegendMarker(void 0) } _afterDataChange() { super._afterDataChange(), this.get("xAxis")._markDirtyKey("start"), this.get("yAxis")._markDirtyKey("start"), this.resetExtremes() } resetExtremes() { this.setPrivate("selectionMinX", void 0), this.setPrivate("selectionMaxX", void 0), this.setPrivate("selectionMinY", void 0), this.setPrivate("selectionMaxY", void 0), this.setPrivate("minX", void 0), this.setPrivate("minY", void 0), this.setPrivate("maxX", void 0), this.setPrivate("maxY", void 0) } createAxisRange(e) { return this.axisRanges.push({ axisDataItem: e }) } get mainDataItems() { return this._mainDataItems } _adjustStartIndex(e) { const t = this.get("xAxis"); if (this.get("baseAxis") == t && t.isType("DateAxis")) { const i = t.baseDuration(), s = t.getPrivate("selectionMin", t.getPrivate("min", 0)), a = i * this.get("locationX", .5); let r = -1 / 0; for (; r < s;) { const t = this.dataItems[e]; if (!t) break; { const i = t.open; if (r = i ? i.valueX : t.get("valueX", 0), r += a, !(r < s)) break; e++ } } } return e } } Object.defineProperty(m, "className", { enumerable: !0, configurable: !0, writable: !0, value: "XYSeries" }), Object.defineProperty(m, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: r.Series.classNames.concat([m.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/Registry.js": (e, t, i) => { i.r(t), i.d(t, { Registry: () => s, addLicense: () => r, disposeAllRootElements: () => n, getRootById: () => o, registry: () => a }); class s { constructor() { Object.defineProperty(this, "version", { enumerable: !0, configurable: !0, writable: !0, value: "5.10.3" }), Object.defineProperty(this, "licenses", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "entitiesById", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "rootElements", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } } const a = new s; function r(e) { a.licenses.push(e) } function n() { let e; for (; e = a.rootElements.pop();)e.dispose() } function o(e) { let t; return a.rootElements.forEach((i => { i.dom.id == e && (t = i) })), t } }, "./node_modules/@amcharts/amcharts5/.internal/core/Root.js": (e, t, i) => { i.r(t), i.d(t, { Root: () => L }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"), p = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js"), g = i("./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js"), b = i("./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js"), _ = i("./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js"), f = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js"), y = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), v = i("./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js"), x = i("./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js"), w = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), P = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), T = i("./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js"), D = i("./node_modules/@amcharts/amcharts5/.internal/core/Registry.js"), k = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js"), j = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), C = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), O = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), S = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), A = i("./node_modules/@amcharts/amcharts5/locales/en.js"); function M(e, t) { null == e ? requestAnimationFrame(t) : setTimeout((() => { requestAnimationFrame(t) }), 1e3 / e) } class L { constructor(e, t = {}, i) { if (Object.defineProperty(this, "dom", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_inner", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_settings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_isDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isDirtyParents", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isDirtyAnimation", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dirty", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dirtyParents", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dirtyBounds", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dirtyPositions", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_ticker", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "_tickers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_updateTick", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new y.EventDispatcher }), Object.defineProperty(this, "animationTime", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "_animations", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_renderer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_rootContainer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "container", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "tooltipContainer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipContainerSettings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltip", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "language", { enumerable: !0, configurable: !0, writable: !0, value: f.Language.new(this, {}) }), Object.defineProperty(this, "locale", { enumerable: !0, configurable: !0, writable: !0, value: A.default }), Object.defineProperty(this, "utc", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "timezone", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fps", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "numberFormatter", { enumerable: !0, configurable: !0, writable: !0, value: g.NumberFormatter.new(this, {}) }), Object.defineProperty(this, "dateFormatter", { enumerable: !0, configurable: !0, writable: !0, value: b.DateFormatter.new(this, {}) }), Object.defineProperty(this, "durationFormatter", { enumerable: !0, configurable: !0, writable: !0, value: _.DurationFormatter.new(this, {}) }), Object.defineProperty(this, "tabindex", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_tabindexes", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_a11yD", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_focusElementDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_focusElementContainer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_focusedSprite", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_isShift", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_keyboardDragPoint", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipElementContainer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_readerAlertElement", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_logo", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipDiv", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "nonce", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "interfaceColors", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "verticalLayout", { enumerable: !0, configurable: !0, writable: !0, value: o.VerticalLayout.new(this, {}) }), Object.defineProperty(this, "horizontalLayout", { enumerable: !0, configurable: !0, writable: !0, value: n.HorizontalLayout.new(this, {}) }), Object.defineProperty(this, "gridLayout", { enumerable: !0, configurable: !0, writable: !0, value: l.GridLayout.new(this, {}) }), Object.defineProperty(this, "_paused", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "autoResize", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_fontHash", { enumerable: !0, configurable: !0, writable: !0, value: "" }), Object.defineProperty(this, "_isDisposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_disposers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_resizeSensorDisposer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltips", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_htmlElementContainer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_htmlEnabledContainers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), !i) throw new Error("You cannot use `new Class()`, instead use `Class.new()`"); let s, a; if (this._settings = t, 0 == t.accessible && (this._a11yD = !0), null == t.useSafeResolution && (t.useSafeResolution = !0), t.useSafeResolution && (s = O.getSafeResolution()), this._renderer = new x.CanvasRenderer(s), a = e instanceof HTMLElement ? e : document.getElementById(e), j.each(D.registry.rootElements, (e => { if (e.dom === a) throw new Error("You cannot have multiple Roots on the same DOM node") })), this.interfaceColors = u.InterfaceColors.new(this, {}), null === a) throw new Error("Could not find HTML element with id `" + e + "`"); this.dom = a; let r = document.createElement("div"); r.style.position = "relative", r.style.width = "100%", r.style.height = "100%", a.appendChild(r); const h = t.tooltipContainerBounds; h && (this._tooltipContainerSettings = h), this._inner = r, this._updateComputedStyles(), D.registry.rootElements.push(this) } static new(e, t) { const i = new L(e, t, !0); return i._init(), i } moveDOM(e) { let t; if (t = e instanceof HTMLElement ? e : document.getElementById(e), t) { for (; this.dom.childNodes.length > 0;)t.appendChild(this.dom.childNodes[0]); this.dom = t, this._initResizeSensor(), this.resize() } } _handleLogo() { if (this._logo) { const e = this.dom.offsetWidth, t = this.dom.offsetHeight; e <= 150 || t <= 60 ? this._logo.hide() : this._logo.show() } } _showBranding() { if (!this._logo) { const e = this.tooltipContainer.children.push(a.Container.new(this, { interactive: !0, interactiveChildren: !1, position: "absolute", setStateOnChildren: !0, paddingTop: 9, paddingRight: 9, paddingBottom: 9, paddingLeft: 9, scale: .6, y: (0, w.percent)(100), centerY: w.p100, tooltipText: "Created using amCharts 5", tooltipX: w.p100, cursorOverStyle: "pointer", background: m.Rectangle.new(this, { fill: (0, P.color)(4671320), fillOpacity: 0, tooltipY: 5 }) })), t = p.Tooltip.new(this, { pointerOrientation: "horizontal", paddingTop: 4, paddingRight: 7, paddingBottom: 4, paddingLeft: 7 }); t.label.setAll({ fontSize: 12 }), t.get("background").setAll({ fill: this.interfaceColors.get("background"), stroke: this.interfaceColors.get("grid"), strokeOpacity: .3 }), e.set("tooltip", t), e.events.on("click", (() => { window.open("https://www.amcharts.com/", "_blank") })), e.states.create("hover", {}); e.children.push(d.Graphics.new(this, { stroke: (0, P.color)(13421772), strokeWidth: 3, svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6" })).states.create("hover", { stroke: (0, P.color)(3976191) }); e.children.push(d.Graphics.new(this, { stroke: (0, P.color)(8947848), strokeWidth: 3, svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0" })).states.create("hover", { stroke: (0, P.color)(4671320) }), this._logo = e, this._handleLogo() } } _getRealSize() { return this.dom.getBoundingClientRect() } _getCalculatedSize(e) { return this._settings.calculateSize ? this._settings.calculateSize(e) : { width: e.width, height: e.height } } _init() { const e = this._settings; !1 !== e.accessible && (e.focusable && (this._inner.setAttribute("focusable", "true"), this._inner.setAttribute("tabindex", this.tabindex + "")), e.ariaLabel && this._inner.setAttribute("aria-label", e.ariaLabel), e.role && this._inner.setAttribute("role", e.role)); const t = this._renderer, i = this._getRealSize(), s = this._getCalculatedSize(i), r = Math.floor(s.width), n = Math.floor(s.height), o = Math.floor(i.width), l = Math.floor(i.height), h = a.Container.new(this, { visible: !0, width: r, height: n }); this._rootContainer = h, this._rootContainer._defaultThemes.push(v.DefaultTheme.new(this)); const c = h.children.push(a.Container.new(this, { visible: !0, width: w.p100, height: w.p100 })); this.container = c, t.resize(o, l, r, n), this._inner.appendChild(t.view), this._initResizeSensor(); const u = document.createElement("div"); if (this._htmlElementContainer = u, u.className = "am5-html-container", u.style.position = "absolute", u.style.pointerEvents = "none", this._tooltipContainerSettings || (u.style.overflow = "hidden"), this._inner.appendChild(u), !0 !== this._a11yD) { const e = document.createElement("div"); e.className = "am5-reader-container", e.setAttribute("role", "alert"), e.style.position = "absolute", e.style.width = "1px", e.style.height = "1px", e.style.overflow = "hidden", e.style.clip = "rect(1px, 1px, 1px, 1px)", this._readerAlertElement = e, this._inner.appendChild(this._readerAlertElement); const i = document.createElement("div"); i.className = "am5-focus-container", i.style.position = "absolute", i.style.pointerEvents = "none", i.style.top = "0px", i.style.left = "0px", i.style.overflow = "hidden", i.style.width = r + "px", i.style.height = n + "px", i.setAttribute("role", "graphics-document"), O.setInteractive(i, !1), this._focusElementContainer = i, this._inner.appendChild(this._focusElementContainer); const s = document.createElement("div"); this._tooltipElementContainer = s, s.className = "am5-tooltip-container", this._inner.appendChild(s), O.supports("keyboardevents") && (this._disposers.push(O.addEventListener(window, "keydown", (e => { const t = O.getEventKey(e); "Shift" == t ? this._isShift = !0 : "Tab" == t && (this._isShift = e.shiftKey) }))), this._disposers.push(O.addEventListener(window, "keyup", (e => { "Shift" == O.getEventKey(e) && (this._isShift = !1) }))), this._disposers.push(O.addEventListener(i, "click", (() => { const e = this._focusedSprite; if (e) { const i = t.getEvent(new MouseEvent("click")); e.events.dispatch("click", { type: "click", originalEvent: i.event, point: i.point, simulated: !0, target: e }) } }))), this._disposers.push(O.addEventListener(i, "keydown", (e => { const i = this._focusedSprite; if (i) { "Escape" == e.key && (O.blur(), this._focusedSprite = void 0); let s = 0, a = 0; const r = O.getEventKey(e); switch (r) { case "Enter": case " ": if (" " == r && "checkbox" != i.get("role")) return; e.preventDefault(); const n = t.getEvent(new MouseEvent("mouse")); return void i.events.dispatch("click", { type: "click", originalEvent: n.event, point: n.point, simulated: !0, target: i }); case "ArrowLeft": s = -6; break; case "ArrowRight": s = 6; break; case "ArrowUp": a = -6; break; case "ArrowDown": a = 6; break; default: return }if (0 != s || 0 != a) { if (e.preventDefault(), !i.isDragging()) { this._keyboardDragPoint = { x: 0, y: 0 }; const e = t.getEvent(new MouseEvent("mousedown", { clientX: 0, clientY: 0 })); i.events.isEnabled("pointerdown") && i.events.dispatch("pointerdown", { type: "pointerdown", originalEvent: e.event, point: e.point, simulated: !0, target: i }) } const r = this._keyboardDragPoint; r.x += s, r.y += a; const n = t.getEvent(new MouseEvent("mousemove", { clientX: r.x, clientY: r.y }), !1); i.events.isEnabled("globalpointermove") && i.events.dispatch("globalpointermove", { type: "globalpointermove", originalEvent: n.event, point: n.point, simulated: !0, target: i }) } } }))), this._disposers.push(O.addEventListener(i, "keyup", (e => { if (this._focusedSprite) { const i = this._focusedSprite, s = O.getEventKey(e); switch (s) { case "ArrowLeft": case "ArrowRight": case "ArrowTop": case "ArrowDown": if (i.isDragging()) { const e = this._keyboardDragPoint, s = t.getEvent(new MouseEvent("mouseup", { clientX: e.x, clientY: e.y })); return i.events.isEnabled("globalpointerup") && i.events.dispatch("globalpointerup", { type: "globalpointerup", originalEvent: s.event, point: s.point, simulated: !0, target: i }), void (this._keyboardDragPoint = void 0) } if (i.get("focusableGroup")) { const e = i.get("focusableGroup"), t = this._tabindexes.filter((t => !(t.get("focusableGroup") != e || !1 === t.getPrivate("focusable") || !t.isVisibleDeep()))); let a = t.indexOf(i); const r = t.length - 1; a += "ArrowRight" == s || "ArrowDown" == s ? 1 : -1, a < 0 ? a = r : a > r && (a = 0), O.focus(t[a].getPrivate("focusElement").dom) } } } })))) } this._startTicker(), this.setThemes([]), this._addTooltip(), this._hasLicense() || this._showBranding() } _initResizeSensor() { this._resizeSensorDisposer && this._resizeSensorDisposer.dispose(), this._resizeSensorDisposer = new c.ResizeSensor(this.dom, (() => { this.autoResize && this.resize() })), this._disposers.push(this._resizeSensorDisposer) } resize() { const e = this._getRealSize(), t = this._getCalculatedSize(e), i = Math.floor(t.width), s = Math.floor(t.height); if (i > 0 && s > 0) { const t = Math.floor(e.width), a = Math.floor(e.height), r = this._htmlElementContainer; if (r.style.width = i + "px", r.style.height = s + "px", !0 !== this._a11yD) { const e = this._focusElementContainer; e.style.width = i + "px", e.style.height = s + "px" } this._renderer.resize(t, a, i, s); const n = this._rootContainer; n.setPrivate("width", i), n.setPrivate("height", s), this._render(), this._handleLogo() } } _render() { this._renderer.render(this._rootContainer._display), this._focusElementDirty && (this._updateCurrentFocus(), this._focusElementDirty = !1) } _runTickers(e) { j.each(this._tickers, (t => { t(e) })) } _runAnimations(e) { let t = 0; return j.keepIf(this._animations, (i => { const a = i._runAnimation(e); return a !== s.AnimationState.Stopped && (a !== s.AnimationState.Playing || (++t, !0)) })), this._isDirtyAnimation = !1, 0 === t } _runDirties() { let e = {}; for (; this._isDirtyParents;)this._isDirtyParents = !1, C.keys(this._dirtyParents).forEach((t => { const i = this._dirtyParents[t]; delete this._dirtyParents[t], i.isDisposed() || (e[i.uid] = i, i._prepareChildren()) })); C.keys(e).forEach((t => { e[t]._updateChildren() })); const t = []; C.keys(this._dirty).forEach((e => { const i = this._dirty[e]; i.isDisposed() ? delete this._dirty[i.uid] : (t.push(i), i._beforeChanged()) })), t.forEach((e => { e._changed(), delete this._dirty[e.uid], e._clearDirty() })), this._isDirty = !1; const i = {}, s = []; C.keys(this._dirtyBounds).forEach((e => { const t = this._dirtyBounds[e]; delete this._dirtyBounds[e], t.isDisposed() || (i[t.uid] = t.depth(), s.push(t)) })), this._positionHTMLElements(), s.sort(((e, t) => k.compare(i[t.uid], i[e.uid]))), s.forEach((e => { e._updateBounds() })); const a = this._dirtyPositions; C.keys(a).forEach((e => { const t = a[e]; delete a[e], t.isDisposed() || t._updatePosition() })), t.forEach((e => { e._afterChanged() })) } _renderFrame(e) { if (this._updateTick) { this.events.isEnabled("framestarted") && this.events.dispatch("framestarted", { type: "framestarted", target: this, timestamp: e }), this._checkComputedStyles(), this._runTickers(e); const t = this._runAnimations(e); return this._runDirties(), this._render(), this._renderer.resetImageArray(), this._positionHTMLElements(), this.events.isEnabled("frameended") && this.events.dispatch("frameended", { type: "frameended", target: this, timestamp: e }), 0 === this._tickers.length && t && !this._isDirtyAnimation && !this._isDirty } return !0 } _runTicker(e, t) { if (!this.isDisposed()) { this.animationTime = e; this._renderFrame(e) ? (this._ticker = null, this.animationTime = null) : this._paused || (t ? this._ticker : M(this.fps, this._ticker)) } } _runTickerNow(e = 1e4) { if (!this.isDisposed()) { const t = performance.now() + e; for (; ;) { const e = performance.now(); if (e >= t) { this.animationTime = null; break } this.animationTime = e; if (this._renderFrame(e)) { this.animationTime = null; break } } } } _startTicker() { null === this._ticker && (this.animationTime = null, this._ticker = e => { this._runTicker(e) }, M(this.fps, this._ticker)) } get updateTick() { return this._updateTick } set updateTick(e) { this._updateTick = e, e && this._startTicker() } _addDirtyEntity(e) { this._isDirty = !0, void 0 === this._dirty[e.uid] && (this._dirty[e.uid] = e), this._startTicker() } _addDirtyParent(e) { this._isDirty = !0, this._isDirtyParents = !0, void 0 === this._dirtyParents[e.uid] && (this._dirtyParents[e.uid] = e), this._startTicker() } _addDirtyBounds(e) { this._isDirty = !0, void 0 === this._dirtyBounds[e.uid] && (this._dirtyBounds[e.uid] = e), this._startTicker() } _addDirtyPosition(e) { this._isDirty = !0, void 0 === this._dirtyPositions[e.uid] && (this._dirtyPositions[e.uid] = e), this._startTicker() } _addAnimation(e) { this._isDirtyAnimation = !0, -1 === this._animations.indexOf(e) && this._animations.push(e), this._startTicker() } _markDirty() { this._isDirty = !0 } _markDirtyRedraw() { this.events.once("frameended", (() => { this._isDirty = !0, this._startTicker() })) } eachFrame(e) { return this._tickers.push(e), this._startTicker(), new h.Disposer((() => { j.removeFirst(this._tickers, e) })) } markDirtyGlobal(e) { e || (e = this.container), e.walkChildren((e => { e instanceof a.Container && this.markDirtyGlobal(e), e.markDirty(), e.markDirtyBounds() })) } width() { return Math.floor(this._getCalculatedSize(this._getRealSize()).width) } height() { return Math.floor(this._getCalculatedSize(this._getRealSize()).height) } dispose() { this._isDisposed || (this._isDisposed = !0, this._rootContainer.dispose(), this._renderer.dispose(), this.horizontalLayout.dispose(), this.verticalLayout.dispose(), this.interfaceColors.dispose(), j.each(this._disposers, (e => { e.dispose() })), this._inner && O.removeElement(this._inner), j.remove(D.registry.rootElements, this)) } isDisposed() { return this._isDisposed } readerAlert(e) { !0 !== this._a11yD && (this._readerAlertElement.innerHTML = O.stripTags(e)) } setThemes(e) { this._rootContainer.set("themes", e); const t = this.tooltipContainer; t && t._applyThemes(); const i = this.interfaceColors; i && i._applyThemes() } _addTooltip() { if (!this.tooltipContainer) { const e = this._tooltipContainerSettings, t = this._rootContainer.children.push(a.Container.new(this, { position: "absolute", isMeasured: !1, width: w.p100, height: w.p100, layer: e ? 35 : 30, layerMargin: e || void 0 })); this.tooltipContainer = t; const i = p.Tooltip.new(this, {}); this.container.set("tooltip", i), i.hide(0), this._tooltip = i } } _registerTabindexOrder(e) { 1 != this._a11yD && (e.get("focusable") ? j.pushOne(this._tabindexes, e) : j.remove(this._tabindexes, e), this._invalidateTabindexes()) } _unregisterTabindexOrder(e) { 1 != this._a11yD && (j.remove(this._tabindexes, e), this._invalidateTabindexes()) } _invalidateTabindexes() { if (1 == this._a11yD) return; this._tabindexes.sort(((e, t) => { const i = e.get("tabindexOrder", 0), s = t.get("tabindexOrder", 0); return i == s ? 0 : i > s ? 1 : -1 })); const e = []; j.each(this._tabindexes, ((t, i) => { t.getPrivate("focusElement") ? this._moveFocusElement(i, t) : this._makeFocusElement(i, t); const s = t.get("focusableGroup"); s && !1 !== t.getPrivate("focusable") && (-1 !== e.indexOf(s) ? t.getPrivate("focusElement").dom.setAttribute("tabindex", "-1") : e.push(s)) })) } _updateCurrentFocus() { 1 != this._a11yD && this._focusedSprite && (this._decorateFocusElement(this._focusedSprite), this._positionFocusElement(this._focusedSprite)) } _decorateFocusElement(e, t) { if (1 == this._a11yD) return; if (t || (t = e.getPrivate("focusElement").dom), !t) return; const i = e.get("role"); i ? t.setAttribute("role", i) : t.removeAttribute("role"); const s = e.get("ariaLabel"); if (s) { const i = (0, T.populateString)(e, s); t.setAttribute("aria-label", i) } else t.removeAttribute("aria-label"); const a = e.get("ariaLive"); a ? t.setAttribute("aria-live", a) : t.removeAttribute("aria-live"); const r = e.get("ariaChecked"); null != r && i && -1 !== ["checkbox", "option", "radio", "menuitemcheckbox", "menuitemradio", "treeitem"].indexOf(i) ? t.setAttribute("aria-checked", r ? "true" : "false") : t.removeAttribute("aria-checked"); const n = e.get("ariaCurrent"); null != n ? t.setAttribute("aria-current", n) : t.removeAttribute("aria-current"); const o = e.get("ariaSelected"); null != o && i && -1 !== ["gridcell", "option", "row", "tab", "columnheader", "rowheader", "treeitem"].indexOf(i) ? t.setAttribute("aria-selected", o ? "true" : "false") : t.removeAttribute("aria-selected"), e.get("ariaHidden") ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden"); const l = e.get("ariaOrientation"); l ? t.setAttribute("aria-orientation", l) : t.removeAttribute("aria-orientation"); const h = e.get("ariaValueNow"); h ? t.setAttribute("aria-valuenow", h) : t.removeAttribute("aria-valuenow"); const c = e.get("ariaValueMin"); c ? t.setAttribute("aria-valuemin", c) : t.removeAttribute("aria-valuemin"); const u = e.get("ariaValueMax"); u ? t.setAttribute("aria-valuemax", u) : t.removeAttribute("aria-valuemax"); const d = e.get("ariaValueText"); d ? t.setAttribute("aria-valuetext", d) : t.removeAttribute("aria-valuetext"); const m = e.get("ariaControls"); m ? t.setAttribute("aria-controls", m) : t.removeAttribute("aria-controls"), e.get("visible") && 0 !== e.get("opacity") && "tooltip" != e.get("role") && !e.isHidden() && !1 !== e.getPrivate("focusable") ? ("-1" != t.getAttribute("tabindex") && t.setAttribute("tabindex", "" + this.tabindex), t.removeAttribute("aria-hidden")) : (t.removeAttribute("tabindex"), t.setAttribute("aria-hidden", "true")) } _makeFocusElement(e, t) { if (t.getPrivate("focusElement") || 1 == this._a11yD) return; const i = document.createElement("div"); "tooltip" != t.get("role") && (i.tabIndex = this.tabindex), i.style.position = "absolute", O.setInteractive(i, !1); const s = []; t.setPrivate("focusElement", { dom: i, disposers: s }), this._decorateFocusElement(t), s.push(O.addEventListener(i, "focus", (e => { this._handleFocus(e) }))), s.push(O.addEventListener(i, "blur", (e => { this._handleBlur(e) }))), this._moveFocusElement(e, t) } _removeFocusElement(e) { if (1 == this._a11yD) return; j.remove(this._tabindexes, e); const t = e.getPrivate("focusElement"); if (t) { this._focusElementContainer.removeChild(t.dom), j.each(t.disposers, (e => { e.dispose() })) } } _hideFocusElement(e) { if (1 == this._a11yD) return; e.getPrivate("focusElement").dom.style.display = "none" } _moveFocusElement(e, t) { if (1 == this._a11yD) return; const i = this._focusElementContainer, s = t.getPrivate("focusElement").dom; if (s === this._focusElementContainer.children[e]) return; const a = this._focusElementContainer.children[e + 1]; a ? i.insertBefore(s, a) : i.append(s) } _positionFocusElement(e) { if (1 == this._a11yD || null == e) return; const t = e.globalBounds(); let i = t.right == t.left ? e.width() : t.right - t.left, s = t.top == t.bottom ? e.height() : t.bottom - t.top; const a = void 0 !== this._settings.focusPadding ? this._settings.focusPadding : 2; let r = t.left - a, n = t.top - a; i < 0 && (r += i, i = Math.abs(i)), s < 0 && (n += s, s = Math.abs(s)); const o = e.getPrivate("focusElement").dom; o.style.top = n + "px", o.style.left = r + "px", o.style.width = i + 2 * a + "px", o.style.height = s + 2 * a + "px" } _getSpriteByFocusElement(e) { let t; return j.eachContinue(this._tabindexes, ((i, s) => i.getPrivate("focusElement").dom !== e || (t = i, !1))), t } _handleFocus(e) { if (1 == this._a11yD) return; const t = this._getSpriteByFocusElement(e.target); t && (t.isVisibleDeep() ? (this._positionFocusElement(t), this._focusedSprite = t, t.events.isEnabled("focus") && t.events.dispatch("focus", { type: "focus", originalEvent: e, target: t })) : this._focusNext(e.target, this._isShift ? -1 : 1)) } _focusNext(e, t) { if (1 == this._a11yD) return; const i = Array.from(document.querySelectorAll(["a[href]", "area[href]", "button:not([disabled])", "details", "input:not([disabled])", "iframe:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", '[contentEditable=""]', '[contentEditable="true"]', '[contentEditable="TRUE"]', '[tabindex]:not([tabindex^="-"])'].join(","))); let s = i.indexOf(e) + t; s < 0 ? s = i.length - 1 : s >= i.length && (s = 0), i[s].focus() } _handleBlur(e) { if (1 == this._a11yD) return; const t = this._focusedSprite; t && !t.isDisposed() && t.events.isEnabled("blur") && t.events.dispatch("blur", { type: "blur", originalEvent: e, target: t }), this._focusedSprite = void 0 } updateTooltip(e) { if (1 == this._a11yD) return; const t = O.stripTags(e._getText()); let i = e.getPrivate("tooltipElement"); "tooltip" == e.get("role") && "" != t ? (i || (i = this._makeTooltipElement(e)), i.innerHTML != t && (i.innerHTML = t), i.setAttribute("aria-hidden", e.isVisibleDeep() ? "false" : "true")) : i && (i.remove(), e.removePrivate("tooltipElement")) } _makeTooltipElement(e) { const t = this._tooltipElementContainer, i = document.createElement("div"); return i.style.position = "absolute", i.style.width = "1px", i.style.height = "1px", i.style.overflow = "hidden", i.style.clip = "rect(1px, 1px, 1px, 1px)", O.setInteractive(i, !1), this._decorateFocusElement(e, i), t.append(i), e.setPrivate("tooltipElement", i), i } _removeTooltipElement(e) { if (1 == this._a11yD) return; const t = e.getPrivate("tooltipElement"); if (t) { const e = t.parentElement; e && e.removeChild(t) } } _invalidateAccessibility(e) { if (1 == this._a11yD) return; this._focusElementDirty = !0; const t = e.getPrivate("focusElement"); e.get("focusable") ? t && (this._decorateFocusElement(e), this._positionFocusElement(e)) : t && this._removeFocusElement(e) } focused(e) { return this._focusedSprite === e } documentPointToRoot(e) { const t = this._getRealSize(), i = this._getCalculatedSize(t), s = i.width / t.width, a = i.height / t.height; return { x: (e.x - t.left) * s, y: (e.y - t.top) * a } } rootPointToDocument(e) { const t = this._getRealSize(), i = this._getCalculatedSize(t), s = i.width / t.width, a = i.height / t.height; return { x: e.x / s + t.left, y: e.y / a + t.top } } addDisposer(e) { return this._disposers.push(e), e } _updateComputedStyles() { const e = window.getComputedStyle(this.dom); let t = ""; C.each(e, ((e, i) => { S.isString(e) && e.match(/^font/) && (t += i) })); const i = t != this._fontHash; return i && (this._fontHash = t), i } _checkComputedStyles() { this._updateComputedStyles() && this._invalidateLabelBounds(this.container) } _invalidateLabelBounds(e) { e instanceof a.Container ? e.children.each((e => { this._invalidateLabelBounds(e) })) : e instanceof r.Text && e.markDirtyBounds() } _hasLicense() { for (let e = 0; e < D.registry.licenses.length; e++)if (D.registry.licenses[e].match(/^AM5C.{5,}/i)) return !0; return !1 } _licenseApplied() { this._logo && this._logo.set("forceHidden", !0) } get debugGhostView() { return this._renderer.debugGhostView } set debugGhostView(e) { this._renderer.debugGhostView = e } set tapToActivate(e) { this._renderer.tapToActivate = e } get tapToActivate() { return this._renderer.tapToActivate } set tapToActivateTimeout(e) { this._renderer.tapToActivateTimeout = e } get tapToActivateTimeout() { return this._renderer.tapToActivateTimeout } _makeHTMLElement(e) { const t = this._htmlElementContainer, i = document.createElement("div"); return e.setPrivate("htmlElement", i), i.style.position = "absolute", i.style.overflow = "auto", i.style.boxSizing = "border-box", O.setInteractive(i, e.get("interactive", !1)), e.events.isEnabled("click") && (O.setInteractive(i, !0), this._disposers.push(O.addEventListener(i, "click", (t => { const i = this._renderer.getEvent(t); e.events.dispatch("click", { type: "click", originalEvent: i.event, point: i.point, simulated: !1, target: e }) })))), this._positionHTMLElement(e), t.append(i), j.pushOne(this._htmlEnabledContainers, e), i } _positionHTMLElements() { j.each(this._htmlEnabledContainers, (e => { this._positionHTMLElement(e) })) } _positionHTMLElement(e) { const t = e.getPrivate("htmlElement"); if (t) { const i = ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"]; j.each(i, (i => { const s = e.get(i); t.style[i] = s ? s + "px" : "" })); const s = e.compositeScale() || 1, a = e.compositeRotation() || 0; t.style.transform = "", t.style.transformOrigin = ""; const r = e.compositeOpacity(); setTimeout((() => { t.style.opacity = r + "" }), 10); const n = e.isVisibleDeep(); n && (t.style.display = "block"); const o = e.globalBounds(); t.style.top = o.top + "px", t.style.left = o.left + "px"; const l = e.get("width"), h = e.get("height"); let c = 0, u = 0; if (l && (c = e.width()), h && (u = e.height()), l && h) e.removePrivate("minWidth"), e.removePrivate("minHeight"); else { t.style.position = "fixed", t.style.width = "", t.style.height = ""; const i = t.getBoundingClientRect(); t.style.position = "absolute", l || (c = i.width), h || (u = i.height), e._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 }, e.setPrivate("minWidth", c / s), e.setPrivate("minHeight", u / s) } c > 0 && (t.style.minWidth = c + "px"), u > 0 && (t.style.minHeight = u + "px"), n && 0 != r || (t.style.display = "none"), 1 != s && (t.style.transform += "scale(" + s + ")"), 0 != a && (t.style.transform += " rotate(" + a + "deg)"), "" != t.style.transform && (t.style.transformOrigin = e.get("centerX", 0) + "%  " + e.get("centerY", 0) + "%") } } _setHTMLContent(e, t) { let i = e.getPrivate("htmlElement"); i || (i = this._makeHTMLElement(e)), i.innerHTML != t && (i.innerHTML = t) } _removeHTMLContent(e) { let t = e.getPrivate("htmlElement"); t && (this._htmlElementContainer.removeChild(t), e.removePrivate("htmlElement")), j.remove(this._htmlEnabledContainers, e) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/Theme.js": (e, t, i) => { i.r(t), i.d(t, { Theme: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); class n { constructor(e, t) { if (Object.defineProperty(this, "_root", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_rules", { enumerable: !0, configurable: !0, writable: !0, value: {} }), this._root = e, !t) throw new Error("You cannot use `new Class()`, instead use `Class.new()`") } static new(e) { const t = new this(e, !0); return t.setupDefaultRules(), t } setupDefaultRules() { } _lookupRules(e) { return this._rules[e] } ruleRaw(e, t = []) { let i = this._rules[e]; i || (i = this._rules[e] = []), t.sort(a.compare); const { index: n, found: o } = r.getSortedIndex(i, (e => { const i = a.compare(e.tags.length, t.length); return 0 === i ? a.compareArray(e.tags, t, a.compare) : i })); if (o) return i[n].template; { const e = s.Template.new({}); return i.splice(n, 0, { tags: t, template: e }), e } } rule(e, t = []) { return this.ruleRaw(e, t) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Button.js": (e, t, i) => { i.r(t), i.d(t, { Button: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class n extends a.Container { _afterNew() { this._settings.themeTags = r.mergeTags(this._settings.themeTags, ["button"]), super._afterNew(), this._settings.background || this.set("background", s.RoundedRectangle.new(this._root, { themeTags: r.mergeTags(this._settings.themeTags, ["background"]) })), this.setPrivate("trustBounds", !0) } _prepareChildren() { if (super._prepareChildren(), this.isDirty("icon")) { const e = this._prevSettings.icon, t = this.get("icon"); t !== e && (this._disposeProperty("icon"), e && e.dispose(), t && this.children.push(t), this._prevSettings.icon = t) } if (this.isDirty("label")) { const e = this._prevSettings.label, t = this.get("label"); t !== e && (this._disposeProperty("label"), e && e.dispose(), t && this.children.push(t), this._prevSettings.label = t) } } } Object.defineProperty(n, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Button" }), Object.defineProperty(n, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.Container.classNames.concat([n.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js": (e, t, i) => { i.r(t), i.d(t, { Chart: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"); class r extends s.Container { constructor() { super(...arguments), Object.defineProperty(this, "chartContainer", { enumerable: !0, configurable: !0, writable: !0, value: this.children.push(s.Container.new(this._root, { width: a.p100, height: a.p100, interactiveChildren: !1 })) }), Object.defineProperty(this, "bulletsContainer", { enumerable: !0, configurable: !0, writable: !0, value: s.Container.new(this._root, { interactiveChildren: !1, isMeasured: !1, position: "absolute", width: a.p100, height: a.p100 }) }) } } Object.defineProperty(r, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Chart" }), Object.defineProperty(r, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Container.classNames.concat([r.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js": (e, t, i) => { i.r(t), i.d(t, { Component: () => c, DataItem: () => h }); var s = i("./node_modules/tslib/tslib.es6.mjs"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"); class h extends a.Settings { constructor(e, t, i) { super(i), Object.defineProperty(this, "component", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "dataContext", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "bullets", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "open", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "close", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.dataContext = t, this.component = e, this._settings.visible = !0, this._checkDirty() } markDirty() { this.component.markDirtyValues(this) } _startAnimation() { this.component._root._addAnimation(this) } _animationTime() { return this.component._root.animationTime } _dispose() { this.component && this.component.disposeDataItem(this), super._dispose() } show(e) { this.setRaw("visible", !0), this.component && this.component.showDataItem(this, e) } hide(e) { this.setRaw("visible", !1), this.component && this.component.hideDataItem(this, e) } isHidden() { return !this.get("visible") } } class c extends r.Container { constructor() { super(...arguments), Object.defineProperty(this, "_data", { enumerable: !0, configurable: !0, writable: !0, value: new n.ListData }), Object.defineProperty(this, "_dataItems", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_mainDataItems", { enumerable: !0, configurable: !0, writable: !0, value: this._dataItems }), Object.defineProperty(this, "valueFields", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "fields", { enumerable: !0, configurable: !0, writable: !0, value: ["id"] }), Object.defineProperty(this, "_valueFields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_valueFieldsF", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_fields", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_fieldsF", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_valuesDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dataChanged", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dataGrouped", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "inited", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } set data(e) { e.incrementRef(), this._data.decrementRef(), this._data = e } get data() { return this._data } _dispose() { super._dispose(), this._data.decrementRef() } _onDataClear() { } _afterNew() { super._afterNew(), this._data.incrementRef(), this._updateFields(), this._disposers.push(this.data.events.onAll((e => { const t = this._mainDataItems; if (this.markDirtyValues(), this._markDirtyGroup(), this._dataChanged = !0, "clear" === e.type) o.each(t, (e => { e.dispose() })), t.length = 0, this._onDataClear(); else if ("push" === e.type) { const i = new h(this, e.newValue, this._makeDataItem(e.newValue)); t.push(i), this.processDataItem(i) } else if ("setIndex" === e.type) { const i = t[e.index], s = this._makeDataItem(e.newValue); i.bullets && 0 == i.bullets.length && (i.bullets = void 0), l.keys(s).forEach((e => { i.animate({ key: e, to: s[e], duration: this.get("interpolationDuration", 0), easing: this.get("interpolationEasing") }) })), i.dataContext = e.newValue } else if ("insertIndex" === e.type) { const i = new h(this, e.newValue, this._makeDataItem(e.newValue)); t.splice(e.index, 0, i), this.processDataItem(i) } else if ("removeIndex" === e.type) { t[e.index].dispose(), t.splice(e.index, 1) } else { if ("moveIndex" !== e.type) throw new Error("Unknown IStreamEvent type"); { const i = t[e.oldIndex]; t.splice(e.oldIndex, 1), t.splice(e.newIndex, 0, i) } } this._afterDataChange() }))) } _updateFields() { this.valueFields && (this._valueFields = [], this._valueFieldsF = {}, o.each(this.valueFields, (e => { this.get(e + "Field") && (this._valueFields.push(e), this._valueFieldsF[e] = { fieldKey: e + "Field", workingKey: e + "Working" }) }))), this.fields && (this._fields = [], this._fieldsF = {}, o.each(this.fields, (e => { this.get(e + "Field") && (this._fields.push(e), this._fieldsF[e] = e + "Field") }))) } get dataItems() { return this._dataItems } processDataItem(e) { } _makeDataItem(e) { const t = {}; return this._valueFields && o.each(this._valueFields, (i => { const s = this.get(this._valueFieldsF[i].fieldKey); t[i] = e[s], t[this._valueFieldsF[i].workingKey] = t[i] })), this._fields && o.each(this._fields, (i => { const s = this.get(this._fieldsF[i]); t[i] = e[s] })), t } makeDataItem(e, t) { let i = new h(this, t, e); return this.processDataItem(i), i } pushDataItem(e, t) { const i = this.makeDataItem(e, t); return this._mainDataItems.push(i), i } disposeDataItem(e) { } showDataItem(e, t) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { e.set("visible", !0) })) } hideDataItem(e, t) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { e.set("visible", !1) })) } _clearDirty() { super._clearDirty(), this._valuesDirty = !1 } _afterDataChange() { } _afterChanged() { if (super._afterChanged(), this._dataChanged) { const e = "datavalidated"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), this._dataChanged = !1 } this.inited = !0 } markDirtyValues(e) { this.markDirty(), this._valuesDirty = !0 } _markDirtyGroup() { this._dataGrouped = !1 } markDirtySize() { this._sizeDirty = !0, this.markDirty() } } Object.defineProperty(c, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Component" }), Object.defineProperty(c, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: r.Container.classNames.concat([c.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js": (e, t, i) => { i.r(t), i.d(t, { Container: () => p }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class p extends r.Sprite { constructor() { super(...arguments), Object.defineProperty(this, "_display", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeContainer() }), Object.defineProperty(this, "_childrenDisplay", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeContainer() }), Object.defineProperty(this, "children", { enumerable: !0, configurable: !0, writable: !0, value: new s.Children(this) }), Object.defineProperty(this, "_percentageSizeChildren", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_percentagePositionChildren", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_prevWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_prevHeight", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_contentWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_contentHeight", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_contentMask", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_vsbd0", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_vsbd1", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _afterNew() { super._afterNew(), this._display.addChild(this._childrenDisplay) } _dispose() { u.eachReverse(this.allChildren(), (e => { e.dispose() })), this.getPrivate("htmlElement") && this._root._removeHTMLContent(this), super._dispose() } _changed() { if (super._changed(), this.isDirty("interactiveChildren") && (this._display.interactiveChildren = this.get("interactiveChildren", !1)), this.isDirty("layout") && (this._prevWidth = 0, this._prevHeight = 0, this.markDirtyBounds(), this._prevSettings.layout && this.children.each((e => { e.removePrivate("x"), e.removePrivate("y") }))), (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) && this.children.each((e => { e.markDirtyPosition() })), this.isDirty("maskContent")) { const e = this._childrenDisplay; let t = this._contentMask; this.get("maskContent") ? t || (t = n.Rectangle.new(this._root, { x: -.5, y: -.5, width: this.width() + 1, height: this.height() + 1 }), this._contentMask = t, e.addChildAt(t._display, 0), e.mask = t._display) : t && (e.removeChild(t._display), e.mask = null, t.dispose(), this._contentMask = void 0) } } _updateSize() { super._updateSize(), u.each(this._percentageSizeChildren, (e => { e._updateSize() })), u.each(this._percentagePositionChildren, (e => { e.markDirtyPosition(), e._updateSize() })), this.updateBackground() } updateBackground() { const e = this.get("background"); let t = this._localBounds; if (t && !this.isHidden()) { let i = t.left, s = t.top, a = t.right - i, r = t.bottom - s, n = this.get("maxWidth"), o = this.get("maxHeight"); o && r > o && (r = o), n && a > n && (a = n); let l = this.width(), h = this.height(); e && (e.setAll({ width: a, height: r, x: i, y: s }), this._display.interactive && (e._display.interactive = !0)); const c = this._contentMask; c && c.setAll({ width: l + 1, height: h + 1 }); const u = this.get("verticalScrollbar"); if (u) { u.set("height", h), u.set("x", l - u.width() - u.get("marginRight", 0)), u.set("end", u.get("start", 0) + h / this._contentHeight); const e = u.get("background"); e && e.setAll({ width: u.width(), height: h }); let t = !0; this._contentHeight <= h && (t = !1), u.setPrivate("visible", t) } } } _applyThemes(e = !1) { return !!super._applyThemes(e) && (this.eachChildren((t => { t._applyThemes(e) })), !0) } _applyState(e) { super._applyState(e), this.get("setStateOnChildren") && this.eachChildren((t => { t.states.apply(e) })) } _applyStateAnimated(e, t) { super._applyStateAnimated(e, t), this.get("setStateOnChildren") && this.eachChildren((i => { i.states.applyAnimate(e, t) })) } innerWidth() { return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0) } innerHeight() { return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0) } _getBounds() { let e = this.get("width"), t = this.get("height"), i = this.getPrivate("width"), s = this.getPrivate("height"), a = { left: 0, top: 0, right: this.width(), bottom: this.height() }, r = this.get("layout"), n = !1, c = !1; if ((r instanceof o.HorizontalLayout || r instanceof h.GridLayout) && (n = !0), r instanceof l.VerticalLayout && (c = !0), null == e && null == i || null == t && null == s || this.get("verticalScrollbar")) { let e = Number.MAX_VALUE, t = e, i = -e, s = e, r = -e; const o = this.get("paddingLeft", 0), l = this.get("paddingTop", 0), h = this.get("paddingRight", 0), u = this.get("paddingBottom", 0); this.children.each((e => { if ("absolute" != e.get("position") && e.get("isMeasured")) { let a = e.adjustedLocalBounds(), o = e.x(), l = e.y(), h = o + a.left, u = o + a.right, d = l + a.top, m = l + a.bottom; n && (h -= e.get("marginLeft", 0), u += e.get("marginRight", 0)), c && (d -= e.get("marginTop", 0), m += e.get("marginBottom", 0)), h < t && (t = h), u > i && (i = u), d < s && (s = d), m > r && (r = m) } })), t == e && (t = 0), i == -e && (i = 0), s == e && (s = 0), r == -e && (r = 0), a.left = t - o, a.top = s - l, a.right = i + h, a.bottom = r + u; const m = this.get("minWidth"); d.isNumber(m) && m > 0 && a.right - a.left < m && (a.right >= m ? a.left = a.right - m : a.right = a.left + m); const p = this.get("minHeight"); d.isNumber(p) && p > 0 && a.bottom - a.top < p && (a.bottom >= p ? a.top = a.bottom - p : a.bottom = a.top + p) } else; this._contentWidth = a.right - a.left, this._contentHeight = a.bottom - a.top, d.isNumber(e) && (a.left = 0, a.right = e), d.isNumber(i) && (a.left = 0, a.right = i), d.isNumber(t) && (a.top = 0, a.bottom = t), d.isNumber(s) && (a.top = 0, a.bottom = s), this._localBounds = a } _updateBounds() { const e = this.get("layout"); e && e.updateContainer(this), super._updateBounds(), this.updateBackground() } markDirty() { super.markDirty(), this._root._addDirtyParent(this) } _prepareChildren() { const e = this.innerWidth(), t = this.innerHeight(); if (e != this._prevWidth || t != this._prevHeight) { let i = this.get("layout"), s = !1, r = !1; i && ((i instanceof o.HorizontalLayout || i instanceof h.GridLayout) && (s = !0), i instanceof l.VerticalLayout && (r = !0)), u.each(this._percentageSizeChildren, (i => { if (!s) { let t = i.get("width"); t instanceof a.Percent && i.setPrivate("width", t.value * e) } if (!r) { let e = i.get("height"); e instanceof a.Percent && i.setPrivate("height", e.value * t) } })), u.each(this._percentagePositionChildren, (e => { e.markDirtyPosition(), e.markDirtyBounds() })), this._prevWidth = e, this._prevHeight = t, this._sizeDirty = !0, this.updateBackground() } this._handleStates() } _updateHTMLContent() { const e = this.get("html"); e && "" !== e ? this._root._setHTMLContent(this, (0, c.populateString)(this, this.get("html", ""))) : this._root._removeHTMLContent(this), this._root._positionHTMLElement(this) } _updateChildren() { if (this.isDirty("html") && this._updateHTMLContent(), this.isDirty("verticalScrollbar")) { const e = this.get("verticalScrollbar"); if (e) { e._setParent(this), e.startGrip.setPrivate("visible", !1), e.endGrip.setPrivate("visible", !1), this.set("maskContent", !0), this.set("paddingRight", e.width() + e.get("marginRight", 0) + e.get("marginLeft", 0)); let t = this.get("background"); t || (t = this.set("background", n.Rectangle.new(this._root, { themeTags: ["background"], fillOpacity: 0, fill: this._root.interfaceColors.get("alternativeBackground") }))), this._vsbd0 = this.events.on("wheel", (t => { const i = t.originalEvent; if (!m.isLocalEvent(i, this)) return; i.preventDefault(); let s = i.deltaY / 5e3; const a = e.get("start", 0), r = e.get("end", 1); a + s <= 0 && (s = -a), r + s >= 1 && (s = 1 - r), a + s >= 0 && r + s <= 1 && (e.set("start", a + s), e.set("end", r + s)) })), this._disposers.push(this._vsbd0), this._vsbd1 = e.events.on("rangechanged", (() => { let t = this._contentHeight; const i = this._childrenDisplay, s = this._contentMask; i.y = -e.get("start", 0) * t, i.markDirtyLayer(), s && (s._display.y = -i.y, i.mask = s._display) })), this._disposers.push(this._vsbd1), this._display.addChild(e._display) } else { const e = this._prevSettings.verticalScrollbar; if (e) { this._display.removeChild(e._display), this._vsbd0 && this._vsbd0.dispose(), this._vsbd1 && this._vsbd1.dispose(); this._childrenDisplay.y = 0, this.setPrivate("height", void 0), this.set("maskContent", !1), this.set("paddingRight", void 0) } } } if (this.isDirty("background")) { const e = this._prevSettings.background; e && this._display.removeChild(e._display); const t = this.get("background"); t instanceof r.Sprite && (t.set("isMeasured", !1), t._setParent(this), this._display.addChildAt(t._display, 0)) } if (this.isDirty("mask")) { const e = this.get("mask"), t = this._prevSettings.mask; if (t && (this._display.removeChild(t._display), t != e && t.dispose()), e) { const t = e.parent; t && t.children.removeValue(e), e._setParent(this), this._display.addChildAt(e._display, 0), this._childrenDisplay.mask = e._display } } } _processTemplateField() { super._processTemplateField(), this.children.each((e => { e._processTemplateField() })) } walkChildren(e) { this.children.each((t => { t instanceof p && t.walkChildren(e), e(t) })) } eachChildren(e) { const t = this.get("background"); t && e(t); const i = this.get("verticalScrollbar"); i && e(i); const s = this.get("mask"); s && e(s), this.children.values.forEach((t => { e(t) })) } allChildren() { const e = []; return this.eachChildren((t => { e.push(t) })), e } _setDataItem(e) { const t = e !== this._dataItem; super._setDataItem(e); const i = this.get("html", ""); i && "" !== i && t && this._root._setHTMLContent(this, (0, c.populateString)(this, i)) } } Object.defineProperty(p, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Container" }), Object.defineProperty(p, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: r.Sprite.classNames.concat([p.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js": (e, t, i) => { i.r(t), i.d(t, { Graphics: () => h, visualSettings: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); const l = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset", "shadowBlur", "shadowColor", "shadowOpacity", "shadowOffsetX", "shadowOffsetY", "blur", "sepia", "invert", "brightness", "hue", "contrast", "saturate"]; class h extends a.Sprite { constructor() { super(...arguments), Object.defineProperty(this, "_display", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeGraphics() }), Object.defineProperty(this, "_clear", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } _beforeChanged() { if (super._beforeChanged(), (this.isDirty("draw") || this.isDirty("svgPath")) && this.markDirtyBounds(), (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) && (this._clear = !0), this._display.crisp = this.get("crisp", !1), this.isDirty("fillGradient")) { const e = this.get("fillGradient"); if (e) { this._display.isMeasured = !0; const t = e.get("target"); t && (this._disposers.push(t.events.on("boundschanged", (() => { this._markDirtyKey("fill") }))), this._disposers.push(t.events.on("positionchanged", (() => { this._markDirtyKey("fill") })))) } } if (this.isDirty("strokeGradient")) { const e = this.get("strokeGradient"); if (e) { this._display.isMeasured = !0; const t = e.get("target"); t && (this._disposers.push(t.events.on("boundschanged", (() => { this._markDirtyKey("stroke") }))), this._disposers.push(t.events.on("positionchanged", (() => { this._markDirtyKey("stroke") })))) } } } _changed() { if (super._changed(), this._clear) { this.markDirtyBounds(), this.markDirtyLayer(), this._display.clear(); let e = this.get("strokeDasharray"); n.isNumber(e) && (e = e < .5 ? [0] : [e]), this._display.setLineDash(e); const t = this.get("strokeDashoffset"); t && this._display.setLineDashOffset(t); const i = this.get("blendMode", r.BlendMode.NORMAL); this._display.blendMode = i; const s = this.get("draw"); s && "function" == typeof s && s(this._display, this); const a = this.get("svgPath"); null != a && this._display.svgPath(a) } } _afterChanged() { if (super._afterChanged(), this._clear) { const e = this.get("fill"), t = this.get("fillGradient"), i = this.get("fillPattern"), a = this.get("fillOpacity"), r = this.get("stroke"), n = this.get("strokeGradient"), l = this.get("strokePattern"), h = this.get("shadowColor"), c = this.get("shadowBlur"), u = this.get("shadowOffsetX"), d = this.get("shadowOffsetY"), m = this.get("shadowOpacity"); if (h && (c || u || d) && this._display.shadow(h, c, u, d, m), e && !t && (this._display.beginFill(e, a), this._display.endFill()), t) { if (e) { const i = t.get("stops", []); i.length && o.each(i, (t => { t.color && !t.colorInherited || !e || (t.color = e, t.colorInherited = !0), (null == t.opacity || t.opacityInherited) && (t.opacity = a, t.opacityInherited = !0) })) } const i = t.getFill(this); i && (this._display.beginFill(i, a), this._display.endFill()) } if (i) { const e = i.pattern; e && (this._display.beginFill(e, a), this._display.endFill(), i instanceof s.PicturePattern && i.events.once("loaded", (() => { this._clear = !0, this.markDirty() }))) } if (r || n || l) { const e = this.get("strokeOpacity"); let t = this.get("strokeWidth", 1); this.get("nonScalingStroke") && (t /= this.get("scale", 1)), this.get("crisp") && (t /= this._root._renderer.resolution); const i = this.get("lineJoin"); if (r && !n && (this._display.lineStyle(t, r, e, i), this._display.endStroke()), n) { const s = n.get("stops", []); s.length && o.each(s, (t => { t.color && !t.colorInherited || !r || (t.color = r, t.colorInherited = !0), (null == t.opacity || t.opacityInherited) && (t.opacity = e, t.opacityInherited = !0) })); const a = n.getFill(this); a && (this._display.lineStyle(t, a, e, i), this._display.endStroke()) } if (l) { let a = l.pattern; a && (this._display.lineStyle(t, a, e, i), this._display.endStroke(), l instanceof s.PicturePattern && l.events.once("loaded", (() => { this._clear = !0, this.markDirty() }))) } } this.getPrivate("showingTooltip") && this.showTooltip() } this._clear = !1 } } Object.defineProperty(h, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Graphics" }), Object.defineProperty(h, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.Sprite.classNames.concat([h.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js": (e, t, i) => { i.r(t), i.d(t, { GridLayout: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); class n extends s.Layout { _afterNew() { this._setRawDefault("maxColumns", Number.MAX_VALUE), super._afterNew() } updateContainer(e) { let t = e.get("paddingLeft", 0), i = e.get("paddingRight", 0), a = e.get("paddingTop", 0), n = e.maxWidth() - t - i, o = n, l = 1; (0, s.eachChildren)(e, (e => { if (e.get("visible") && e.getPrivate("visible") && !e.get("forceHidden") && "absolute" != e.get("position")) { let t = e.width(); t < o && (o = t), t > l && (l = t) } })), o = r.fitToRange(o, 1, n), l = r.fitToRange(l, 1, n); let h = 1; h = this.get("fixedWidthGrid") ? n / l : n / o, h = Math.max(1, Math.floor(h)), h = Math.min(this.get("maxColumns", Number.MAX_VALUE), h); let c = this.getColumnWidths(e, h, l, n), u = a, d = 0, m = 0; h = c.length; let p = t; (0, s.eachChildren)(e, (e => { if ("relative" == e.get("position") && e.isVisible()) { const i = e.get("marginTop", 0), s = e.get("marginBottom", 0); let a = e.adjustedLocalBounds(), r = e.get("marginLeft", 0), n = e.get("marginRight", 0), o = p + r - a.left, l = u + i - a.top; e.setPrivate("x", o), e.setPrivate("y", l), p += c[d] + n, m = Math.max(m, e.height() + i + s), d++, d >= h && (d = 0, p = t, u += m) } })) } getColumnWidths(e, t, i, r) { let n = 0, o = [], l = 0; return (0, s.eachChildren)(e, (s => { let a = s.adjustedLocalBounds(); "absolute" != s.get("position") && s.isVisible() && (this.get("fixedWidthGrid") ? o[l] = i : o[l] = Math.max(0 | o[l], a.right - a.left + s.get("marginLeft", 0) + s.get("marginRight", 0)), l < e.children.length - 1 && (l++, l == t && (l = 0))) })), a.each(o, (e => { n += e })), n > r ? t > 2 ? (t -= 1, this.getColumnWidths(e, t, i, r)) : [r] : o } } Object.defineProperty(n, "className", { enumerable: !0, configurable: !0, writable: !0, value: "GridLayout" }), Object.defineProperty(n, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Layout.classNames.concat([n.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/HorizontalLayout.js": (e, t, i) => { i.r(t), i.d(t, { HorizontalLayout: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"); class n extends s.Layout { updateContainer(e) { let t = e.get("paddingLeft", 0), i = e.innerWidth(), n = 0; (0, s.eachChildren)(e, (e => { if (e.isVisible() && "relative" == e.get("position")) { let t = e.get("width"); if (t instanceof r.Percent) { n += t.value; let s = i * t.value, a = e.get("minWidth", e.getPrivate("minWidth", -1 / 0)); a > s && (i -= a, n -= t.value); let r = e.get("maxWidth", e.getPrivate("maxWidth", 1 / 0)); s > r && (i -= r, n -= t.value) } else a.isNumber(t) || (t = e.width()), i -= t + e.get("marginLeft", 0) + e.get("marginRight", 0) } })), (i <= 0 || i == 1 / 0) && (i = .1), (0, s.eachChildren)(e, (e => { if (e.isVisible() && "relative" == e.get("position")) { let t = e.get("width"); if (t instanceof r.Percent) { let s = i * t.value / n - e.get("marginLeft", 0) - e.get("marginRight", 0), a = e.get("minWidth", e.getPrivate("minWidth", -1 / 0)), r = e.get("maxWidth", e.getPrivate("maxWidth", 1 / 0)); s = Math.min(Math.max(a, s), r), e.setPrivate("width", s) } else e._prevSettings.width instanceof r.Percent && e.setPrivate("width", void 0) } })); let o = t; (0, s.eachChildren)(e, (e => { if ("relative" == e.get("position")) if (e.isVisible()) { let t = e.adjustedLocalBounds(), i = e.get("marginLeft", 0), s = e.get("marginRight", 0), a = e.get("maxWidth"), r = t.left, n = t.right; a && n - r > a && (n = r + a); let l = o + i - r; e.setPrivate("x", l), o = l + n + s } else e.setPrivate("x", void 0) })) } } Object.defineProperty(n, "className", { enumerable: !0, configurable: !0, writable: !0, value: "HorizontalLayout" }), Object.defineProperty(n, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Layout.classNames.concat([n.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js": (e, t, i) => { i.r(t), i.d(t, { Label: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class l extends r.Container { constructor() { super(...arguments), Object.defineProperty(this, "_text", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_textKeys", { enumerable: !0, configurable: !0, writable: !0, value: ["text", "fill", "fillGradient", "fillOpacity", "textAlign", "fontFamily", "fontSize", "fontStyle", "fontWeight", "fontStyle", "fontVariant", "textDecoration", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowOpacity", "lineHeight", "baselineRatio", "direction", "textBaseline", "oversizedBehavior", "breakWords", "ellipsis", "minScale", "populateText", "role", "ignoreFormatting", "maxChars", "ariaLabel"] }) } get text() { return this._text } _afterNew() { super._afterNew(), this._makeText(), n.each(this._textKeys, (e => { const t = this.get(e); null != t && this._text.set(e, t) })), "" !== this.get("html", "") && this._text.set("text", ""), this.onPrivate("maxWidth", (() => { this._setMaxDimentions() })), this.onPrivate("maxHeight", (() => { this._setMaxDimentions() })) } _makeText() { this._text = this.children.push(s.Text.new(this._root, {})) } _updateChildren() { super._updateChildren(); const e = this._text; if (n.each(this._textKeys, (e => { this._text.set(e, this.get(e)) })), (this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isDirty("rotation")) && this._setMaxDimentions(), "" !== this.get("html", "") ? e.set("text", "") : (e.set("text", this.get("text")), this._maybeUpdateHTMLColor()), (this.isDirty("fill") || this.isDirty("fillGradient")) && this._maybeUpdateHTMLColor(), this.isDirty("textAlign") || this.isDirty("width")) { const t = this.get("textAlign"); let i; null != this.get("width") ? i = "right" == t ? a.p100 : "center" == t ? a.p50 : 0 : "left" == t || "start" == t ? i = this.get("paddingLeft", 0) : "right" != t && "end" != t || (i = -this.get("paddingRight", 0)), e.set("x", i) } const t = this.get("background"); t && t.setPrivate("visible", e._display.textVisible) } _maybeUpdateHTMLColor() { const e = this.getPrivate("htmlElement"); e && this.get("fill") && (e.style.color = this.get("fill").toCSSHex()) } _setMaxDimentions() { const e = this.get("rotation"), t = 90 == e || 270 == e || -90 == e, i = this._text, s = this.get("maxWidth", this.getPrivate("maxWidth", 1 / 0)); o.isNumber(s) ? i.set(t ? "maxHeight" : "maxWidth", s - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) : i.set(t ? "maxHeight" : "maxWidth", void 0); const a = this.get("maxHeight", this.getPrivate("maxHeight", 1 / 0)); o.isNumber(a) ? i.set(t ? "maxWidth" : "maxHeight", a - this.get("paddingTop", 0) - this.get("paddingBottom", 0)) : i.set(t ? "maxWidth" : "maxHeight", void 0), this.root.events.once("frameended", (() => { i.markDirtyBounds() })) } _setDataItem(e) { super._setDataItem(e), this._markDirtyKey("text"); const t = this._text; t.get("populateText") && t.markDirtyText(); const i = this.get("html"); i && "" !== i && this._updateHTMLContent() } getText() { return this._text._getText() } getAccessibleText() { return this._text._getAccessibleText() } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Label" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: r.Container.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js": (e, t, i) => { i.r(t), i.d(t, { Layout: () => r, eachChildren: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"); function a(e, t) { e.get("reverseChildren", !1) ? e.children.eachReverse(t) : e.children.each(t) } class r extends s.Entity { } Object.defineProperty(r, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Layout" }), Object.defineProperty(r, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Entity.classNames.concat([r.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js": (e, t, i) => { i.r(t), i.d(t, { Legend: () => c }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class c extends s.Series { constructor() { super(...arguments), Object.defineProperty(this, "itemContainers", { enumerable: !0, configurable: !0, writable: !0, value: new l.ListTemplate(o.Template.new({}), (() => a.Container._new(this._root, { themeTags: h.mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item"]), themeTagsSelf: h.mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]), background: n.RoundedRectangle.new(this._root, { themeTags: h.mergeTags(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]), themeTagsSelf: h.mergeTags(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]) }) }, [this.itemContainers.template]))) }), Object.defineProperty(this, "markers", { enumerable: !0, configurable: !0, writable: !0, value: new l.ListTemplate(o.Template.new({}), (() => a.Container._new(this._root, { themeTags: h.mergeTags(this.markers.template.get("themeTags", []), ["legend", "marker"]) }, [this.markers.template]))) }), Object.defineProperty(this, "labels", { enumerable: !0, configurable: !0, writable: !0, value: new l.ListTemplate(o.Template.new({}), (() => r.Label._new(this._root, { themeTags: h.mergeTags(this.labels.template.get("themeTags", []), ["legend", "label"]) }, [this.labels.template]))) }), Object.defineProperty(this, "valueLabels", { enumerable: !0, configurable: !0, writable: !0, value: new l.ListTemplate(o.Template.new({}), (() => r.Label._new(this._root, { themeTags: h.mergeTags(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"]) }, [this.valueLabels.template]))) }), Object.defineProperty(this, "markerRectangles", { enumerable: !0, configurable: !0, writable: !0, value: new l.ListTemplate(o.Template.new({}), (() => n.RoundedRectangle._new(this._root, { themeTags: h.mergeTags(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"]) }, [this.markerRectangles.template]))) }) } _afterNew() { this._settings.themeTags = h.mergeTags(this._settings.themeTags, ["legend"]), this.fields.push("name", "stroke", "fill"), super._afterNew() } makeItemContainer(e) { const t = this.children.push(this.itemContainers.make()); return t._setDataItem(e), this.itemContainers.push(t), t.states.create("disabled", {}), t } makeMarker() { const e = this.markers.make(); return this.markers.push(e), e.states.create("disabled", {}), e } makeLabel() { const e = this.labels.make(); return e.states.create("disabled", {}), e } makeValueLabel() { const e = this.valueLabels.make(); return e.states.create("disabled", {}), e } makeMarkerRectangle() { const e = this.markerRectangles.make(); return e.states.create("disabled", {}), e } processDataItem(e) { super.processDataItem(e); const t = this.makeItemContainer(e), i = this.get("nameField"), s = this.get("fillField"), a = this.get("strokeField"); if (t) { const r = this.get("clickTarget", "itemContainer"), n = e.dataContext; n && n.set && n.set("legendDataItem", e), t._setDataItem(e), e.set("itemContainer", t); const o = this.makeMarker(); if (o) { t.children.push(o), o._setDataItem(e), e.set("marker", o); const i = this.get("useDefaultMarker"), r = o.children.push(this.makeMarkerRectangle()); let l = e.get("fill"), h = e.get("stroke"); e.set("markerRectangle", r), n && n.get && (l = n.get(s, l), h = n.get(a, h)), h || (h = l), i ? n.on && (n.on(s, (() => { r.set("fill", n.get(s)) })), n.on(a, (() => { r.set("stroke", n.get(a)) }))) : n && n.createLegendMarker && n.createLegendMarker(), r.setAll({ fill: l, stroke: h }); const c = n.component; c && c.updateLegendMarker && c.updateLegendMarker(n) } const l = this.makeLabel(); if (l) { t.children.push(l), l._setDataItem(e), e.set("label", l), l.text.on("text", (() => { t.setRaw("ariaLabel", l.text._getText() + ("none" !== this.get("clickTarget") ? "; " + this._t("Press ENTER to toggle") : "")), t.markDirtyAccessibility() })), n && n.get && e.set("name", n.get(i)); let s = e.get("name"); s && l.set("text", s) } const h = this.makeValueLabel(); if (h && (t.children.push(h), h._setDataItem(e), e.set("valueLabel", h)), n && n.show && (n.on("visible", (e => { t.set("disabled", !e) })), n.get("visible") || t.set("disabled", !0), "none" != r)) { let i = t; "marker" == r && (i = o), this._addClickEvents(i, n, e) } this.children.values.sort(((e, t) => { const i = e.dataItem.dataContext, s = t.dataItem.dataContext; if (i && s) { const e = this.data.indexOf(i), t = this.data.indexOf(s); if (e > t) return 1; if (e < t) return -1 } return 0 })), n && n.updateLegendValue && n.updateLegendValue() } } _addClickEvents(e, t, i) { e.set("cursorOverStyle", "pointer"), e.events.on("pointerover", (() => { const e = t.component; e && e.hoverDataItem && e.hoverDataItem(t) })), e.events.on("pointerout", (() => { const e = t.component; e && e.hoverDataItem && e.unhoverDataItem(t) })), e.events.on("click", (() => { const s = i.get("label").text._getText(); t.show && t.isHidden && (t.isHidden() || !1 === t.get("visible")) ? (t.show(), e.set("disabled", !1), this._root.readerAlert(this._t("%1 shown", this._root.locale, s))) : t.hide && (t.hide(), e.set("disabled", !0), this._root.readerAlert(this._t("%1 hidden", this._root.locale, s))) })) } disposeDataItem(e) { super.disposeDataItem(e); const t = e.dataContext; if (t && t.get) { t.get("legendDataItem") == e && t.set("legendDataItem", void 0) } let i = e.get("itemContainer"); i && (this.itemContainers.removeValue(i), i.dispose()); let s = e.get("marker"); s && (this.markers.removeValue(s), s.dispose()); let a = e.get("markerRectangle"); a && (this.markerRectangles.removeValue(a), a.dispose()); let r = e.get("label"); r && (this.labels.removeValue(r), r.dispose()); let n = e.get("valueLabel"); n && (this.valueLabels.removeValue(n), n.dispose()) } } Object.defineProperty(c, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Legend" }), Object.defineProperty(c, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Series.classNames.concat([c.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js": (e, t, i) => { i.r(t), i.d(t, { Line: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js"); class r extends s.Graphics { _beforeChanged() { super._beforeChanged(), (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0) } _changed() { if (super._changed(), this._clear) { const e = this.get("points"), t = this.get("segments"); if (e && e.length > 0) { let t = e[0]; this._display.moveTo(t.x, t.y), a.segmentedLine(this._display, [[e]]) } else if (t) a.segmentedLine(this._display, t); else if (!this.get("draw")) { let e = this.width(), t = this.height(); this._display.moveTo(0, 0), this._display.lineTo(e, t) } } } } Object.defineProperty(r, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Line" }), Object.defineProperty(r, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Graphics.classNames.concat([r.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js": (e, t, i) => { i.r(t), i.d(t, { PointedRectangle: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); class r extends s.Graphics { _beforeChanged() { super._beforeChanged(), (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) && (this._clear = !0) } _changed() { if (super._changed(), this._clear) { this.markDirtyBounds(); let e = this.width(), t = this.height(); if (e > 0 && t > 0) { let i = this.get("cornerRadius", 8); i = a.fitToRange(i, 0, Math.min(e / 2, t / 2)); let s = this.get("pointerX", 0), r = this.get("pointerY", 0), n = this.get("pointerBaseWidth", 15) / 2, o = 0, l = 0, h = 0, c = (s - o) * (t - l) - (r - l) * (e - o), u = (s - h) * (0 - t) - (r - t) * (e - h); const d = this._display; if (d.moveTo(i, 0), c > 0 && u > 0) { let t = Math.round(a.fitToRange(s, i + n, e - n - i)); r = a.fitToRange(r, -1 / 0, 0), d.lineTo(t - n, 0), d.lineTo(s, r), d.lineTo(t + n, 0) } if (d.lineTo(e - i, 0), d.arcTo(e, 0, e, i, i), c > 0 && u < 0) { let o = Math.round(a.fitToRange(r, i + n, t - n - i)); s = a.fitToRange(s, e, 1 / 0), d.lineTo(e, i), d.lineTo(e, Math.max(o - n, i)), d.lineTo(s, r), d.lineTo(e, o + n) } if (d.lineTo(e, t - i), d.arcTo(e, t, e - i, t, i), c < 0 && u < 0) { let o = Math.round(a.fitToRange(s, i + n, e - n - i)); r = a.fitToRange(r, t, 1 / 0), d.lineTo(e - i, t), d.lineTo(o + n, t), d.lineTo(s, r), d.lineTo(o - n, t) } if (d.lineTo(i, t), d.arcTo(0, t, 0, t - i, i), c < 0 && u > 0) { let e = Math.round(a.fitToRange(r, i + n, t - i - n)); s = a.fitToRange(s, -1 / 0, 0), d.lineTo(0, t - i), d.lineTo(0, e + n), d.lineTo(s, r), d.lineTo(0, Math.max(e - n, i)) } d.lineTo(0, i), d.arcTo(0, 0, i, 0, i), d.closePath() } } } } Object.defineProperty(r, "className", { enumerable: !0, configurable: !0, writable: !0, value: "PointedRectangle" }), Object.defineProperty(r, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Graphics.classNames.concat([r.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js": (e, t, i) => { i.r(t), i.d(t, { Rectangle: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Graphics.js"); class a extends s.Graphics { _afterNew() { super._afterNew(), this._display.isMeasured = !0, this.setPrivateRaw("trustBounds", !0) } _beforeChanged() { super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0) } _changed() { super._changed(), this._clear && !this.get("draw") && this._draw() } _draw() { this._display.drawRect(0, 0, this.width(), this.height()) } _updateSize() { this.markDirty(), this._clear = !0 } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Rectangle" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Graphics.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/RoundedRectangle.js": (e, t, i) => { i.r(t), i.d(t, { RoundedRectangle: () => o }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Rectangle.js"); class o extends n.Rectangle { _beforeChanged() { super._beforeChanged(), (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) && (this._clear = !0) } _draw() { let e = this.width(), t = this.height(), i = e, n = t, o = i / Math.abs(e), l = n / Math.abs(t); if (s.isNumber(i) && s.isNumber(n)) { let e = Math.min(i, n) / 2, t = r.relativeToValue(this.get("cornerRadiusTL", 8), e), s = r.relativeToValue(this.get("cornerRadiusTR", 8), e), h = r.relativeToValue(this.get("cornerRadiusBR", 8), e), c = r.relativeToValue(this.get("cornerRadiusBL", 8), e), u = Math.min(Math.abs(i / 2), Math.abs(n / 2)); t = a.fitToRange(t, 0, u), s = a.fitToRange(s, 0, u), h = a.fitToRange(h, 0, u), c = a.fitToRange(c, 0, u); const d = this._display; d.moveTo(t * o, 0), d.lineTo(i - s * o, 0), s > 0 && d.arcTo(i, 0, i, s * l, s), d.lineTo(i, n - h * l), h > 0 && d.arcTo(i, n, i - h * o, n, h), d.lineTo(c * o, n), c > 0 && d.arcTo(0, n, 0, n - c * l, c), d.lineTo(0, t * l), t > 0 && d.arcTo(0, 0, t * o, 0, t), d.closePath() } } } Object.defineProperty(o, "className", { enumerable: !0, configurable: !0, writable: !0, value: "RoundedRectangle" }), Object.defineProperty(o, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: n.Rectangle.classNames.concat([o.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/SerialChart.js": (e, t, i) => { i.r(t), i.d(t, { SerialChart: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Chart.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); class l extends s.Chart { constructor() { super(...arguments), Object.defineProperty(this, "seriesContainer", { enumerable: !0, configurable: !0, writable: !0, value: a.Container.new(this._root, { width: n.p100, height: n.p100, isMeasured: !1 }) }), Object.defineProperty(this, "series", { enumerable: !0, configurable: !0, writable: !0, value: new r.ListAutoDispose }) } _afterNew() { super._afterNew(), this._disposers.push(this.series); const e = this.seriesContainer.children; this._disposers.push(this.series.events.onAll((t => { if ("clear" === t.type) { o.each(t.oldValues, (e => { this._removeSeries(e) })); const e = this.get("colors"); e && e.reset(); const i = this.get("patterns"); i && i.reset() } else if ("push" === t.type) e.moveValue(t.newValue), this._processSeries(t.newValue); else if ("setIndex" === t.type) e.setIndex(t.index, t.newValue), this._processSeries(t.newValue); else if ("insertIndex" === t.type) e.insertIndex(t.index, t.newValue), this._processSeries(t.newValue); else if ("removeIndex" === t.type) this._removeSeries(t.oldValue); else { if ("moveIndex" !== t.type) throw new Error("Unknown IListEvent type"); e.moveValue(t.value, t.newIndex), this._processSeries(t.value) } }))) } _processSeries(e) { e.chart = this, e._placeBulletsContainer(this) } _removeSeries(e) { e.isDisposed() || (this.seriesContainer.children.removeValue(e), e._removeBulletsContainer()) } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "SerialChart" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Chart.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Series.js": (e, t, i) => { i.r(t), i.d(t, { Series: () => p }); var s = i("./node_modules/tslib/tslib.es6.mjs"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Component.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js"); class p extends a.Component { constructor() { super(...arguments), Object.defineProperty(this, "_aggregatesCalculated", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_selectionAggregatesCalculated", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dataProcessed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_psi", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_pei", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "chart", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "bullets", { enumerable: !0, configurable: !0, writable: !0, value: new r.List }), Object.defineProperty(this, "bulletsContainer", { enumerable: !0, configurable: !0, writable: !0, value: h.Container.new(this._root, { width: l.p100, height: l.p100, position: "absolute" }) }) } _afterNew() { this.valueFields.push("value", "customValue"), super._afterNew(), this.setPrivate("customData", {}), this._disposers.push(this.bullets.events.onAll((e => { if ("clear" === e.type) this._handleBullets(this.dataItems); else if ("push" === e.type) this._handleBullets(this.dataItems); else if ("setIndex" === e.type) this._handleBullets(this.dataItems); else if ("insertIndex" === e.type) this._handleBullets(this.dataItems); else if ("removeIndex" === e.type) this._handleBullets(this.dataItems); else { if ("moveIndex" !== e.type) throw new Error("Unknown IListEvent type"); this._handleBullets(this.dataItems) } }))) } _dispose() { this.bulletsContainer.dispose(), super._dispose() } startIndex() { let e = this.dataItems.length; return Math.min(this.getPrivate("startIndex", 0), e) } endIndex() { let e = this.dataItems.length; return Math.min(this.getPrivate("endIndex", e), e) } _handleBullets(e) { u.each(e, (e => { const t = e.bullets; t && (u.each(t, (e => { e.dispose() })), e.bullets = void 0) })), this.markDirtyValues() } getDataItemById(e) { return u.find(this.dataItems, (t => t.get("id") == e)) } _makeBullets(e) { this._shouldMakeBullet(e) && (e.bullets = [], this.bullets.each((t => { this._makeBullet(e, t) }))) } _shouldMakeBullet(e) { return !0 } _makeBullet(e, t, i) { const s = t(this._root, this, e); return s && (s._index = i, this._makeBulletReal(e, s)), s } _makeBulletReal(e, t) { let i = t.get("sprite"); i && (i._setDataItem(e), i.setRaw("position", "absolute"), this.bulletsContainer.children.push(i)), t.series = this, e.bullets.push(t) } addBullet(e, t) { e.bullets || (e.bullets = []), t && this._makeBulletReal(e, t) } _clearDirty() { super._clearDirty(), this._aggregatesCalculated = !1, this._selectionAggregatesCalculated = !1 } _prepareChildren() { super._prepareChildren(); let e = this.startIndex(), t = this.endIndex(); if (this.isDirty("name") && this.updateLegendValue(), this.isDirty("heatRules") && (this._valuesDirty = !0), this.isPrivateDirty("baseValueSeries")) { const e = this.getPrivate("baseValueSeries"); e && this._disposers.push(e.onPrivate("startIndex", (() => { this.markDirtyValues() }))) } if (this.get("calculateAggregates") && (this._valuesDirty && !this._dataProcessed && (this._aggregatesCalculated || (this._calculateAggregates(0, this.dataItems.length), this._aggregatesCalculated = !0, 0 != e && (this._psi = void 0))), this._psi == e && this._pei == t && !this.isPrivateDirty("adjustedStartIndex") || this._selectionAggregatesCalculated || (0 === e && t === this.dataItems.length && this._aggregatesCalculated || this._calculateAggregates(e, t), this._selectionAggregatesCalculated = !0)), this.isDirty("tooltip")) { let e = this.get("tooltip"); e && (e.hide(0), e.set("tooltipTarget", this)) } if (this.isDirty("fill") || this.isDirty("stroke")) { let e; const t = this.get("legendDataItem"); if (t && (e = t.get("markerRectangle"), e && this.isVisible())) { if (this.isDirty("stroke")) { let t = this.get("stroke"); e.set("stroke", t) } if (this.isDirty("fill")) { let t = this.get("fill"); e.set("fill", t) } } this.updateLegendMarker(void 0) } if (this.bullets.length > 0) { let e = this.startIndex(), t = this.endIndex(); t < this.dataItems.length && t++; for (let i = e; i < t; i++) { let e = this.dataItems[i]; e.bullets || this._makeBullets(e) } } } _adjustStartIndex(e) { return e } _calculateAggregates(e, t) { let i = this._valueFields; if (!i) throw new Error("No value fields are set for the series."); const s = {}, a = {}, r = {}, n = {}, o = {}, l = {}, h = {}, c = {}, d = {}; u.each(i, (e => { s[e] = 0, a[e] = 0, r[e] = 0 })), u.each(i, (i => { let u = i + "Change", m = i + "ChangePercent", p = i + "ChangePrevious", g = i + "ChangePreviousPercent", b = i + "ChangeSelection", _ = i + "ChangeSelectionPercent", f = "valueY"; "valueX" != i && "openValueX" != i && "lowValueX" != i && "highValueX" != i || (f = "valueX"); const y = this.getPrivate("baseValueSeries"), v = this.getPrivate("adjustedStartIndex", e); for (let x = v; x < t; x++) { const t = this.dataItems[x]; if (t) { let v = t.get(i); null != v && (r[i]++, s[i] += v, a[i] += Math.abs(v), c[i] = s[i] / r[i], (n[i] > v || null == n[i]) && (n[i] = v), (o[i] < v || null == o[i]) && (o[i] = v), h[i] = v, null == l[i] && (l[i] = v, d[i] = v, y && (l[f] = y._getBase(f))), 0 === e && (t.setRaw(u, v - l[f]), t.setRaw(m, (v - l[f]) / l[f] * 100)), t.setRaw(p, v - d[f]), t.setRaw(g, (v - d[f]) / d[f] * 100), t.setRaw(b, v - l[f]), t.setRaw(_, (v - l[f]) / l[f] * 100), d[i] = v) } } if (t < this.dataItems.length - 1) { const e = this.dataItems[t]; if (e) { let t = e.get(i); e.setRaw(p, t - d[f]), e.setRaw(g, (t - d[f]) / d[f] * 100), e.setRaw(b, t - l[f]), e.setRaw(_, (t - l[f]) / l[f] * 100) } } e > 0 && e--, delete d[i]; for (let t = e; t < v; t++) { const e = this.dataItems[t]; if (e) { let t = e.get(i); null == d[i] && (d[i] = t), null != t && (e.setRaw(p, t - d[f]), e.setRaw(g, (t - d[f]) / d[f] * 100), e.setRaw(b, t - l[f]), e.setRaw(_, (t - l[f]) / l[f] * 100), d[i] = t) } } })), u.each(i, (e => { this.setPrivate(e + "AverageSelection", c[e]), this.setPrivate(e + "CountSelection", r[e]), this.setPrivate(e + "SumSelection", s[e]), this.setPrivate(e + "AbsoluteSumSelection", a[e]), this.setPrivate(e + "LowSelection", n[e]), this.setPrivate(e + "HighSelection", o[e]), this.setPrivate(e + "OpenSelection", l[e]), this.setPrivate(e + "CloseSelection", h[e]) })), 0 === e && t === this.dataItems.length && u.each(i, (e => { this.setPrivate(e + "Average", c[e]), this.setPrivate(e + "Count", r[e]), this.setPrivate(e + "Sum", s[e]), this.setPrivate(e + "AbsoluteSum", a[e]), this.setPrivate(e + "Low", n[e]), this.setPrivate(e + "High", o[e]), this.setPrivate(e + "Open", l[e]), this.setPrivate(e + "Close", h[e]) })) } _updateChildren() { super._updateChildren(), this._psi = this.startIndex(), this._pei = this.endIndex(), this.isDirty("visible") && this.bulletsContainer.set("visible", this.get("visible")); const e = this.get("heatRules"); if (this._valuesDirty && e && e.length > 0 && u.each(e, (e => { const t = e.minValue || this.getPrivate(e.dataField + "Low") || 0, i = e.maxValue || this.getPrivate(e.dataField + "High") || 0; u.each(e.target._entities, (s => { const a = s.dataItem.get(e.dataField); if (!d.isNumber(a)) { e.neutral && s.set(e.key, e.neutral); const t = s.states; if (t) { const i = t.lookup("default"); i && e.neutral && i.set(e.key, e.neutral) } if (!e.customFunction) return } if (e.customFunction) e.customFunction.call(this, s, t, i, a); else { let r, h; r = e.logarithmic ? (Math.log(a) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(t) * Math.LOG10E) : (a - t) / (i - t), !d.isNumber(a) || d.isNumber(r) && Math.abs(r) != 1 / 0 || (r = .5), d.isNumber(e.min) ? h = e.min + (e.max - e.min) * r : e.min instanceof n.Color ? h = n.Color.interpolate(r, e.min, e.max) : e.min instanceof l.Percent && (h = (0, o.percentInterpolate)(r, e.min, e.max)), s.set(e.key, h); const c = s.states; if (c) { const t = c.lookup("default"); t && t.set(e.key, h) } } })) })), this.get("visible")) { let e = this.dataItems.length, t = this.startIndex(), i = this.endIndex(); i < e && i++, t > 0 && t--; for (let e = 0; e < t; e++)this._hideBullets(this.dataItems[e]); for (let e = t; e < i; e++)this._positionBullets(this.dataItems[e]); for (let t = i; t < e; t++)this._hideBullets(this.dataItems[t]) } } _positionBullets(e) { e.bullets && u.each(e.bullets, (e => { this._positionBullet(e); const t = e.get("sprite"); e.get("dynamic") && (t && (t._markDirtyKey("fill"), t.markDirtySize()), t instanceof h.Container && t.walkChildren((e => { e._markDirtyKey("fill"), e.markDirtySize(), e instanceof c.Label && e.text.markDirtyText() }))), t instanceof c.Label && t.get("populateText") && t.text.markDirtyText() })) } _hideBullets(e) { e.bullets && u.each(e.bullets, (e => { let t = e.get("sprite"); t && t.setPrivate("visible", !1) })) } _positionBullet(e) { } _placeBulletsContainer(e) { e.bulletsContainer.children.moveValue(this.bulletsContainer) } _removeBulletsContainer() { const e = this.bulletsContainer; e.parent && e.parent.children.removeValue(e) } disposeDataItem(e) { const t = e.bullets; t && u.each(t, (e => { e.dispose() })) } _getItemReaderLabel() { return "" } showDataItem(e, t) { const i = Object.create(null, { showDataItem: { get: () => super.showDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.showDataItem.call(this, e, t)], a = e.bullets; a && u.each(a, (e => { const i = e.get("sprite"); i && s.push(i.show(t)) })), yield Promise.all(s) })) } hideDataItem(e, t) { const i = Object.create(null, { hideDataItem: { get: () => super.hideDataItem } }); return (0, s.__awaiter)(this, void 0, void 0, (function* () { const s = [i.hideDataItem.call(this, e, t)], a = e.bullets; a && u.each(a, (e => { const i = e.get("sprite"); i && s.push(i.hide(t)) })), yield Promise.all(s) })) } _sequencedShowHide(e, t) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { if (this.get("sequencedInterpolation")) if (d.isNumber(t) || (t = this.get("interpolationDuration", 0)), t > 0) { const i = this.startIndex(), a = this.endIndex(); yield Promise.all(u.map(this.dataItems, ((r, n) => (0, s.__awaiter)(this, void 0, void 0, (function* () { let s = t || 0; (n < i - 10 || n > a + 10) && (s = 0); let o = this.get("sequencedDelay", 0) + s / (a - i); yield m.sleep(o * (n - i)), e ? yield this.showDataItem(r, s) : yield this.hideDataItem(r, s) }))))) } else yield Promise.all(u.map(this.dataItems, (t => e ? this.showDataItem(t, 0) : this.hideDataItem(t, 0)))) })) } updateLegendValue(e) { if (e) { const t = e.get("legendDataItem"); if (t) { const i = t.get("valueLabel"); if (i) { const t = i.text; let s = ""; i._setDataItem(e), s = this.get("legendValueText", t.get("text", "")), i.set("text", s), t.markDirtyText() } const s = t.get("label"); if (s) { const t = s.text; let i = ""; s._setDataItem(e), i = this.get("legendLabelText", t.get("text", "")), s.set("text", i), t.markDirtyText() } } } } updateLegendMarker(e) { } _onHide() { super._onHide(); const e = this.getTooltip(); e && e.hide() } hoverDataItem(e) { } unhoverDataItem(e) { } _getBase(e) { const t = this.dataItems[this.startIndex()]; return t ? t.get(e) : 0 } } Object.defineProperty(p, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Series" }), Object.defineProperty(p, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.Component.classNames.concat([p.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js": (e, t, i) => { i.r(t), i.d(t, { Sprite: () => b }); var s = i("./node_modules/tslib/tslib.es6.mjs"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), p = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); class g extends o.EventDispatcher { constructor(e) { super(), Object.defineProperty(this, "_sprite", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_rendererDisposers", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dispatchParents", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), this._sprite = e } _makePointerEvent(e, t) { return { type: e, originalEvent: t.event, point: t.point, simulated: t.simulated, native: t.native, target: this._sprite } } _onRenderer(e, t) { this._sprite.set("interactive", !0), this._sprite._display.interactive = !0; let i = this._rendererDisposers[e]; if (void 0 === i) { const s = this._sprite._display.on(e, (e => { t.call(this, e) })); i = this._rendererDisposers[e] = new l.CounterDisposer((() => { delete this._rendererDisposers[e], s.dispose() })) } return i.increment() } _on(e, t, i, s, a, r) { const n = super._on(e, t, i, s, a, r), o = g.RENDERER_EVENTS[t]; return void 0 !== o && (n.disposer = new l.MultiDisposer([n.disposer, this._onRenderer(t, o)])), n } stopParentDispatch() { this._dispatchParents = !1 } dispatchParents(e, t) { const i = this._dispatchParents; this._dispatchParents = !0; try { this.dispatch(e, t), this._dispatchParents && this._sprite.parent && this._sprite.parent.events.dispatchParents(e, t) } finally { this._dispatchParents = i } } } Object.defineProperty(g, "RENDERER_EVENTS", { enumerable: !0, configurable: !0, writable: !0, value: { click: function (e) { this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", e)) && this.dispatch("click", this._makePointerEvent("click", e)) }, rightclick: function (e) { this.isEnabled("rightclick") && this.dispatch("rightclick", this._makePointerEvent("rightclick", e)) }, middleclick: function (e) { this.isEnabled("middleclick") && this.dispatch("middleclick", this._makePointerEvent("middleclick", e)) }, dblclick: function (e) { this.dispatchParents("dblclick", this._makePointerEvent("dblclick", e)) }, pointerover: function (e) { const t = this._sprite; let i = !0; if (t.getPrivate("trustBounds")) { t._getBounds(); const s = t.globalBounds(); if (t.isType("Graphics")) { const e = t.get("strokeWidth", 1) / 2; e >= 1 && (s.left -= e, s.right += e, s.top -= e, s.bottom += e) } p.inBounds(e.point, s) || (i = !1, t._root._renderer.removeHovering(t._display)) } i && this.isEnabled("pointerover") && this.dispatch("pointerover", this._makePointerEvent("pointerover", e)) }, pointerout: function (e) { this.isEnabled("pointerout") && this.dispatch("pointerout", this._makePointerEvent("pointerout", e)) }, pointerdown: function (e) { this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", e)) }, pointerup: function (e) { this.isEnabled("pointerup") && this.dispatch("pointerup", this._makePointerEvent("pointerup", e)) }, globalpointerup: function (e) { this.isEnabled("globalpointerup") && this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", e)) }, globalpointermove: function (e) { this.isEnabled("globalpointermove") && this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", e)) }, wheel: function (e) { this.dispatchParents("wheel", { type: "wheel", target: this._sprite, originalEvent: e.event, point: e.point }) } } }); class b extends a.Entity { constructor() { super(...arguments), Object.defineProperty(this, "_adjustedLocalBounds", { enumerable: !0, configurable: !0, writable: !0, value: { left: 0, right: 0, top: 0, bottom: 0 } }), Object.defineProperty(this, "_localBounds", { enumerable: !0, configurable: !0, writable: !0, value: { left: 0, right: 0, top: 0, bottom: 0 } }), Object.defineProperty(this, "_parent", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_dataItem", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_templateField", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_sizeDirty", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isDragging", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_dragEvent", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_dragPoint", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_isHidden", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isShowing", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isHiding", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_isDown", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_downPoint", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_downPoints", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_toggleDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_dragDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_hoverDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_focusDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipMoveDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_tooltipPointerDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_statesHandled", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } _afterNew() { this.setPrivateRaw("visible", !0), super._afterNew() } markDirtyKey(e) { this._markDirtyKey(e) } _markDirtyKey(e) { super._markDirtyKey(e), "x" != e && "y" != e && "dx" != e && "dy" != e || (this.markDirtyBounds(), this._addPercentagePositionChildren(), this.markDirtyPosition()) } _markDirtyPrivateKey(e) { super._markDirtyPrivateKey(e), "x" != e && "y" != e || this.markDirtyPosition() } _removeTemplateField() { this._templateField && this._templateField._removeObjectTemplate(this) } _createEvents() { return new g(this) } _processTemplateField() { let e; const t = this.get("templateField"); if (t) { const i = this.dataItem; if (i) { const s = i.dataContext; s && (e = s[t], e instanceof r.Template || !e || (e = r.Template.new(e))) } } this._templateField !== e && (this._removeTemplateField(), this._templateField = e, e && e._setObjectTemplate(this), this._applyTemplates()) } _setDataItem(e) { const t = this._dataItem; this._dataItem = e, this._processTemplateField(); const i = "dataitemchanged"; e != t && this.events.isEnabled(i) && this.events.dispatch(i, { type: i, target: this, oldDataItem: t, newDataItem: e }) } set dataItem(e) { this._setDataItem(e) } get dataItem() { if (this._dataItem) return this._dataItem; { let e = this._parent; for (; e;) { if (e._dataItem) return e._dataItem; e = e._parent } } } _addPercentageSizeChildren() { let e = this.parent; e && (this.get("width") instanceof n.Percent || this.get("height") instanceof n.Percent ? u.pushOne(e._percentageSizeChildren, this) : u.removeFirst(e._percentageSizeChildren, this)) } _addPercentagePositionChildren() { let e = this.parent; e && (this.get("x") instanceof n.Percent || this.get("y") instanceof n.Percent ? u.pushOne(e._percentagePositionChildren, this) : u.removeFirst(e._percentagePositionChildren, this)) } markDirtyPosition() { this._root._addDirtyPosition(this) } updatePivotPoint() { const e = this._localBounds; if (e) { const t = this.get("centerX"); null != t && (this._display.pivot.x = e.left + c.relativeToValue(t, e.right - e.left)); const i = this.get("centerY"); null != i && (this._display.pivot.y = e.top + c.relativeToValue(i, e.bottom - e.top)) } } _beforeChanged() { if (super._beforeChanged(), this._handleStates(), this.isDirty("tooltip")) { const e = this._prevSettings.tooltip; e && e.dispose() } if ((this.isDirty("layer") || this.isDirty("layerMargin")) && (this._display.setLayer(this.get("layer"), this.get("layerMargin")), this.markDirtyLayer()), this.isDirty("tooltipPosition")) { const e = this._tooltipMoveDp; e && (e.dispose(), this._tooltipMoveDp = void 0); const t = this._tooltipPointerDp; t && (t.dispose(), this._tooltipPointerDp = void 0), "pointer" == this.get("tooltipPosition") && (this.isHover() && (this._tooltipMoveDp = this.events.on("globalpointermove", (e => { this.showTooltip(e.point) }))), this._tooltipPointerDp = new l.MultiDisposer([this.events.on("pointerover", (() => { this._tooltipMoveDp = this.events.on("globalpointermove", (e => { this.showTooltip(e.point) })) })), this.events.on("pointerout", (() => { const e = this._tooltipMoveDp; e && (e.dispose(), this._tooltipMoveDp = void 0) }))])) } } _handleStates() { this._statesHandled || (this.isDirty("active") && (this.get("active") ? (this.states.applyAnimate("active"), this.set("ariaChecked", !0)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !1)), this.markDirtyAccessibility()), this.isDirty("disabled") && (this.get("disabled") ? (this.states.applyAnimate("disabled"), this.set("ariaChecked", !1)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !0)), this.markDirtyAccessibility()), this._statesHandled = !0) } _changed() { super._changed(); const e = this._display, t = this.events; if (this.isDirty("draggable")) { const i = this.get("draggable"); i ? (this.set("interactive", !0), this._dragDp = new l.MultiDisposer([t.on("pointerdown", (e => { this.dragStart(e) })), t.on("globalpointermove", (e => { this.dragMove(e) })), t.on("globalpointerup", (e => { this.dragStop(e) }))])) : this._dragDp && (this._dragDp.dispose(), this._dragDp = void 0), e.cancelTouch = !!i } if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) { const e = this.get("tooltipText"), i = this.get("tooltipHTML"), s = this.get("showTooltipOn", "hover"); this._tooltipDp && (this._tooltipDp.dispose(), this._tooltipDp = void 0), (e || i) && ("click" == s ? (this._tooltipDp = new l.MultiDisposer([t.on("click", (() => { this.setTimeout((() => this.showTooltip()), 10) })), c.addEventListener(document, "click", (e => { this.hideTooltip() }))]), this._disposers.push(this._tooltipDp)) : "always" == s || (this._tooltipDp = new l.MultiDisposer([t.on("pointerover", (() => { this.showTooltip() })), t.on("pointerout", (() => { this.hideTooltip() }))]), this._disposers.push(this._tooltipDp))) } if (this.isDirty("toggleKey")) { let e = this.get("toggleKey"); e && "none" != e ? this._toggleDp = t.on("click", (() => { this._isDragging || this.set(e, !this.get(e)) })) : this._toggleDp && (this._toggleDp.dispose(), this._toggleDp = void 0) } if (this.isDirty("opacity") && (e.alpha = Math.max(0, this.get("opacity", 1)), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("rotation") && (this.markDirtyBounds(), e.angle = this.get("rotation", 0)), this.isDirty("scale") && (this.markDirtyBounds(), e.scale = this.get("scale", 0)), (this.isDirty("centerX") || this.isDirty("centerY")) && (this.markDirtyBounds(), this.updatePivotPoint()), (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) && (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden") ? e.visible = !0 : (e.visible = !1, this.hideTooltip()), this.markDirtyBounds(), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("width") || this.isDirty("height")) { this.markDirtyBounds(), this._addPercentageSizeChildren(); const e = this.parent; e && (this.isDirty("width") && this.get("width") instanceof n.Percent || this.isDirty("height") && this.get("height") instanceof n.Percent) && (e.markDirty(), e._prevWidth = 0), this._sizeDirty = !0 } if ((this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight") || this.isDirty("marginLeft") || this.isDirty("marginTop") || this.isDirty("marginRight") || this.isDirty("marginBottom")) && (this.markDirtyBounds(), this._sizeDirty = !0), this._sizeDirty && this._updateSize(), this.isDirty("wheelable")) { const t = this.get("wheelable"); t && this.set("interactive", !0), e.wheelable = !!t } (this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this)), this.isDirty("filter") && (e.filter = this.get("filter")); let i = this.get("filter", ""); if (this.isDirty("blur")) { const e = this.get("blur", 0); 0 != e && (i += " blur(" + e + "px)") } if (this.isDirty("saturate")) { const e = this.get("saturate", 1); 1 != e && (i += " saturate(" + e + ")") } if (this.isDirty("brightness")) { const e = this.get("brightness", 1); 1 != e && (i += " brightness(" + e + ")") } if (this.isDirty("contrast")) { const e = this.get("contrast", 1); 1 != e && (i += " contrast(" + e + ")") } if (this.isDirty("sepia")) { const e = this.get("sepia", 0); 0 != e && (i += " sepia(" + e + ")") } if (this.isDirty("hue")) { const e = this.get("hue", 0); 0 != e && (i += " hue-rotate(" + e + "deg)") } if (this.isDirty("invert")) { const e = this.get("invert", 0); 0 != e && (i += " invert(" + e + ")") } if (i && (e.filter = i), this.isDirty("cursorOverStyle") && (e.cursorOverStyle = this.get("cursorOverStyle")), this.isDirty("hoverOnFocus") && (this.get("hoverOnFocus") ? this._focusDp = new l.MultiDisposer([t.on("focus", (() => { this.showTooltip() })), t.on("blur", (() => { this.hideTooltip() }))]) : this._focusDp && (this._focusDp.dispose(), this._focusDp = void 0)), this.isDirty("focusable") && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this), this.markDirtyAccessibility()), this.isPrivateDirty("focusable") && this.markDirtyAccessibility(), (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) && this.markDirtyAccessibility(), this.isDirty("exportable") && (e.exportable = this.get("exportable")), this.isDirty("interactive")) { const e = this.events; this.get("interactive") && !e.isDisposed() ? this._hoverDp = new l.MultiDisposer([e.on("click", (e => { c.isTouchEvent(e.originalEvent) && (this.getPrivate("touchHovering") || this.setTimeout((() => { this._handleOver(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.showTooltip(), this.setPrivateRaw("touchHovering", !0), this.events.dispatch("pointerover", { type: "pointerover", target: e.target, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated }) }), 10)) })), e.on("globalpointerup", (e => { c.isTouchEvent(e.originalEvent) && this.getPrivate("touchHovering") && (this._handleOut(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.hideTooltip(), this.setPrivateRaw("touchHovering", !1), this.events.dispatch("pointerout", { type: "pointerout", target: e.target, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated })), this._isDown && this._handleUp(e) })), e.on("pointerover", (() => { this._handleOver() })), e.on("pointerout", (() => { this._handleOut() })), e.on("pointerdown", (e => { this._handleDown(e) }))]) : (this._display.interactive = !1, this._hoverDp && (this._hoverDp.dispose(), this._hoverDp = void 0)) } this.isDirty("forceInactive") && (this._display.inactive = this.get("forceInactive", null)), "always" == this.get("showTooltipOn") && this._display.visible && this.showTooltip() } dragStart(e) { this._dragEvent = e, this.events.stopParentDispatch() } dragStop(e) { if (this._dragEvent = void 0, this._dragPoint = void 0, this.events.stopParentDispatch(), this._isDragging) { this._isDragging = !1; const t = "dragstop"; this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated }) } } _handleOver() { this.isHidden() || (this.get("active") && this.states.lookup("hoverActive") ? this.states.applyAnimate("hoverActive") : this.get("disabled") && this.states.lookup("hoverDisabled") ? this.states.applyAnimate("hoverDisabled") : this.states.applyAnimate("hover"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down")) } _handleOut() { this.isHidden() || (this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : (this.states.lookup("hover") || this.states.lookup("hoverActive")) && this.states.applyAnimate("default"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down")) } _handleUp(e) { if (!this.isHidden()) { this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : this.states.lookup("down") && (this.isHover() ? this.states.applyAnimate("hover") : this.states.applyAnimate("default")), this._downPoint = void 0; const t = c.getPointerId(e.originalEvent); delete this._downPoints[t], 0 == m.keys(this._downPoints).length && (this._isDown = !1) } } _hasMoved(e) { const t = c.getPointerId(e.originalEvent), i = this._downPoints[t]; if (i) { const t = Math.abs(i.x - e.point.x), s = Math.abs(i.y - e.point.y); return t > 5 || s > 5 } return !1 } _hasDown() { return m.keys(this._downPoints).length > 0 } _handleDown(e) { const t = this.parent; if (t && !this.get("draggable") && t._handleDown(e), this.get("interactive") && !this.isHidden()) { this.states.lookup("down") && this.states.applyAnimate("down"), this._downPoint = { x: e.point.x, y: e.point.y }, this._isDown = !0; const t = c.getPointerId(e.originalEvent); this._downPoints[t] = { x: e.point.x, y: e.point.y } } } dragMove(e) { let t = this._dragEvent; if (t) { if (t.simulated && !e.simulated) return !0; let i = 0, s = this.parent, a = 1; for (; null != s;)i += s.get("rotation", 0), s = s.parent, s && (a *= s.get("scale", 1)); let r = (e.point.x - t.point.x) / a, n = (e.point.y - t.point.y) / a; const o = this.events; if (t.simulated && !this._isDragging) { this._isDragging = !0, this._dragEvent = e, this._dragPoint = { x: this.x(), y: this.y() }; const t = "dragstart"; o.isEnabled(t) && o.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated }) } if (this._isDragging) { let t = this._dragPoint; this.set("x", t.x + r * p.cos(i) + n * p.sin(i)), this.set("y", t.y + n * p.cos(i) - r * p.sin(i)); const s = "dragged"; o.isEnabled(s) && o.dispatch(s, { type: s, target: this, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated }) } else if (Math.hypot(r, n) > 5) { this._isDragging = !0, this._dragEvent = e, this._dragPoint = { x: this.x(), y: this.y() }; const t = "dragstart"; o.isEnabled(t) && o.dispatch(t, { type: t, target: this, originalEvent: e.originalEvent, point: e.point, simulated: e.simulated }) } } } _updateSize() { } _getBounds() { this._localBounds = this._display.getLocalBounds() } depth() { let e = this.parent, t = 0; for (; ;) { if (!e) return t; ++t, e = e.parent } } markDirtySize() { this._sizeDirty = !0, this.markDirty() } markDirtyBounds() { const e = this._display; if (this.get("isMeasured")) { this._root._addDirtyBounds(this), e.isMeasured = !0, e.invalidateBounds(); const t = this.parent; t && "absolute" != this.get("position") && (null == t.get("width") || null == t.get("height") || t.get("layout")) && t.markDirtyBounds(), this.get("focusable") && this.isFocus() && this.markDirtyAccessibility() } } markDirtyAccessibility() { this._root._invalidateAccessibility(this) } markDirtyLayer() { this._display.markDirtyLayer(!0) } markDirty() { super.markDirty(), this.markDirtyLayer() } _updateBounds() { const e = this._adjustedLocalBounds; let t; if (this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden") ? (this._getBounds(), this._fixMinBounds(this._localBounds), this.updatePivotPoint(), this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds), t = this._adjustedLocalBounds) : (t = { left: 0, right: 0, top: 0, bottom: 0 }, this._localBounds = t, this._adjustedLocalBounds = t), !e || e.left !== t.left || e.top !== t.top || e.right !== t.right || e.bottom !== t.bottom) { const e = "boundschanged"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), this.parent && (this.parent.markDirty(), this.parent.markDirtyBounds()), this.getPrivate("showingTooltip") && this.showTooltip() } } _fixMinBounds(e) { let t = this.get("minWidth", this.getPrivate("minWidth")), i = this.get("minHeight", this.getPrivate("minHeight")); d.isNumber(t) && e.right - e.left < t && (e.right = e.left + t), d.isNumber(i) && e.bottom - e.top < i && (e.bottom = e.top + i); let s = this.getPrivate("width"), a = this.getPrivate("height"); d.isNumber(s) && (s > 0 ? e.right = e.left + s : e.left = e.right + s), d.isNumber(a) && (a > 0 ? e.bottom = e.top + a : e.top = e.bottom + a) } _removeParent(e) { e && (e.children.removeValue(this), u.removeFirst(e._percentageSizeChildren, this), u.removeFirst(e._percentagePositionChildren, this)) } _clearDirty() { super._clearDirty(), this._sizeDirty = !1, this._statesHandled = !1 } hover() { this.isDisposed() || (this.showTooltip(), this._handleOver()) } unhover() { this.isDisposed() || (this.hideTooltip(), this._handleOut()) } showTooltip(e) { if (!this.isDisposed()) { const t = this.getTooltip(), i = this.get("tooltipText"), s = this.get("tooltipHTML"); if ((i || s) && t) { const a = this.get("tooltipPosition"), r = this.getPrivate("tooltipTarget", this); "fixed" != a && e || (this._display._setMatrix(), e = this.toGlobal(r._getTooltipPoint())), t.set("pointTo", e), t.set("tooltipTarget", r), t.get("x") || t.set("x", e.x), t.get("y") || t.set("y", e.y), i && t.label.set("text", i), s && t.label.set("html", s); const n = this.dataItem; if (n && t.label._setDataItem(n), "always" == this.get("showTooltipOn") && (e.x < 0 || e.x > this._root.width() || e.y < 0 || e.y > this._root.height())) return void this.hideTooltip(); t.label.text.markDirtyText(); const o = t.show(); return this.setPrivateRaw("showingTooltip", !0), o } } } hideTooltip() { const e = this.getTooltip(); if (e && (e.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == e)) { let t = e.get("keepTargetHover") && 0 == e.get("stateAnimationDuration", 0) ? 400 : void 0; const i = e.hide(t); return this.setPrivateRaw("showingTooltip", !1), i } } _getTooltipPoint() { const e = this._localBounds; if (e) { let t = 0, i = 0; return this.get("isMeasured") ? (t = e.left + c.relativeToValue(this.get("tooltipX", 0), e.right - e.left), i = e.top + c.relativeToValue(this.get("tooltipY", 0), e.bottom - e.top)) : (t = c.relativeToValue(this.get("tooltipX", 0), this.width()), i = c.relativeToValue(this.get("tooltipY", 0), this.height())), { x: t, y: i } } return { x: 0, y: 0 } } getTooltip() { let e = this.get("tooltip"); if (e) return e; { let e = this.parent; if (e) return e.getTooltip() } } _updatePosition() { const e = this.parent; let t = this.get("dx", 0), i = this.get("dy", 0), s = this.get("x"), a = this.getPrivate("x"), r = 0, o = 0; const l = this.get("position"); s instanceof n.Percent && (s = e ? e.innerWidth() * s.value + e.get("paddingLeft", 0) : 0), d.isNumber(s) ? r = s + t : null != a ? r = a : e && "relative" == l && (r = e.get("paddingLeft", 0) + t); let h = this.get("y"), c = this.getPrivate("y"); h instanceof n.Percent && (h = e ? e.innerHeight() * h.value + e.get("paddingTop", 0) : 0), d.isNumber(h) ? o = h + i : null != c ? o = c : e && "relative" == l && (o = e.get("paddingTop", 0) + i); const u = this._display; if (u.x != r || u.y != o) { u.invalidateBounds(), u.x = r, u.y = o; const e = "positionchanged"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }) } this.getPrivate("showingTooltip") && this.showTooltip() } x() { let e = this.get("x"), t = this.getPrivate("x"); const i = this.parent; return i ? e instanceof n.Percent ? c.relativeToValue(e, i.innerWidth()) + i.get("paddingLeft", 0) : d.isNumber(e) ? e : null != t ? t : i.get("paddingLeft", this._display.x) : this._display.x } y() { let e = this.getPrivate("y"); if (null != e) return e; let t = this.get("y"); const i = this.parent; return i ? t instanceof n.Percent ? c.relativeToValue(t, i.innerHeight()) + i.get("paddingTop", 0) : d.isNumber(t) ? t : null != e ? e : i.get("paddingTop", this._display.y) : this._display.y } _dispose() { super._dispose(), this._display.dispose(), this._removeTemplateField(), this._removeParent(this.parent), this._root._removeFocusElement(this); const e = this.get("tooltip"); e && e.dispose(), this.markDirty() } adjustedLocalBounds() { return this._fixMinBounds(this._adjustedLocalBounds), this._adjustedLocalBounds } localBounds() { return this._localBounds } bounds() { const e = this._adjustedLocalBounds, t = this.x(), i = this.y(); return { left: e.left + t, right: e.right + t, top: e.top + i, bottom: e.bottom + i } } globalBounds() { const e = this.localBounds(), t = this.toGlobal({ x: e.left, y: e.top }), i = this.toGlobal({ x: e.right, y: e.top }), s = this.toGlobal({ x: e.right, y: e.bottom }), a = this.toGlobal({ x: e.left, y: e.bottom }); return { left: Math.min(t.x, i.x, s.x, a.x), top: Math.min(t.y, i.y, s.y, a.y), right: Math.max(t.x, i.x, s.x, a.x), bottom: Math.max(t.y, i.y, s.y, a.y) } } _onShow(e) { } _onHide(e) { } appear(e, t) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { return yield this.hide(0), t ? new Promise(((i, s) => { this.setTimeout((() => { i(this.show(e)) }), t) })) : this.show(e) })) } show(e) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { if (!this._isShowing) { this._isHidden = !1, this._isShowing = !0, this._isHiding = !1, this.states.lookup("default").get("visible") && this.set("visible", !0), this._onShow(e); const t = this.states.applyAnimate("default", e); yield (0, h.waitForAnimations)(t), this._isShowing = !1 } })) } hide(e) { return (0, s.__awaiter)(this, void 0, void 0, (function* () { if (!this._isHiding && !this._isHidden) { this._isHiding = !0, this._isShowing = !1; let t = this.states.lookup("hidden"); t || (t = this.states.create("hidden", { opacity: 0, visible: !1 })), this._isHidden = !0, this._onHide(e); const i = this.states.applyAnimate("hidden", e); yield (0, h.waitForAnimations)(i), this._isHiding = !1 } })) } isHidden() { return this._isHidden } isShowing() { return this._isShowing } isHiding() { return this._isHiding } isHover() { return this._display.hovering() } isFocus() { return this._root.focused(this) } isDragging() { return this._isDragging } isVisible() { return !(!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden")) } isVisibleDeep() { return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible() } compositeOpacity() { const e = this.get("opacity", 1); return this._parent ? this._parent.compositeOpacity() * e : e } compositeScale() { const e = this.get("scale", 1); return this._parent ? this._parent.compositeScale() * e : e } compositeRotation() { const e = this.get("rotation", 0); return this._parent ? this._parent.compositeRotation() + e : e } width() { let e = this.get("width"), t = this.get("maxWidth", this.getPrivate("maxWidth")), i = this.get("minWidth", this.getPrivate("minWidth")), s = this.getPrivate("width"), a = 0; if (d.isNumber(s)) a = s; else if (null == e) this._adjustedLocalBounds && (a = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left); else if (e instanceof n.Percent) { const t = this.parent; a = t ? t.innerWidth() * e.value : this._root.width() * e.value } else d.isNumber(e) && (a = e); return d.isNumber(i) && (a = Math.max(i, a)), d.isNumber(t) && (a = Math.min(t, a)), a } maxWidth() { let e = this.get("maxWidth", this.getPrivate("maxWidth")); if (d.isNumber(e)) return e; { let e = this.get("width"); if (d.isNumber(e)) return e } const t = this.parent; return t ? t.innerWidth() : this._root.width() } maxHeight() { let e = this.get("maxHeight", this.getPrivate("maxHeight")); if (d.isNumber(e)) return e; { let e = this.get("height"); if (d.isNumber(e)) return e } const t = this.parent; return t ? t.innerHeight() : this._root.height() } height() { let e = this.get("height"), t = this.get("maxHeight", this.getPrivate("maxHeight")), i = this.get("minHeight", this.getPrivate("minHeight")), s = this.getPrivate("height"), a = 0; if (d.isNumber(s)) a = s; else if (null == e) this._adjustedLocalBounds && (a = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top); else if (e instanceof n.Percent) { const t = this.parent; a = t ? t.innerHeight() * e.value : this._root.height() * e.value } else d.isNumber(e) && (a = e); return d.isNumber(i) && (a = Math.max(i, a)), d.isNumber(t) && (a = Math.min(t, a)), a } _findStaticTemplate(e) { return this._templateField && e(this._templateField) ? this._templateField : super._findStaticTemplate(e) } _walkParents(e) { this._parent && this._walkParent(e) } _walkParent(e) { this._parent && this._parent._walkParent(e), e(this) } get parent() { return this._parent } _setParent(e, t = !1) { const i = this._parent; e !== i && (this.markDirtyBounds(), e.markDirty(), this._parent = e, t && (this._removeParent(i), e && (this._addPercentageSizeChildren(), this._addPercentagePositionChildren())), this.markDirtyPosition(), this._applyThemes()) } getNumberFormatter() { return this.get("numberFormatter", this._root.numberFormatter) } getDateFormatter() { return this.get("dateFormatter", this._root.dateFormatter) } getDurationFormatter() { return this.get("durationFormatter", this._root.durationFormatter) } toGlobal(e) { return this._display.toGlobal(e) } toLocal(e) { return this._display.toLocal(e) } _getDownPoint() { const e = this._getDownPointId(); if (e) return this._downPoints[e] } _getDownPointId() { if (this._downPoints) return m.keysOrdered(this._downPoints, ((e, t) => e > t ? 1 : e < t ? -1 : 0))[0] } toFront() { const e = this.parent; e && e.children.moveValue(this, e.children.length - 1) } toBack() { const e = this.parent; e && e.children.moveValue(this, 0) } } Object.defineProperty(b, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Sprite" }), Object.defineProperty(b, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: a.Entity.classNames.concat([b.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Text.js": (e, t, i) => { i.r(t), i.d(t, { Text: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"); class l extends s.Sprite { constructor() { super(...arguments), Object.defineProperty(this, "textStyle", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeTextStyle() }), Object.defineProperty(this, "_display", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeText("", this.textStyle) }), Object.defineProperty(this, "_textStyles", { enumerable: !0, configurable: !0, writable: !0, value: ["textAlign", "fontFamily", "fontSize", "fontStyle", "fontWeight", "fontStyle", "fontVariant", "textDecoration", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowOpacity", "lineHeight", "baselineRatio", "direction", "textBaseline", "oversizedBehavior", "breakWords", "ellipsis", "minScale", "maxChars"] }), Object.defineProperty(this, "_originalScale", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _updateBounds() { if (this.get("text")) { super._updateBounds(); let e = this.get("fillGradient"); e && (this._display.style.fill = e.getFill(this)) } else { let e = { left: 0, right: 0, top: 0, bottom: 0 }; this._adjustedLocalBounds = e } } _changed() { super._changed(), this._display.clear(); let e = this.textStyle; if (this.isDirty("opacity")) { let e = this.get("opacity", 1); this._display.alpha = e } if ((this.isDirty("text") || this.isDirty("populateText")) && (this._display.text = this._getText(), this.markDirtyBounds(), "tooltip" == this.get("role") && this._root.updateTooltip(this)), this.isPrivateDirty("tooltipElement")) { this.getPrivate("tooltipElement") && this._disposers.push(new o.Disposer((() => { this._root._removeTooltipElement(this) }))) } if (this.isDirty("width") && (e.wordWrapWidth = this.width(), this.markDirtyBounds()), this.isDirty("oversizedBehavior") && (e.oversizedBehavior = this.get("oversizedBehavior", "none"), this.markDirtyBounds()), this.isDirty("breakWords") && (e.breakWords = this.get("breakWords", !1), this.markDirtyBounds()), this.isDirty("ellipsis") && (e.ellipsis = this.get("ellipsis"), this.markDirtyBounds()), this.isDirty("ignoreFormatting") && (e.ignoreFormatting = this.get("ignoreFormatting", !1), this.markDirtyBounds()), this.isDirty("minScale") && (e.minScale = this.get("minScale", 0), this.markDirtyBounds()), this.isDirty("fill") || this.isDirty("fillGradient")) { const t = this.get("fill"), i = this.get("fillGradient"), s = this.get("fillOpacity"); if (i) { if (t) { const e = i.get("stops", []); e.length && r.each(e, (e => { e.color && !e.colorInherited || !t || (e.color = t, e.colorInherited = !0), (null == e.opacity || e.opacityInherited) && (e.opacity = s, e.opacityInherited = !0) })) } e.fill = i.getFill(this) } else t && (e.fill = t) } if (this.isDirty("fillOpacity")) { let t = this.get("fillOpacity", 1); t && (e.fillOpacity = t) } (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) && (e.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth")), this.markDirtyBounds()), (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) && (e.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight")), this.markDirtyBounds()), r.each(this._textStyles, (t => { this._dirty[t] && (e[t] = this.get(t), this.markDirtyBounds()) })), e.fontSize = this.get("fontSize"), e.fontFamily = this.get("fontFamily"), this._display.style = e, this.isDirty("role") && "tooltip" == this.get("role") && this._root.updateTooltip(this) } _getText() { let e = this.get("text", ""); return this.get("maxChars") && (e = n.truncateTextWithEllipsis(e, this.get("maxChars", 1e8), this.get("breakWords"), this.get("ellipsis"))), this.get("populateText") ? (0, a.populateString)(this, e) : e } _getAccessibleText() { const e = this.get("ariaLabel"); return void 0 !== e ? this.get("populateText") ? (0, a.populateString)(this, e) : e : this._getText() } markDirtyText() { this._display.text = this._getText(), "tooltip" == this.get("role") && this._root.updateTooltip(this), this.markDirtyBounds(), this.markDirty() } _setDataItem(e) { super._setDataItem(e), this.get("populateText") && this.markDirtyText() } getNumberFormatter() { return this.parent ? this.parent.getNumberFormatter() : super.getNumberFormatter() } getDateFormatter() { return this.parent ? this.parent.getDateFormatter() : super.getDateFormatter() } getDurationFormatter() { return this.parent ? this.parent.getDurationFormatter() : super.getDurationFormatter() } } Object.defineProperty(l, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Text" }), Object.defineProperty(l, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Sprite.classNames.concat([l.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Tick.js": (e, t, i) => { i.r(t), i.d(t, { Tick: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Line.js"); class a extends s.Line { } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Tick" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Line.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/Tooltip.js": (e, t, i) => { i.r(t), i.d(t, { Tooltip: () => d }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Label.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/PointedRectangle.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Container.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class d extends n.Container { constructor(e, t, i, s = []) { super(e, t, i, s), Object.defineProperty(this, "_fx", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_fy", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_label", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_fillDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_strokeDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_labelDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_w", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_h", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_keepHoverDp", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_htmlContentHovered", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } _afterNew() { this._settings.themeTags = u.mergeTags(this._settings.themeTags, ["tooltip"]), super._afterNew(); this._setDefaultFn("background", (() => r.PointedRectangle.new(this._root, {}))).set("themeTags", ["tooltip", "background"]), this._label = this.children.push(a.Label.new(this._root, {})), this._disposers.push(this._label.events.on("boundschanged", (() => { this._updateBackground() }))), this._disposers.push(this.on("bounds", (() => { this._updateBackground() }))), this._updateTextColor(), this._root.tooltipContainer.children.push(this), this.hide(0), this._disposers.push(this.label.onPrivate("htmlElement", (e => { e && (this._disposers.push(u.addEventListener(e, "pointerover", (e => { this._htmlContentHovered = !0 }))), this._disposers.push(u.addEventListener(e, "pointerout", (e => { this._htmlContentHovered = !1 })))) }))), this.on("visible", (e => { this._handleReaderAnnouncement() })), this.label.events.on("dataitemchanged", (e => { this._handleReaderAnnouncement() })), this._root._tooltips.push(this) } _handleReaderAnnouncement() { this.get("readerAnnounce") && this.isVisibleDeep() && this._root.readerAlert(this.label.getAccessibleText()) } get label() { return this._label } dispose() { super.dispose(), c.remove(this._root._tooltips, this) } _updateChildren() { super._updateChildren(), (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && this.get("background")._markDirtyKey("width"); null != this.get("labelText") && this.label.set("text", this.get("labelText")); null != this.get("labelHTML") && this.label.set("html", this.get("labelHTML")); null != this.get("labelAriaLabel") && this.label.set("ariaLabel", this.get("labelAriaLabel")) } _changed() { if (super._changed(), (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) && this._updateBackground(), this.isDirty("tooltipTarget") && this.updateBackgroundColor(), this.isDirty("keepTargetHover")) { if (this.get("keepTargetHover")) { const e = this.get("background"); this._keepHoverDp = new s.MultiDisposer([e.events.on("pointerover", (e => { let t = this.get("tooltipTarget"); t && (t.parent && t.parent.getPrivate("tooltipTarget") == t && (t = t.parent), t.hover()) })), e.events.on("pointerout", (e => { let t = this.get("tooltipTarget"); t && (t.parent && t.parent.getPrivate("tooltipTarget") == t && (t = t.parent), this._htmlContentHovered || t.unhover()) }))]), this.label.onPrivate("htmlElement", (t => { this._keepHoverDp && t && this._keepHoverDp.disposers.push(u.addEventListener(t, "pointerleave", (t => { const i = this.root._renderer.getEvent(t); e.events.dispatch("pointerout", { type: "pointerout", originalEvent: i.event, point: i.point, simulated: !1, target: e }) }))) })) } else this._keepHoverDp && (this._keepHoverDp.dispose(), this._keepHoverDp = void 0) } } _onShow() { super._onShow(), this.updateBackgroundColor() } updateBackgroundColor() { let e = this.get("tooltipTarget"); const t = this.get("background"); let i, s; e && t && (i = e.get("fill"), s = e.get("stroke"), null == i && (i = s), this.get("getFillFromSprite") && (this._fillDp && this._fillDp.dispose(), null != i && t.set("fill", i), this._fillDp = e.on("fill", (e => { null != e && (t.set("fill", e), this._updateTextColor(e)) })), this._disposers.push(this._fillDp)), this.get("getStrokeFromSprite") && (this._strokeDp && this._strokeDp.dispose(), null != i && t.set("stroke", i), this._strokeDp = e.on("fill", (e => { null != e && t.set("stroke", e) })), this._disposers.push(this._strokeDp)), this.get("getLabelFillFromSprite") && (this._labelDp && this._labelDp.dispose(), null != i && this.label.set("fill", i), this._labelDp = e.on("fill", (e => { null != e && this.label.set("fill", e) })), this._disposers.push(this._labelDp))), this._updateTextColor(i) } _updateTextColor(e) { this.get("autoTextColor") && (null == e && (e = this.get("background").get("fill")), null == e && (e = this._root.interfaceColors.get("background")), e instanceof l.Color && this.label.set("fill", l.Color.alternative(e, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text")))) } _setDataItem(e) { super._setDataItem(e), this.label._setDataItem(e) } _updateBackground() { super.updateBackground(); const e = this._root.container; if (e) { let t = .5, i = .5, s = this.get("centerX"); s instanceof o.Percent && (t = s.value); let a = this.get("centerY"); a instanceof o.Percent && (i = a.value); let n = e.width(), l = e.height(), c = this.parent, u = 0, d = 0; if (c) { u = c.x(), d = c.y(); const e = c.get("layerMargin"); e && (u += e.left || 0, d += e.top || 0, n += (e.left || 0) + (e.right || 0), l += (e.top || 0) + (e.bottom || 0)) } const m = this.get("bounds", { left: -u, top: -d, right: n - u, bottom: l - d }); this._updateBounds(); let p = this.width(), g = this.height(); 0 === p && (p = this._w), 0 === g && (g = this._h); let b = this.get("pointTo", { x: n / 2, y: l / 2 }), _ = b.x, f = b.y, y = this.get("pointerOrientation"), v = this.get("background"), x = 0, w = 0, P = 0; v instanceof r.PointedRectangle && (x = v.get("pointerLength", 0), w = v.get("strokeWidth", 0) / 2, P = w, v.set("width", p), v.set("height", g)); let T = 0, D = 0, k = m.right - m.left, j = m.bottom - m.top; "horizontal" == y || "left" == y || "right" == y ? (w = 0, "horizontal" == y ? _ > m.left + k / 2 ? (_ -= p * (1 - t) + x, P *= -1) : _ += p * t + x : "left" == y ? _ += p * (1 - t) + x : (_ -= p * t + x, P *= -1)) : (P = 0, "vertical" == y ? f > m.top + g / 2 + x ? f -= g * (1 - i) + x : (f += g * i + x, w *= -1) : "down" == y ? f -= g * (1 - i) + x : (f += g * i + x, w *= -1)), _ = h.fitToRange(_, m.left + p * t, m.left + k - p * (1 - t)) + P, f = h.fitToRange(f, m.top + g * i, m.top + j - g * (1 - i)) - w, T = b.x - _ + p * t + P, D = b.y - f + g * i - w, this._fx = _, this._fy = f; const C = this.get("animationDuration", 0); if (C > 0 && this.get("visible") && this.get("opacity") > .1) { const e = this.get("animationEasing"); this.animate({ key: "x", to: _, duration: C, easing: e }), this.animate({ key: "y", to: f, duration: C, easing: e }) } else this.set("x", _), this.set("y", f); v instanceof r.PointedRectangle && (v.set("pointerX", T), v.set("pointerY", D)), p > 0 && (this._w = p), g > 0 && (this._h = g) } } } Object.defineProperty(d, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Tooltip" }), Object.defineProperty(d, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: n.Container.classNames.concat([d.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/VerticalLayout.js": (e, t, i) => { i.r(t), i.d(t, { VerticalLayout: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Layout.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"); class n extends s.Layout { updateContainer(e) { let t = e.get("paddingTop", 0), i = e.innerHeight(), n = 0; (0, s.eachChildren)(e, (e => { if (e.isVisible() && "relative" == e.get("position")) { let t = e.get("height"); if (t instanceof r.Percent) { n += t.value; let s = i * t.value, a = e.get("minHeight", e.getPrivate("minHeight", -1 / 0)); a > s && (i -= a, n -= t.value); let r = e.get("maxHeight", e.getPrivate("maxHeight", 1 / 0)); s > r && (i -= r, n -= t.value) } else a.isNumber(t) || (t = e.height()), i -= t + e.get("marginTop", 0) + e.get("marginBottom", 0) } })), (i <= 0 || i == 1 / 0) && (i = .1), (0, s.eachChildren)(e, (e => { if (e.isVisible() && "relative" == e.get("position")) { let t = e.get("height"); if (t instanceof r.Percent) { let s = i * t.value / n - e.get("marginTop", 0) - e.get("marginBottom", 0), a = e.get("minHeight", e.getPrivate("minHeight", -1 / 0)), r = e.get("maxHeight", e.getPrivate("maxHeight", 1 / 0)); s = Math.min(Math.max(a, s), r), e.setPrivate("height", s) } else e._prevSettings.height instanceof r.Percent && e.setPrivate("height", void 0) } })); let o = t; (0, s.eachChildren)(e, (e => { if ("relative" == e.get("position")) if (e.isVisible()) { let t = e.adjustedLocalBounds(), i = e.get("marginTop", 0), s = t.top, a = t.bottom, r = e.get("maxHeight"); r && a - s > r && (a = s + r); let n = e.get("marginBottom", 0), l = o + i - s; e.setPrivate("y", l), o = l + a + n } else e.setPrivate("y", void 0) })) } } Object.defineProperty(n, "className", { enumerable: !0, configurable: !0, writable: !0, value: "VerticalLayout" }), Object.defineProperty(n, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Layout.classNames.concat([n.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/CanvasRenderer.js": (e, t, i) => { i.r(t), i.d(t, { CanvasContainer: () => j, CanvasDisplayObject: () => k, CanvasGraphics: () => Z, CanvasImage: () => Q, CanvasLayer: () => se, CanvasPivot: () => D, CanvasRadialText: () => $, CanvasRenderer: () => te, CanvasRendererEvent: () => ee, CanvasText: () => q, CanvasTextStyle: () => J }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"), p = i("./node_modules/svg-arc-to-cubic-bezier/modules/index.js"); function g(e, t, i) { if (t !== i) throw new Error("Required " + i + " arguments for " + e + " but got " + t) } function b(e, t, i) { if (t < i) throw new Error("Required at least " + i + " arguments for " + e + " but got " + t) } function _(e, t, i) { if (b(e, t, i), t % i != 0) throw new Error("Arguments for " + e + " must be in pairs of " + i) } function f(e) { for (let t = 0; t < e.length; t += 7) { let i = t + 3, s = e[i]; if (s.length > 1) { const t = /^([01])([01])(.*)$/.exec(s); null !== t && (e.splice(i, 0, t[1]), ++i, e.splice(i, 0, t[2]), ++i, t[3].length > 0 ? e[i] = t[3] : e.splice(i, 1)) } if (++i, s = e[i], s.length > 1) { const t = /^([01])(.+)$/.exec(s); null !== t && (e.splice(i, 0, t[1]), ++i, e[i] = t[2]) } } } function y(e) { if (0 === e || 1 === e) return e; throw new Error("Flag must be 0 or 1") } function v(e, t) { for (; (!e.interactive || t(e)) && e._parent;)e = e._parent } function x(e, t, i) { return h.addEventListener(e, h.getRendererEvent(t), (e => { const t = h.getEventTarget(e); let s = e.touches; s ? (0 == s.length && (s = e.changedTouches), i(c.copy(s), t)) : i([e], t) })) } function w(e) { const t = document.createElement("canvas"); t.width = 1, t.height = 1; const i = t.getContext("2d", { willReadFrequently: !0 }); i.drawImage(e, 0, 0, 1, 1); try { return i.getImageData(0, 0, 1, 1), !1 } catch (t) { return console.warn('Image "' + e.src + '" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors'), !0 } } function P(e) { e.width = 0, e.height = 0, e.style.width = "0px", e.style.height = "0px" } function T(e) { return Math.floor(e) + .5 } class D { constructor() { Object.defineProperty(this, "_x", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_y", { enumerable: !0, configurable: !0, writable: !0, value: 0 }) } get x() { return this._x } get y() { return this._y } set x(e) { this._x = e } set y(e) { this._y = e } } class k extends o.DisposerClass { constructor(e) { super(), Object.defineProperty(this, "_layer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "mask", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "visible", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "exportable", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "interactive", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "inactive", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "wheelable", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "cancelTouch", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "isMeasured", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "buttonMode", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "alpha", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "compoundAlpha", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "angle", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "scale", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "crisp", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "pivot", { enumerable: !0, configurable: !0, writable: !0, value: new D }), Object.defineProperty(this, "filter", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "cursorOverStyle", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_replacedCursorStyle", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_localMatrix", { enumerable: !0, configurable: !0, writable: !0, value: new r.Matrix }), Object.defineProperty(this, "_matrix", { enumerable: !0, configurable: !0, writable: !0, value: new r.Matrix }), Object.defineProperty(this, "_uMatrix", { enumerable: !0, configurable: !0, writable: !0, value: new r.Matrix }), Object.defineProperty(this, "_renderer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_parent", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_localBounds", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_bounds", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_colorId", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._renderer = e } subStatus(e) { return { inactive: null == this.inactive ? e.inactive : this.inactive, layer: this._layer || e.layer } } _dispose() { this._renderer._removeObject(this), this.getLayer().dirty = !0 } getCanvas() { return this.getLayer().view } getLayer() { let e = this; for (; ;) { if (e._layer) return e._layer; if (!e._parent) return this._renderer.defaultLayer; e = e._parent } } setLayer(e, t) { if (null == e) this._layer = void 0; else { const i = !0; this._layer = this._renderer.getLayer(e, i), this._layer.visible = i, this._layer.margin = t, t && h.setInteractive(this._layer.view, !1), this._renderer._ghostLayer.setMargin(this._renderer.layers), this._parent && this._parent.registerChildLayer(this._layer), this._layer.dirty = !0, this._renderer.resizeLayer(this._layer), this._renderer.resizeGhost() } } markDirtyLayer() { this.getLayer().dirty = !0 } clear() { this.invalidateBounds() } invalidateBounds() { this._localBounds = void 0 } _addBounds(e) { } _getColorId() { return void 0 === this._colorId && (this._colorId = this._renderer.paintId(this)), this._colorId } _isInteractive(e) { return !e.inactive && (this.interactive || this._renderer._forceInteractive > 0) } _isInteractiveMask(e) { return this._isInteractive(e) } contains(e) { for (; ;) { if (e === this) return !0; if (!e._parent) return !1; e = e._parent } } toGlobal(e) { return this._matrix.apply(e) } toLocal(e) { return this._matrix.applyInverse(e) } getLocalMatrix() { return this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._uMatrix } getLocalBounds() { if (!this._localBounds) { const e = 1e7; this._localBounds = { left: e, top: e, right: -e, bottom: -e }, this._addBounds(this._localBounds) } return this._localBounds } getAdjustedBounds(e) { this._setMatrix(); const t = this.getLocalMatrix(), i = t.apply({ x: e.left, y: e.top }), s = t.apply({ x: e.right, y: e.top }), a = t.apply({ x: e.right, y: e.bottom }), r = t.apply({ x: e.left, y: e.bottom }); return { left: Math.min(i.x, s.x, a.x, r.x), top: Math.min(i.y, s.y, a.y, r.y), right: Math.max(i.x, s.x, a.x, r.x), bottom: Math.max(i.y, s.y, a.y, r.y) } } on(e, t, i) { return this.interactive ? this._renderer._addEvent(this, e, t, i) : new o.Disposer((() => { })) } _setMatrix() { this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._matrix.copyFrom(this._localMatrix), this._parent && this._matrix.prepend(this._parent._matrix) } _transform(e, t) { const i = this._matrix; let s = i.tx * t, a = i.ty * t; this.crisp && (s = T(s), a = T(a)), e.setTransform(i.a * t, i.b * t, i.c * t, i.d * t, s, a) } _transformMargin(e, t, i) { const s = this._matrix; e.setTransform(s.a * t, s.b * t, s.c * t, s.d * t, (s.tx + i.left) * t, (s.ty + i.top) * t) } _transformLayer(e, t, i) { i.margin ? this._transformMargin(e, i.scale || t, i.margin) : this._transform(e, i.scale || t) } render(e) { if (this.visible && (!1 !== this.exportable || !this._renderer._omitTainted)) { this._setMatrix(); const t = this.subStatus(e), i = this._renderer.resolution, s = this._renderer.layers, a = this._renderer._ghostLayer, r = a.context, n = this.mask; n && n._setMatrix(), c.each(s, (e => { if (e) { const t = e.context; t.save(), n && (n._transformLayer(t, i, e), n._runPath(t), t.clip()), t.globalAlpha = this.compoundAlpha * this.alpha, this._transformLayer(t, i, e), this.filter && (t.filter = this.filter) } })), r.save(), n && this._isInteractiveMask(t) && (n._transformMargin(r, i, a.margin), n._runPath(r), r.clip()), this._transformMargin(r, i, a.margin), this._render(t), r.restore(), c.each(s, (e => { e && e.context.restore() })) } } _render(e) { !1 === this.exportable && (e.layer.tainted = !0) } hovering() { return this._renderer._hovering.has(this) } dragging() { return this._renderer._dragging.some((e => e.value === this)) } shouldCancelTouch() { const e = this._renderer; return !(e.tapToActivate && !e._touchActive) && (!!this.cancelTouch || !!this._parent && this._parent.shouldCancelTouch()) } } class j extends k { constructor() { super(...arguments), Object.defineProperty(this, "interactiveChildren", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_childLayers", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_children", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } _isInteractiveMask(e) { return this.interactiveChildren || super._isInteractiveMask(e) } addChild(e) { e._parent = this, this._children.push(e), e._layer && this.registerChildLayer(e._layer) } addChildAt(e, t) { e._parent = this, this._children.splice(t, 0, e), e._layer && this.registerChildLayer(e._layer) } removeChild(e) { e._parent = void 0, c.removeFirst(this._children, e) } _render(e) { super._render(e); const t = this._renderer; this.interactive && this.interactiveChildren && ++t._forceInteractive, c.each(this._children, (t => { t.compoundAlpha = this.compoundAlpha * this.alpha, t.render(e) })), this.interactive && this.interactiveChildren && --t._forceInteractive } registerChildLayer(e) { this._childLayers || (this._childLayers = []), c.pushOne(this._childLayers, e), this._parent && this._parent.registerChildLayer(e) } markDirtyLayer(e = !1) { super.markDirtyLayer(), e && this._childLayers && c.each(this._childLayers, (e => e.dirty = !0)) } _dispose() { super._dispose(), this._childLayers && c.each(this._childLayers, (e => { e.dirty = !0 })) } } function C(e, t) { e.left = Math.min(e.left, t.x), e.top = Math.min(e.top, t.y), e.right = Math.max(e.right, t.x), e.bottom = Math.max(e.bottom, t.y) } class O { colorize(e, t) { } colorizeGhost(e, t) { this.colorize(e, t) } path(e) { } pathGhost(e) { this.path(e) } addBounds(e) { } } class S extends O { colorize(e, t) { e.beginPath() } } class A extends O { constructor(e) { super(), Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, writable: !0, value: e }) } colorize(e, t) { e.fillStyle = void 0 !== t ? t : this.color } } class M extends O { constructor(e) { super(), Object.defineProperty(this, "clearShadow", { enumerable: !0, configurable: !0, writable: !0, value: e }) } colorize(e, t) { e.fill(), this.clearShadow && (e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0) } } class L extends O { colorize(e, t) { e.stroke() } } class E extends O { constructor(e, t, i) { super(), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "lineJoin", { enumerable: !0, configurable: !0, writable: !0, value: i }) } colorize(e, t) { e.strokeStyle = void 0 !== t ? t : this.color, e.lineWidth = this.width, this.lineJoin && (e.lineJoin = this.lineJoin) } } class R extends O { constructor(e) { super(), Object.defineProperty(this, "dash", { enumerable: !0, configurable: !0, writable: !0, value: e }) } colorize(e, t) { e.setLineDash(this.dash) } } class I extends O { constructor(e) { super(), Object.defineProperty(this, "dashOffset", { enumerable: !0, configurable: !0, writable: !0, value: e }) } colorize(e, t) { e.lineDashOffset = this.dashOffset } } class B extends O { constructor(e, t, i, s) { super(), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, writable: !0, value: s }) } path(e) { e.rect(this.x, this.y, this.width, this.height) } addBounds(e) { const t = this.x, i = this.y, s = t + this.width, a = i + this.height; C(e, { x: t, y: i }), C(e, { x: s, y: i }), C(e, { x: t, y: a }), C(e, { x: s, y: a }) } } class F extends O { constructor(e, t, i) { super(), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "radius", { enumerable: !0, configurable: !0, writable: !0, value: i }) } path(e) { e.moveTo(this.x + this.radius, this.y), e.arc(this.x, this.y, this.radius, 0, 2 * Math.PI) } addBounds(e) { C(e, { x: this.x - this.radius, y: this.y - this.radius }), C(e, { x: this.x + this.radius, y: this.y + this.radius }) } } class N extends O { constructor(e, t, i, s) { super(), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "radiusX", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "radiusY", { enumerable: !0, configurable: !0, writable: !0, value: s }) } path(e) { e.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, 2 * Math.PI) } addBounds(e) { C(e, { x: this.x - this.radiusX, y: this.y - this.radiusY }), C(e, { x: this.x + this.radiusX, y: this.y + this.radiusY }) } } class Y extends O { constructor(e, t, i, s, a, r) { super(), Object.defineProperty(this, "cx", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "cy", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "radius", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "startAngle", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "endAngle", { enumerable: !0, configurable: !0, writable: !0, value: a }), Object.defineProperty(this, "anticlockwise", { enumerable: !0, configurable: !0, writable: !0, value: r }) } path(e) { this.radius > 0 && e.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise) } addBounds(e) { let t = m.getArcBounds(this.cx, this.cy, this.startAngle * m.DEGREES, this.endAngle * m.DEGREES, this.radius); C(e, { x: t.left, y: t.top }), C(e, { x: t.right, y: t.bottom }) } } class H extends O { constructor(e, t, i, s, a) { super(), Object.defineProperty(this, "x1", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y1", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "x2", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "y2", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "radius", { enumerable: !0, configurable: !0, writable: !0, value: a }) } path(e) { this.radius > 0 && e.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius) } addBounds(e) { } } class X extends O { constructor(e, t) { super(), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: t }) } path(e) { e.lineTo(this.x, this.y) } addBounds(e) { C(e, { x: this.x, y: this.y }) } } class z extends O { constructor(e, t) { super(), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: t }) } path(e) { e.moveTo(this.x, this.y) } addBounds(e) { C(e, { x: this.x, y: this.y }) } } class V extends O { path(e) { e.closePath() } } class U extends O { constructor(e, t, i, s, a, r) { super(), Object.defineProperty(this, "cpX", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "cpY", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "cpX2", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "cpY2", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "toX", { enumerable: !0, configurable: !0, writable: !0, value: a }), Object.defineProperty(this, "toY", { enumerable: !0, configurable: !0, writable: !0, value: r }) } path(e) { e.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY) } addBounds(e) { C(e, { x: this.cpX, y: this.cpY }), C(e, { x: this.cpX2, y: this.cpY2 }), C(e, { x: this.toX, y: this.toY }) } } class G extends O { constructor(e, t, i, s) { super(), Object.defineProperty(this, "cpX", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "cpY", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "toX", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "toY", { enumerable: !0, configurable: !0, writable: !0, value: s }) } path(e) { e.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY) } addBounds(e) { C(e, { x: this.cpX, y: this.cpY }), C(e, { x: this.toX, y: this.toY }) } } class W extends O { constructor(e, t, i, s, a) { super(), Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "blur", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "offsetX", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "offsetY", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "opacity", { enumerable: !0, configurable: !0, writable: !0, value: a }) } colorize(e, t) { this.opacity && (e.fillStyle = this.color), e.shadowColor = this.color, e.shadowBlur = this.blur, e.shadowOffsetX = this.offsetX, e.shadowOffsetY = this.offsetY } colorizeGhost(e, t) { } } class K extends O { constructor(e, t, i, s, a) { super(), Object.defineProperty(this, "image", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, writable: !0, value: a }) } path(e) { e.drawImage(this.image, this.x, this.y, this.width, this.height) } addBounds(e) { C(e, { x: this.x, y: this.y }), C(e, { x: this.width, y: this.height }) } } class Z extends k { constructor() { super(...arguments), Object.defineProperty(this, "_operations", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "blendMode", { enumerable: !0, configurable: !0, writable: !0, value: s.BlendMode.NORMAL }), Object.defineProperty(this, "_hasShadows", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_fillAlpha", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_strokeAlpha", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } clear() { super.clear(), this._operations.length = 0 } _pushOp(e) { this._operations.push(e) } beginFill(e, t = 1) { this._fillAlpha = t, e ? e instanceof a.Color ? this._pushOp(new A(e.toCSS(t))) : (this.isMeasured = !0, this._pushOp(new A(e))) : this._pushOp(new A("rgba(0, 0, 0, " + t + ")")) } endFill() { this._pushOp(new M(this._hasShadows)) } endStroke() { this._pushOp(new L) } beginPath() { this._pushOp(new S) } lineStyle(e = 0, t, i = 1, s) { this._strokeAlpha = i, t ? t instanceof a.Color ? this._pushOp(new E(e, t.toCSS(i), s)) : this._pushOp(new E(e, t, s)) : this._pushOp(new E(e, "rgba(0, 0, 0, " + i + ")", s)) } setLineDash(e) { this._pushOp(new R(e || [])) } setLineDashOffset(e = 0) { this._pushOp(new I(e)) } drawRect(e, t, i, s) { this._pushOp(new B(e, t, i, s)) } drawCircle(e, t, i) { this._pushOp(new F(e, t, i)) } drawEllipse(e, t, i, s) { this._pushOp(new N(e, t, i, s)) } arc(e, t, i, s, a, r = !1) { this._pushOp(new Y(e, t, i, s, a, r)) } arcTo(e, t, i, s, a) { this._pushOp(new H(e, t, i, s, a)) } lineTo(e, t) { this._pushOp(new X(e, t)) } moveTo(e, t) { this._pushOp(new z(e, t)) } bezierCurveTo(e, t, i, s, a, r) { this._pushOp(new U(e, t, i, s, a, r)) } quadraticCurveTo(e, t, i, s) { this._pushOp(new G(e, t, i, s)) } closePath() { this._pushOp(new V) } shadow(e, t = 0, i = 0, s = 0, a) { this._hasShadows = !0, this._pushOp(new W(a ? e.toCSS(a) : e.toCSS(this._fillAlpha || this._strokeAlpha), t, i, s)) } image(e, t, i, s, a) { this._pushOp(new K(e, t, i, s, a)) } svgPath(e) { let t = 0, i = 0, s = null, a = null, r = null, n = null; const o = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g, l = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g; let h; for (; null !== (h = o.exec(e));) { const e = h[1], o = h[2], u = []; for (; null !== (h = l.exec(o));)u.push(h[1]); switch ("S" !== e && "s" !== e && "C" !== e && "c" !== e && (s = null, a = null), "Q" !== e && "q" !== e && "T" !== e && "t" !== e && (r = null, n = null), e) { case "M": _(e, u.length, 2), t = +u[0], i = +u[1], this.moveTo(t, i); for (let e = 2; e < u.length; e += 2)t = +u[e], i = +u[e + 1], this.lineTo(t, i); break; case "m": _(e, u.length, 2), t += +u[0], i += +u[1], this.moveTo(t, i); for (let e = 2; e < u.length; e += 2)t += +u[e], i += +u[e + 1], this.lineTo(t, i); break; case "L": _(e, u.length, 2); for (let e = 0; e < u.length; e += 2)t = +u[e], i = +u[e + 1], this.lineTo(t, i); break; case "l": _(e, u.length, 2); for (let e = 0; e < u.length; e += 2)t += +u[e], i += +u[e + 1], this.lineTo(t, i); break; case "H": b(e, u.length, 1); for (let e = 0; e < u.length; ++e)t = +u[e], this.lineTo(t, i); break; case "h": b(e, u.length, 1); for (let e = 0; e < u.length; ++e)t += +u[e], this.lineTo(t, i); break; case "V": b(e, u.length, 1); for (let e = 0; e < u.length; ++e)i = +u[e], this.lineTo(t, i); break; case "v": b(e, u.length, 1); for (let e = 0; e < u.length; ++e)i += +u[e], this.lineTo(t, i); break; case "C": _(e, u.length, 6); for (let e = 0; e < u.length; e += 6) { const r = +u[e], n = +u[e + 1]; s = +u[e + 2], a = +u[e + 3], t = +u[e + 4], i = +u[e + 5], this.bezierCurveTo(r, n, s, a, t, i) } break; case "c": _(e, u.length, 6); for (let e = 0; e < u.length; e += 6) { const r = +u[e] + t, n = +u[e + 1] + i; s = +u[e + 2] + t, a = +u[e + 3] + i, t += +u[e + 4], i += +u[e + 5], this.bezierCurveTo(r, n, s, a, t, i) } break; case "S": _(e, u.length, 4), null !== s && null !== a || (s = t, a = i); for (let e = 0; e < u.length; e += 4) { const r = 2 * t - s, n = 2 * i - a; s = +u[e], a = +u[e + 1], t = +u[e + 2], i = +u[e + 3], this.bezierCurveTo(r, n, s, a, t, i) } break; case "s": _(e, u.length, 4), null !== s && null !== a || (s = t, a = i); for (let e = 0; e < u.length; e += 4) { const r = 2 * t - s, n = 2 * i - a; s = +u[e] + t, a = +u[e + 1] + i, t += +u[e + 2], i += +u[e + 3], this.bezierCurveTo(r, n, s, a, t, i) } break; case "Q": _(e, u.length, 4); for (let e = 0; e < u.length; e += 4)r = +u[e], n = +u[e + 1], t = +u[e + 2], i = +u[e + 3], this.quadraticCurveTo(r, n, t, i); break; case "q": _(e, u.length, 4); for (let e = 0; e < u.length; e += 4)r = +u[e] + t, n = +u[e + 1] + i, t += +u[e + 2], i += +u[e + 3], this.quadraticCurveTo(r, n, t, i); break; case "T": _(e, u.length, 2), null !== r && null !== n || (r = t, n = i); for (let e = 0; e < u.length; e += 2)r = 2 * t - r, n = 2 * i - n, t = +u[e], i = +u[e + 1], this.quadraticCurveTo(r, n, t, i); break; case "t": _(e, u.length, 2), null !== r && null !== n || (r = t, n = i); for (let e = 0; e < u.length; e += 2)r = 2 * t - r, n = 2 * i - n, t += +u[e], i += +u[e + 1], this.quadraticCurveTo(r, n, t, i); break; case "A": case "a": const o = "a" === e; f(u), _(e, u.length, 7); for (let e = 0; e < u.length; e += 7) { let s = +u[e + 5], a = +u[e + 6]; o && (s += t, a += i); const r = (0, p.default)({ px: t, py: i, rx: +u[e], ry: +u[e + 1], xAxisRotation: +u[e + 2], largeArcFlag: y(+u[e + 3]), sweepFlag: y(+u[e + 4]), cx: s, cy: a }); c.each(r, (e => { this.bezierCurveTo(e.x1, e.y1, e.x2, e.y2, e.x, e.y), t = e.x, i = e.y })) } break; case "Z": case "z": g(e, u.length, 0), this.closePath() } } } _runPath(e) { e.beginPath(), c.each(this._operations, (t => { t.path(e) })) } _render(e) { super._render(e); const t = e.layer.dirty, i = this._isInteractive(e); if (t || i) { const s = e.layer.context, a = this._renderer._ghostLayer.context; let r; t && (s.globalCompositeOperation = this.blendMode, s.beginPath()), i && (a.beginPath(), r = this._getColorId()), c.each(this._operations, (e => { t && (e.path(s), e.colorize(s, void 0)), i && (e.pathGhost(a), e.colorizeGhost(a, r)) })) } } renderDetached(e) { if (this.visible) { this._setMatrix(), e.save(); const t = this.mask; t && (t._setMatrix(), t._transform(e, 1), t._runPath(e), e.clip()), e.globalAlpha = this.compoundAlpha * this.alpha, this._transform(e, 1), this.filter && (e.filter = this.filter), e.globalCompositeOperation = this.blendMode, e.beginPath(), c.each(this._operations, (t => { t.path(e), t.colorize(e, void 0) })), e.restore() } } _addBounds(e) { this.visible && this.isMeasured && c.each(this._operations, (t => { t.addBounds(e) })) } } class q extends k { constructor(e, t, i) { super(e), Object.defineProperty(this, "text", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "style", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "resolution", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "textVisible", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_textInfo", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_originalScale", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), this.text = t, this.style = i } invalidateBounds() { super.invalidateBounds(), this._textInfo = void 0 } _shared(e) { this.style.textAlign && (e.textAlign = this.style.textAlign), this.style.direction && (e.direction = this.style.direction), this.style.textBaseline && (e.textBaseline = this.style.textBaseline) } _prerender(e, t = !1, i = !1) { super._render(e); const s = e.layer.context, r = this._renderer._ghostLayer.context, n = this.style; let o = this._getFontStyle(void 0, i); s.font = o, this._isInteractive(e) && !t && (r.font = o), n.fill && (n.fill instanceof a.Color ? s.fillStyle = n.fill.toCSS(null != n.fillOpacity ? n.fillOpacity : 1) : s.fillStyle = n.fill), n.shadowColor && (e.layer.context.shadowColor = n.shadowColor.toCSS(n.shadowOpacity || 1)), n.shadowBlur && (e.layer.context.shadowBlur = n.shadowBlur), n.shadowOffsetX && (e.layer.context.shadowOffsetX = n.shadowOffsetX), n.shadowOffsetY && (e.layer.context.shadowOffsetY = n.shadowOffsetY), this._shared(s), this._isInteractive(e) && !t && (r.fillStyle = this._getColorId(), this._shared(r)) } _getFontStyle(e, t = !1) { const i = this.style; let s = []; return e && e.fontVariant ? s.push(e.fontVariant) : i.fontVariant && s.push(i.fontVariant), t || (e && e.fontWeight ? s.push(e.fontWeight) : i.fontWeight && s.push(i.fontWeight)), e && e.fontStyle ? s.push(e.fontStyle) : i.fontStyle && s.push(i.fontStyle), e && e.fontSize ? (d.isNumber(e.fontSize) && (e.fontSize = e.fontSize + "px"), s.push(e.fontSize)) : i.fontSize && (d.isNumber(i.fontSize) && (i.fontSize = i.fontSize + "px"), s.push(i.fontSize)), e && e.fontFamily ? s.push(e.fontFamily) : i.fontFamily ? s.push(i.fontFamily) : s.length && s.push("Arial"), s.join(" ") } _render(e) { if (this._textInfo || this._measure(e), this.textVisible) { const t = this._isInteractive(e), i = e.layer.context, s = e.layer.dirty, r = this._renderer._ghostLayer.context; i.save(), r.save(), this._prerender(e), c.each(this._textInfo, ((n, o) => { c.each(n.textChunks, ((o, h) => { if (o.style && (i.save(), r.save(), i.font = o.style, this._isInteractive(e) && (r.font = o.style)), o.fill && (i.save(), i.fillStyle = o.fill.toCSS()), s && i.fillText(o.text, o.offsetX, n.offsetY + o.offsetY), "underline" == o.textDecoration || "line-through" == o.textDecoration) { let e = 1, t = 1, s = o.height; const r = this.style.oversizedBehavior || ""; if (["truncate", "wrap", "wrap-no-break"].indexOf(r) > -1) { const e = this._measureText(o.text, i); o.width = e.actualBoundingBoxLeft + e.actualBoundingBoxRight } let h, c = o.offsetX; switch (this.style.textAlign) { case "right": case "end": c -= o.width; break; case "center": c -= o.width / 2 }if (o.style) { switch (l.TextFormatter.getTextStyle(o.style).fontWeight) { case "bolder": case "bold": case "700": case "800": case "900": e = 2 } } s && (t = s / 20), h = "line-through" == o.textDecoration ? e + n.offsetY + o.offsetY - o.height / 2 : e + 1.5 * t + n.offsetY + o.offsetY, i.save(), i.beginPath(), o.fill ? i.strokeStyle = o.fill.toCSS() : this.style.fill && this.style.fill instanceof a.Color && (i.strokeStyle = this.style.fill.toCSS()), i.lineWidth = e * t, i.moveTo(c, h), i.lineTo(c + o.width, h), i.stroke(), i.restore() } t && this.interactive && r.fillText(o.text, o.offsetX, n.offsetY + o.offsetY), o.fill && i.restore(), o.style && (i.restore(), r.restore()) })) })), i.restore(), r.restore() } } _addBounds(e) { if (this.visible && this.isMeasured) { const t = this._measure({ inactive: this.inactive, layer: this.getLayer() }); C(e, { x: t.left, y: t.top }), C(e, { x: t.right, y: t.bottom }) } } _ignoreFontWeight() { return /apple/i.test(navigator.vendor) } _measure(e) { const t = e.layer.context, i = this._renderer._ghostLayer.context, s = "rtl" == this.style.direction; this._textInfo = []; const a = this.style.oversizedBehavior, r = this.style.maxWidth, o = d.isNumber(r) && "truncate" == a, u = d.isNumber(r) && ("wrap" == a || "wrap-no-break" == a); t.save(), i.save(), this._prerender(e, !0, this._ignoreFontWeight()); const m = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", p = this.text.toString().replace(/\r/g, "").split(/\n/); let g, b = !0, _ = 0, f = 0, y = 0; c.each(p, ((e, s) => { let a; for (a = "" == e ? [{ type: "value", text: "" }] : l.TextFormatter.chunk(e, !1, this.style.ignoreFormatting); a.length > 0;) { let e = { offsetY: y, ascent: 0, width: 0, height: 0, left: 0, right: 0, textChunks: [] }; const s = this._measureText(m, t), p = s.actualBoundingBoxAscent + s.actualBoundingBoxDescent; let v; e.height = p, e.ascent = s.actualBoundingBoxAscent; let x, w, P, T = this.style.textDecoration, D = !1, k = !0, j = []; c.eachContinue(a, ((s, n) => { if ("format" == s.type) if ("[/]" == s.text) b || (t.restore(), i.restore(), b = !0), x = void 0, g = void 0, w = void 0, T = this.style.textDecoration, P = void 0, v = s.text; else { b || (t.restore(), i.restore()); let a = l.TextFormatter.getTextStyle(s.text); const r = this._getFontStyle(a); t.save(), i.save(), t.font = r, g = r, v = s.text, a.textDecoration && (T = a.textDecoration), a.fill && (x = a.fill), a.width && (w = d.toNumber(a.width)), a.verticalAlign && (P = a.verticalAlign), b = !1; const n = this._measureText(m, t), o = n.actualBoundingBoxAscent + n.actualBoundingBoxDescent; o > e.height && (e.height = o), n.actualBoundingBoxAscent > e.ascent && (e.ascent = n.actualBoundingBoxAscent) } else if ("value" == s.type && !D) { const i = this._measureText(s.text, t); let l = i.actualBoundingBoxLeft + i.actualBoundingBoxRight; if (o) { let i = k || this.style.breakWords || !1; const a = this.style.ellipsis || "", n = this._measureText(a, t), o = n.actualBoundingBoxLeft + n.actualBoundingBoxRight; if (e.width + l > r) { const n = r - e.width - o; s.text = this._truncateText(t, s.text, n, i), s.text += a, D = !0 } } else if (u && e.width + l > r) { const i = r - e.width, o = this._truncateText(t, s.text, i, !1, k && "wrap-no-break" != this.style.oversizedBehavior); if ("" == o) return this.textVisible = !0, !1; j = a.slice(n + 1), h.trim(o) != h.trim(s.text) && (j.unshift({ type: "value", text: s.text.substr(o.length) }), v && j.unshift({ type: "format", text: v })), s.text = h.trim(o), a = [], D = !0 } let c = 1, d = 1; if (g && w && w > l) { const e = l / w; switch (this.style.textAlign) { case "right": case "end": c = e; break; case "center": c = e, d = e; break; default: d = e }l = w } const m = i.actualBoundingBoxAscent + i.actualBoundingBoxDescent; m > e.height && (e.height = m), i.actualBoundingBoxAscent > e.ascent && (e.ascent = i.actualBoundingBoxAscent), e.width += l, e.left += i.actualBoundingBoxLeft / c, e.right += i.actualBoundingBoxRight / d, e.textChunks.push({ style: g, fill: x, text: s.text, width: l, height: m, left: i.actualBoundingBoxLeft, right: i.actualBoundingBoxRight, ascent: i.actualBoundingBoxAscent, offsetX: 0, offsetY: 0, textDecoration: T, verticalAlign: P }), k = !1 } return !0 })), this.style.lineHeight instanceof n.Percent ? (e.height *= this.style.lineHeight.value, e.ascent *= this.style.lineHeight.value) : (e.height *= this.style.lineHeight || 1.2, e.ascent *= this.style.lineHeight || 1.2), _ < e.left && (_ = e.left), f < e.right && (f = e.right), this._textInfo.push(e), y += e.height, a = j || [] } })), b || (t.restore(), i.restore()), c.each(this._textInfo, ((e, t) => { let i = 0; c.each(e.textChunks, (t => { if (t.offsetX = i + t.left - e.left, t.offsetY += e.height - e.height * (this.style.baselineRatio || .19), i += t.width, t.verticalAlign) switch (t.verticalAlign) { case "super": t.offsetY -= e.height / 2 - t.height / 2; break; case "sub": t.offsetY += t.height / 2 } })) })); const v = { left: s ? -f : -_, top: 0, right: s ? _ : f, bottom: y }; if ("none" !== a) { const e = this._fitRatio(v); if (e < 1) if ("fit" == a) d.isNumber(this.style.minScale) && e < this.style.minScale ? (this.textVisible = !1, v.left = 0, v.top = 0, v.right = 0, v.bottom = 0) : (this._originalScale && 1 != this._originalScale || (this._originalScale = this.scale), this.scale = e, this.textVisible = !0); else if ("hide" == a) this.textVisible = !1, v.left = 0, v.top = 0, v.right = 0, v.bottom = 0; else { switch (this.style.textAlign) { case "right": case "end": v.left = s ? r : -r, v.right = 0; break; case "center": v.left = -r / 2, v.right = r / 2; break; default: v.left = 0, v.right = s ? -r : r }this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0 } else this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0 } return t.restore(), i.restore(), v } _fitRatio(e) { const t = this.style.maxWidth, i = this.style.maxHeight; if (!d.isNumber(t) && !d.isNumber(i)) return 1; const s = e.right - e.left, a = e.bottom - e.top; return Math.min(t / s || 1, i / a || 1) } _truncateText(e, t, i, s = !1, a = !0) { let r; do { if (s) t = t.slice(0, -1); else { let e = t.replace(/[^,;:!?\\\/\s]+[,;:!?\\\/\s]*$/g, ""); if ("" != e && e !== t || !a) { if ("" == e) return t; t = e } else s = !0 } const i = this._measureText(t, e); r = i.actualBoundingBoxLeft + i.actualBoundingBoxRight } while (r > i && "" != t); return t } _measureText(e, t) { let i = t.measureText(e), s = {}; if (null == i.actualBoundingBoxAscent) { const t = document.createElement("div"); t.innerText = e, t.style.visibility = "hidden", t.style.position = "absolute", t.style.top = "-1000000px;", t.style.fontFamily = this.style.fontFamily || "", t.style.fontSize = this.style.fontSize + "", document.body.appendChild(t); const a = t.getBoundingClientRect(); document.body.removeChild(t); const r = a.height, n = i.width; s = { actualBoundingBoxAscent: r, actualBoundingBoxDescent: 0, actualBoundingBoxLeft: 0, actualBoundingBoxRight: n, fontBoundingBoxAscent: r, fontBoundingBoxDescent: 0, width: n } } else s = { actualBoundingBoxAscent: i.actualBoundingBoxAscent, actualBoundingBoxDescent: i.actualBoundingBoxDescent, actualBoundingBoxLeft: i.actualBoundingBoxLeft, actualBoundingBoxRight: i.actualBoundingBoxRight, fontBoundingBoxAscent: i.actualBoundingBoxAscent, fontBoundingBoxDescent: i.actualBoundingBoxDescent, width: i.width }; const a = i.width; switch (this.style.textAlign) { case "right": case "end": s.actualBoundingBoxLeft = a, s.actualBoundingBoxRight = 0; break; case "center": s.actualBoundingBoxLeft = a / 2, s.actualBoundingBoxRight = a / 2; break; default: s.actualBoundingBoxLeft = 0, s.actualBoundingBoxRight = a }return s } } class J { constructor() { Object.defineProperty(this, "fill", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fillOpacity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "textAlign", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fontFamily", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fontWeight", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "fontVariant", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "textDecoration", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowColor", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowBlur", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOffsetX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOffsetY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOpacity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "lineHeight", { enumerable: !0, configurable: !0, writable: !0, value: (0, n.percent)(120) }), Object.defineProperty(this, "baselineRatio", { enumerable: !0, configurable: !0, writable: !0, value: .19 }), Object.defineProperty(this, "direction", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "textBaseline", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "oversizedBehavior", { enumerable: !0, configurable: !0, writable: !0, value: "none" }), Object.defineProperty(this, "breakWords", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "ellipsis", { enumerable: !0, configurable: !0, writable: !0, value: "" }), Object.defineProperty(this, "maxWidth", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "maxHeight", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "minScale", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "ignoreFormatting", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } } class $ extends q { constructor() { super(...arguments), Object.defineProperty(this, "textType", { enumerable: !0, configurable: !0, writable: !0, value: "circular" }), Object.defineProperty(this, "radius", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "startAngle", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "inside", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "orientation", { enumerable: !0, configurable: !0, writable: !0, value: "auto" }), Object.defineProperty(this, "kerning", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_textReversed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } _render(e) { if ("circular" === this.textType) this._renderCircular(e); else super._render(e) } _renderCircular(e) { if (this.textVisible) { this._prerender(e); const t = this._isInteractive(e), i = e.layer.context, s = e.layer.dirty, a = this._renderer._ghostLayer.context; i.save(), t && a.save(), this._textInfo || this._measure(e); let r = this.radius || 0, n = this.startAngle || 0, o = 0, l = this.orientation, h = "auto" == l ? "auto" : "inward" == l; const u = this.inside, d = this.style.textAlign || "left", p = this.kerning || 0; let g = "left" == d ? 1 : -1; const b = !this._textReversed; if ("auto" == h) { let e = 0, t = 0; c.each(this._textInfo, ((t, i) => { const s = n + t.width / (r - t.height) / 2 * -g; s > e && (e = s) })), t = "left" == d ? (e + o / 2) * m.DEGREES : "right" == d ? (e - o / 2) * m.DEGREES : n * m.DEGREES, t = m.normalizeAngle(t), h = t >= 270 || t <= 90 } 1 == h && b && (this._textInfo.reverse(), this._textReversed = !0), c.each(this._textInfo, ((e, l) => { const m = e.height; u || (r += m), (-1 == g && h || 1 == g && !h) && b && e.textChunks.reverse(); let _ = n; o = 0, "center" == d && (_ += e.width / (r - m) / 2 * -g, o = _ - n), _ += Math.PI * (h ? 0 : 1), i.save(), t && a.save(), i.rotate(_), t && a.rotate(_); let f = 0; c.each(e.textChunks, ((e, n) => { const o = e.text, l = e.width; f = l / 2 / (r - m) * g, i.rotate(f), t && a.rotate(f), e.style && (i.save(), a.save(), i.font = e.style, t && (a.font = e.style)), e.fill && (i.save(), i.fillStyle = e.fill.toCSS()), i.textBaseline = "middle", i.textAlign = "center", t && (a.textBaseline = "middle", a.textAlign = "center"), s && i.fillText(o, 0, (h ? 1 : -1) * (0 - r + m / 2)), t && a.fillText(o, 0, (h ? 1 : -1) * (0 - r + m / 2)), e.fill && i.restore(), e.style && (i.restore(), a.restore()), f = (l / 2 + p) / (r - m) * g, i.rotate(f), t && a.rotate(f) })), i.restore(), t && a.restore(), u && (r -= m) })), i.restore(), t && a.restore() } } _measure(e) { return "circular" === this.textType ? this._measureCircular(e) : super._measure(e) } _measureCircular(e) { const t = e.layer.context, i = this._renderer._ghostLayer.context, s = "rtl" == this.style.direction, a = this.style.oversizedBehavior, r = this.style.maxWidth, o = d.isNumber(r) && "truncate" == a, u = this.style.ellipsis || ""; let m; this.textVisible = !0, this._textInfo = [], this._textReversed = !1, t.save(), i.save(), this._prerender(e, !0); const p = this.text.toString().replace(/\r/g, "").split(/\n/); let g = !0, b = 0, _ = 0; return c.each(p, ((e, a) => { let p, f, y, v = l.TextFormatter.chunk(e, !1, this.style.ignoreFormatting), x = { offsetY: _, ascent: 0, width: 0, height: 0, left: 0, right: 0, textChunks: [] }; c.each(v, ((e, a) => { if ("format" == e.type) { if ("[/]" == e.text) g || (t.restore(), i.restore(), g = !0), f = void 0, p = void 0, y = void 0; else { let s = l.TextFormatter.getTextStyle(e.text); const a = this._getFontStyle(s); t.save(), i.save(), t.font = a, p = a, s.fill && (f = s.fill), s.width && (y = d.toNumber(s.width)), g = !1 } o && (m = this._measureText(u, t)) } else if ("value" == e.type) { let i = e.text.match(/./gu) || []; s && (i = h.splitString(e.text), i.reverse()); for (let e = 0; e < i.length; e++) { const s = i[e], a = this._measureText(s, t); let n = a.width; p && y && y > n && (n = y); const l = a.actualBoundingBoxAscent + a.actualBoundingBoxDescent; if (l > x.height && (x.height = l), a.actualBoundingBoxAscent > x.ascent && (x.ascent = a.actualBoundingBoxAscent), b += n, o) { m || (m = this._measureText(u, t)); const e = m.actualBoundingBoxLeft + m.actualBoundingBoxRight; if (b + e > r) { 1 == x.textChunks.length ? this.textVisible = !1 : (x.width += e, x.left += m.actualBoundingBoxLeft, x.right += m.actualBoundingBoxRight, x.textChunks.push({ style: p, fill: f, text: u, width: e, height: l + m.actualBoundingBoxDescent, left: m.actualBoundingBoxLeft, right: m.actualBoundingBoxRight, ascent: m.actualBoundingBoxAscent, offsetX: 0, offsetY: l, textDecoration: void 0 })); break } } x.width += n, x.left += a.actualBoundingBoxLeft, x.right += a.actualBoundingBoxRight, x.textChunks.push({ style: p, fill: f, text: s, width: n, height: l + a.actualBoundingBoxDescent, left: a.actualBoundingBoxLeft, right: a.actualBoundingBoxRight, ascent: a.actualBoundingBoxAscent, offsetX: 0, offsetY: l, textDecoration: void 0 }) } } })), this.style.lineHeight instanceof n.Percent ? x.height *= this.style.lineHeight.value : x.height *= this.style.lineHeight || 1.2, this._textInfo.push(x), _ += x.height })), g || (t.restore(), i.restore()), "hide" == a && b > r && (this.textVisible = !1), c.each(this._textInfo, (e => { c.each(e.textChunks, (t => { t.offsetY += Math.round((e.height - t.height + (e.ascent - t.ascent)) / 2) })) })), t.restore(), i.restore(), { left: 0, top: 0, right: 0, bottom: 0 } } } class Q extends k { constructor(e, t) { super(e), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "image", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "tainted", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowColor", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowBlur", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOffsetX", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOffsetY", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "shadowOpacity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_imageMask", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.image = t } _dispose() { super._dispose(), this._imageMask && P(this._imageMask) } getLocalBounds() { if (!this._localBounds) { let e = 0, t = 0; this.width && (e = this.width), this.height && (t = this.height), this._localBounds = { left: 0, top: 0, right: e, bottom: t }, this._addBounds(this._localBounds) } return this._localBounds } _render(e) { if (super._render(e), this.image) { if (void 0 === this.tainted && (this.tainted = w(this.image), e.layer.tainted = !0), this.tainted && this._renderer._omitTainted) return; if (e.layer.dirty) { this.shadowColor && (e.layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1)), this.shadowBlur && (e.layer.context.shadowBlur = this.shadowBlur), this.shadowOffsetX && (e.layer.context.shadowOffsetX = this.shadowOffsetX), this.shadowOffsetY && (e.layer.context.shadowOffsetY = this.shadowOffsetY); const t = this.width || this.image.naturalWidth, i = this.height || this.image.naturalHeight; e.layer.context.drawImage(this.image, 0, 0, t, i) } if (this.interactive && this._isInteractive(e)) { const e = this._getMask(this.image); this._renderer._ghostLayer.context.drawImage(e, 0, 0) } } } clear() { super.clear(), this.image = void 0, this._imageMask = void 0 } _getMask(e) { if (void 0 === this._imageMask) { const t = this.width || e.naturalWidth, i = this.height || e.naturalHeight, s = document.createElement("canvas"); s.width = t, s.height = i; const a = s.getContext("2d"); a.imageSmoothingEnabled = !1, a.fillStyle = this._getColorId(), a.fillRect(0, 0, t, i), w(e) || (a.globalCompositeOperation = "destination-in", a.drawImage(e, 0, 0, t, i)), this._imageMask = s } return this._imageMask } } class ee { constructor(e, t, i, s) { Object.defineProperty(this, "event", { enumerable: !0, configurable: !0, writable: !0, value: e }), Object.defineProperty(this, "originalPoint", { enumerable: !0, configurable: !0, writable: !0, value: t }), Object.defineProperty(this, "point", { enumerable: !0, configurable: !0, writable: !0, value: i }), Object.defineProperty(this, "bbox", { enumerable: !0, configurable: !0, writable: !0, value: s }), Object.defineProperty(this, "id", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "simulated", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "native", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), h.supports("touchevents") && e instanceof Touch ? this.id = e.identifier : this.id = null } } class te extends o.ArrayDisposer { constructor(e) { if (super(), Object.defineProperty(this, "view", { enumerable: !0, configurable: !0, writable: !0, value: document.createElement("div") }), Object.defineProperty(this, "_layerDom", { enumerable: !0, configurable: !0, writable: !0, value: document.createElement("div") }), Object.defineProperty(this, "layers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_dirtyLayers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "defaultLayer", { enumerable: !0, configurable: !0, writable: !0, value: this.getLayer(0) }), Object.defineProperty(this, "_ghostLayer", { enumerable: !0, configurable: !0, writable: !0, value: new ie }), Object.defineProperty(this, "_patternCanvas", { enumerable: !0, configurable: !0, writable: !0, value: document.createElement("canvas") }), Object.defineProperty(this, "_patternContext", { enumerable: !0, configurable: !0, writable: !0, value: this._patternCanvas.getContext("2d") }), Object.defineProperty(this, "_realWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_realHeight", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_calculatedWidth", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_calculatedHeight", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "resolution", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "interactionsEnabled", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_listeners", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_events", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_colorId", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_colorMap", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_forceInteractive", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_omitTainted", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_hovering", { enumerable: !0, configurable: !0, writable: !0, value: new Set }), Object.defineProperty(this, "_dragging", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_mousedown", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_lastPointerMoveEvent", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "tapToActivate", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "tapToActivateTimeout", { enumerable: !0, configurable: !0, writable: !0, value: 3e3 }), Object.defineProperty(this, "_touchActive", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_touchActiveTimeout", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.resolution = null == e ? window.devicePixelRatio : e, this.view.style.position = "absolute", this.view.setAttribute("aria-hidden", "true"), this.view.appendChild(this._layerDom), this._disposers.push(new o.Disposer((() => { u.each(this._events, ((e, t) => { t.disposer.dispose() })), c.each(this.layers, (e => { P(e.view), e.exportableView && P(e.exportableView) })), P(this._ghostLayer.view), P(this._patternCanvas) }))), this._disposers.push(h.onZoom((() => { null == e && (this.resolution = window.devicePixelRatio) }))), h.supports("touchevents")) { const e = e => { 0 !== this._dragging.length && c.eachContinue(this._dragging, (t => !t.value.shouldCancelTouch() || (e.preventDefault(), !1))), this._touchActiveTimeout && this._delayTouchDeactivate() }; this._disposers.push(h.addEventListener(window, "touchstart", e, { passive: !1 })), this._disposers.push(h.addEventListener(this.view, "touchstart", e, { passive: !1 })), this._disposers.push(h.addEventListener(this.view, "touchmove", (() => { this._touchActiveTimeout && this._delayTouchDeactivate() }), { passive: !0 })), this._disposers.push(h.addEventListener(window, "click", (e => { this._touchActive = !1 }), { passive: !0 })), this._disposers.push(h.addEventListener(this.view, "click", (e => { window.setTimeout((() => { this._touchActive = !0, this._delayTouchDeactivate() }), 100) }), { passive: !0 })) } h.supports("wheelevents") && this._disposers.push(h.addEventListener(this.view, "wheel", (e => { let t = !1; this._hovering.forEach((e => { if (e.wheelable) return t = !0, !1 })), t && e.preventDefault() }), { passive: !1 })) } resetImageArray() { this._ghostLayer.imageArray = void 0 } _delayTouchDeactivate() { this._touchActiveTimeout && clearTimeout(this._touchActiveTimeout), this.tapToActivateTimeout > 0 && (this._touchActiveTimeout = window.setTimeout((() => { this._touchActive = !1 }), this.tapToActivateTimeout)) } get debugGhostView() { return !!this._ghostLayer.view.parentNode } set debugGhostView(e) { e ? this._ghostLayer.view.parentNode || this.view.appendChild(this._ghostLayer.view) : this._ghostLayer.view.parentNode && this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view) } createLinearGradient(e, t, i, s) { return this.defaultLayer.context.createLinearGradient(e, t, i, s) } createRadialGradient(e, t, i, s, a, r) { return this.defaultLayer.context.createRadialGradient(e, t, i, s, a, r) } createPattern(e, t, i, s, a) { return this._patternCanvas.width = s, this._patternCanvas.height = a, this._patternContext.clearRect(0, 0, s, a), t.renderDetached(this._patternContext), e.renderDetached(this._patternContext), this._patternContext.createPattern(this._patternCanvas, i) } makeContainer() { return new j(this) } makeGraphics() { return new Z(this) } makeText(e, t) { return new q(this, e, t) } makeTextStyle() { return new J } makeRadialText(e, t) { return new $(this, e, t) } makePicture(e) { return new Q(this, e) } resizeLayer(e) { e.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution) } resizeGhost() { this._ghostLayer.resize(this._calculatedWidth, this._calculatedHeight, this._calculatedWidth, this._calculatedHeight, this.resolution) } resize(e, t, i, s) { this._realWidth = e, this._realHeight = t, this._calculatedWidth = i, this._calculatedHeight = s, c.each(this.layers, (e => { e && (e.dirty = !0, this.resizeLayer(e)) })), this.resizeGhost(), this.view.style.width = i + "px", this.view.style.height = s + "px" } createDetachedLayer(e = !1) { const t = document.createElement("canvas"), i = t.getContext("2d", { willReadFrequently: e }), s = new se(t, i); return t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", s } getLayerByOrder(e) { const t = this.layers, i = t.length; for (let s = 0; s < i; s++) { const i = t[s]; if (i.order == e) return i } } getLayer(e, t = !0) { let i = this.getLayerByOrder(e); if (i) return i; const s = this.createDetachedLayer(99 == e); s.order = e, s.visible = t, s.view.className = "am5-layer-" + e, s.visible && this.resizeLayer(s); const a = this.layers; a.push(s), a.sort(((e, t) => e.order > t.order ? 1 : e.order < t.order ? -1 : 0)); const r = a.length; let n; for (let e = c.indexOf(a, s) + 1; e < r; e++)if (a[e].visible) { n = a[e]; break } return s.visible && (void 0 === n ? this._layerDom.appendChild(s.view) : this._layerDom.insertBefore(s.view, n.view)), s } render(e) { if (this._dirtyLayers.length = 0, c.each(this.layers, (e => { e && e.dirty && e.visible && (this._dirtyLayers.push(e), e.clear()) })), this._ghostLayer.clear(), e.render({ inactive: null, layer: this.defaultLayer }), this._ghostLayer.context.restore(), c.each(this.layers, (e => { if (e) { const t = e.context; t.beginPath(), t.moveTo(0, 0), t.stroke() } })), c.each(this._dirtyLayers, (e => { e.context.restore(), e.dirty = !1 })), this._hovering.size && this._lastPointerMoveEvent) { const { events: e, target: t, native: i } = this._lastPointerMoveEvent; c.each(e, (e => { this._dispatchGlobalMousemove(e, t, i) })) } } paintId(e) { const t = function (e) { const t = [0, 0, 0]; for (let i = 0; i < 24; i++)t[i % 3] <<= 1, t[i % 3] |= 1 & e, e >>= 1; return (0 | t[0]) + (t[1] << 8) + (t[2] << 16) }(++this._colorId), i = a.Color.fromHex(t).toCSS(); return this._colorMap[i] = e, i } _removeObject(e) { void 0 !== e._colorId && delete this._colorMap[e._colorId] } _adjustBoundingBox(e) { const t = this._ghostLayer.margin; return new DOMRect(-t.left, -t.top, e.width + t.left + t.right, e.height + t.top + t.bottom) } getEvent(e, t = !0) { const i = this.view.getBoundingClientRect(), s = e.clientX || 0, a = e.clientY || 0, r = this._calculatedWidth / this._realWidth, n = this._calculatedHeight / this._realHeight, o = { x: s - i.left, y: a - i.top }, l = { x: (s - (t ? i.left : 0)) * r, y: (a - (t ? i.top : 0)) * n }; return new ee(e, o, l, this._adjustBoundingBox(i)) } _getHitTarget(e, t, i) { if (0 === t.width || 0 === t.height || e.x < t.left || e.x > t.right || e.y < t.top || e.y > t.bottom) return; if (!i || !this._layerDom.contains(i)) return; const s = this._ghostLayer.getImageData(e, t); if (0 === s.data[0] && 0 === s.data[1] && 0 === s.data[2]) return !1; const r = a.Color.fromRGB(s.data[0], s.data[1], s.data[2]).toCSS(); return this._colorMap[r] } getObjectAtPoint(e) { const t = this._ghostLayer.getImageArray(e); if (0 === t[0] && 0 === t[1] && 0 === t[2]) return; const i = a.Color.fromRGB(t[0], t[1], t[2]).toCSS(); return this._colorMap[i] } _withEvents(e, t) { const i = this._events[e]; if (void 0 !== i) { i.dispatching = !0; try { t(i) } finally { i.dispatching = !1, i.cleanup && (i.cleanup = !1, c.keepIf(i.callbacks, (e => !e.disposed)), 0 === i.callbacks.length && (i.disposer.dispose(), delete this._events[e])) } } } _dispatchEventAll(e, t) { this.interactionsEnabled && this._withEvents(e, (e => { c.each(e.callbacks, (e => { e.disposed || e.callback.call(e.context, t) })) })) } _dispatchEvent(e, t, i) { if (!this.interactionsEnabled) return !1; let s = !1; return this._withEvents(e, (e => { c.each(e.callbacks, (e => { e.disposed || e.object !== t || (e.callback.call(e.context, i), s = !0) })) })), s } _dispatchMousedown(e, t) { const i = e.button; if (0 != i && 2 != i && 1 != i && void 0 !== i) return; const s = this.getEvent(e), a = this._getHitTarget(s.originalPoint, s.bbox, t); if (a) { const e = s.id; let t = !1; v(a, (i => { const a = { id: e, value: i }; if (this._mousedown.push(a), !t && this._dispatchEvent("pointerdown", i, s)) { t = !0; this._dragging.some((t => t.value === i && t.id === e)) || this._dragging.push(a) } return !0 })) } } _dispatchGlobalMousemove(e, t, i) { const s = this.getEvent(e), a = this._getHitTarget(s.originalPoint, s.bbox, t); s.native = i, a ? (this._hovering.forEach((e => { e.contains(a) || (this._hovering.delete(e), e.cursorOverStyle && h.setStyle(document.body, "cursor", e._replacedCursorStyle), this._dispatchEvent("pointerout", e, s)) })), s.native && v(a, (e => (this._hovering.has(e) || (this._hovering.add(e), e.cursorOverStyle && (e._replacedCursorStyle = h.getStyle(document.body, "cursor"), h.setStyle(document.body, "cursor", e.cursorOverStyle)), this._dispatchEvent("pointerover", e, s)), !0)))) : (this._hovering.forEach((e => { e.cursorOverStyle && h.setStyle(document.body, "cursor", e._replacedCursorStyle), this._dispatchEvent("pointerout", e, s) })), this._hovering.clear()), this._dispatchEventAll("globalpointermove", s) } removeHovering(e) { this._hovering.delete(e), e.cursorOverStyle && h.setStyle(document.body, "cursor", e._replacedCursorStyle) } _dispatchGlobalMouseup(e, t) { const i = this.getEvent(e); i.native = t, this._dispatchEventAll("globalpointerup", i) } _dispatchDragMove(e) { if (0 !== this._dragging.length) { const t = this.getEvent(e), i = t.id; this._dragging.forEach((e => { e.id === i && this._dispatchEvent("pointermove", e.value, t) })) } } _dispatchDragEnd(e, t) { const i = e.button; let s; if (0 == i || void 0 === i) s = "click"; else if (2 == i) s = "rightclick"; else { if (1 != i) return; s = "middleclick" } const a = this.getEvent(e), r = a.id; if (0 !== this._mousedown.length) { const e = this._getHitTarget(a.originalPoint, a.bbox, t); e && this._mousedown.forEach((t => { t.id === r && t.value.contains(e) && this._dispatchEvent(s, t.value, a) })), this._mousedown.length = 0 } 0 !== this._dragging.length && (this._dragging.forEach((e => { e.id === r && this._dispatchEvent("pointerup", e.value, a) })), this._dragging.length = 0) } _dispatchDoubleClick(e, t) { const i = this.getEvent(e), s = this._getHitTarget(i.originalPoint, i.bbox, t); s && v(s, (e => !this._dispatchEvent("dblclick", e, i))) } _dispatchWheel(e, t) { const i = this.getEvent(e), s = this._getHitTarget(i.originalPoint, i.bbox, t); s && v(s, (e => !this._dispatchEvent("wheel", e, i))) } _makeSharedEvent(e, t) { if (void 0 === this._listeners[e]) { const i = t(); this._listeners[e] = new o.CounterDisposer((() => { delete this._listeners[e], i.dispose() })) } return this._listeners[e].increment() } _onPointerEvent(e, t) { let i = !1, s = null; function a() { s = null, i = !1 } return new o.MultiDisposer([new o.Disposer((() => { null !== s && clearTimeout(s), a() })), h.addEventListener(this.view, h.getRendererEvent(e), (e => { i = !0, null !== s && clearTimeout(s), s = window.setTimeout(a, 0) })), x(window, e, ((e, a) => { null !== s && (clearTimeout(s), s = null), t(e, a, i), i = !1 }))]) } _initEvent(e) { switch (e) { case "globalpointermove": case "pointerover": case "pointerout": return this._makeSharedEvent("pointermove", (() => { const e = (e, t, i) => { this._lastPointerMoveEvent = { events: e, target: t, native: i }, c.each(e, (e => { this._dispatchGlobalMousemove(e, t, i) })) }; return new o.MultiDisposer([this._onPointerEvent("pointerdown", e), this._onPointerEvent("pointermove", e)]) })); case "globalpointerup": return this._makeSharedEvent("pointerup", (() => { const e = this._onPointerEvent("pointerup", ((e, t, i) => { c.each(e, (e => { this._dispatchGlobalMouseup(e, i) })), this._lastPointerMoveEvent = { events: e, target: t, native: i } })), t = this._onPointerEvent("pointercancel", ((e, t, i) => { c.each(e, (e => { this._dispatchGlobalMouseup(e, i) })), this._lastPointerMoveEvent = { events: e, target: t, native: i } })); return new o.Disposer((() => { e.dispose(), t.dispose() })) })); case "click": case "rightclick": case "middleclick": case "pointerdown": case "pointermove": case "pointerup": return this._makeSharedEvent("pointerdown", (() => { const e = this._onPointerEvent("pointerdown", ((e, t) => { c.each(e, (e => { this._dispatchMousedown(e, t) })) })), t = this._onPointerEvent("pointermove", (e => { c.each(e, (e => { this._dispatchDragMove(e) })) })), i = this._onPointerEvent("pointerup", ((e, t) => { c.each(e, (e => { this._dispatchDragEnd(e, t) })) })), s = this._onPointerEvent("pointercancel", ((e, t) => { c.each(e, (e => { this._dispatchDragEnd(e, t) })) })); return new o.Disposer((() => { e.dispose(), t.dispose(), i.dispose(), s.dispose() })) })); case "dblclick": return this._makeSharedEvent("dblclick", (() => this._onPointerEvent("dblclick", ((e, t) => { c.each(e, (e => { this._dispatchDoubleClick(e, t) })) })))); case "wheel": return this._makeSharedEvent("wheel", (() => h.addEventListener(this.view, h.getRendererEvent("wheel"), (e => { this._dispatchWheel(e, h.getEventTarget(e)) }), { passive: !1 }))) } } _addEvent(e, t, i, s) { let a = this._events[t]; void 0 === a && (a = this._events[t] = { disposer: this._initEvent(t), callbacks: [], dispatching: !1, cleanup: !1 }); const r = { object: e, context: s, callback: i, disposed: !1 }; return a.callbacks.push(r), new o.Disposer((() => { r.disposed = !0, a.dispatching ? a.cleanup = !0 : (c.removeFirst(a.callbacks, r), 0 === a.callbacks.length && (a.disposer.dispose(), delete this._events[t])) })) } getCanvas(e, t) { this.render(e), t || (t = {}); let i = this.resolution, s = Math.floor(this._calculatedWidth * this.resolution), a = Math.floor(this._calculatedHeight * this.resolution); if (t.minWidth && t.minWidth > s) { let e = t.minWidth / s; e > i && (i = e * this.resolution) } if (t.minHeight && t.minHeight > a) { let e = t.minHeight / a; e > i && (i = e * this.resolution) } if (t.maxWidth && t.maxWidth < s) { let e = t.maxWidth / s; e < i && (i = e * this.resolution) } if (t.maxHeight && t.maxHeight > a) { let e = t.maxHeight / a; e < i && (i = e * this.resolution) } t.maintainPixelRatio && (i /= this.resolution); const r = []; let n = !1; const o = document.createElement("canvas"); i != this.resolution && (n = !0, s = s * i / this.resolution, a = a * i / this.resolution), o.width = s, o.height = a, o.style.position = "fixed", o.style.top = "-10000px", this.view.appendChild(o), r.push(o); const l = o.getContext("2d"); let h = 0, u = 0, d = !1; return c.each(this.layers, (e => { if (e && e.visible && (e.tainted || n)) { d = !0, e.exportableView = e.view, e.exportableContext = e.context, e.view = document.createElement("canvas"), e.view.style.position = "fixed", e.view.style.top = "-10000px", this.view.appendChild(e.view), r.push(e.view); let t = 0, n = 0; e.margin && (t += e.margin.left || 0 + e.margin.right || 0, n += e.margin.top || 0 + e.margin.bottom || 0), e.view.width = s + t, e.view.height = a + n, e.context = e.view.getContext("2d"), e.dirty = !0, e.scale = i } })), d && (this._omitTainted = !0, this.render(e), this._omitTainted = !1), c.each(this.layers, (e => { if (e && e.visible) { let t = 0, i = 0; e.margin && (t = -(e.margin.left || 0) * this.resolution, i = -(e.margin.top || 0) * this.resolution), l.drawImage(e.view, t, i), e.exportableView && (e.view = e.exportableView, e.exportableView = void 0), e.exportableContext && (e.context = e.exportableContext, e.exportableContext = void 0), h < e.view.clientWidth && (h = e.view.clientWidth), u < e.view.clientHeight && (u = e.view.clientHeight), e.scale = void 0 } })), o.style.width = h + "px", o.style.height = u + "px", c.each(r, (e => { e.style.position = "", e.style.top = "", this.view.removeChild(e) })), o } } class ie { constructor() { Object.defineProperty(this, "view", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "context", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "margin", { enumerable: !0, configurable: !0, writable: !0, value: { left: 0, right: 0, top: 0, bottom: 0 } }), Object.defineProperty(this, "_resolution", { enumerable: !0, configurable: !0, writable: !0, value: 1 }), Object.defineProperty(this, "_width", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_height", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "imageArray", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.view = document.createElement("canvas"), this.context = this.view.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.context.imageSmoothingEnabled = !1, this.view.style.position = "absolute", this.view.style.top = "0px", this.view.style.left = "0px" } resize(e, t, i, s, a) { this._resolution = a, e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, i += this.margin.left + this.margin.right, s += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px", this._width = Math.floor(e * a), this._height = Math.floor(t * a), this.view.width = this._width, this.view.style.width = i + "px", this.view.height = this._height, this.view.style.height = s + "px" } getImageData(e, t) { return this.context.getImageData(Math.round((e.x - t.left) / t.width * this._width), Math.round((e.y - t.top) / t.height * this._height), 1, 1) } getImageArray(e) { this.imageArray || (this.imageArray = this.context.getImageData(0, 0, this._width, this._height).data); const t = this.imageArray, i = Math.round(e.x * this._resolution), s = 4 * (Math.round(e.y * this._resolution) * this._width + i); return [t[s], t[s + 1], t[s + 2], t[s + 3]] } setMargin(e) { this.margin.left = 0, this.margin.right = 0, this.margin.top = 0, this.margin.bottom = 0, c.each(e, (e => { e.margin && (this.margin.left = Math.max(this.margin.left, e.margin.left), this.margin.right = Math.max(this.margin.right, e.margin.right), this.margin.top = Math.max(this.margin.top, e.margin.top), this.margin.bottom = Math.max(this.margin.bottom, e.margin.bottom)) })) } clear() { this.context.save(), this.context.fillStyle = "#000", this.context.fillRect(0, 0, this._width, this._height) } } class se { constructor(e, t) { Object.defineProperty(this, "view", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "context", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "tainted", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "margin", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "order", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "visible", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "scale", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "dirty", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "exportableView", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "exportableContext", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_width", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_height", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), this.view = e, this.context = t } resize(e, t, i, s, a) { null != this.width && (e = this.width, i = this.width), null != this.height && (t = this.height, s = this.height), this.margin ? (e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, i += this.margin.left + this.margin.right, s += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px") : (this.view.style.left = "0px", this.view.style.top = "0px"), this._width = Math.floor(e * a), this._height = Math.floor(t * a), this.view.width = this._width, this.view.style.width = i + "px", this.view.height = this._height, this.view.style.height = s + "px" } clear() { this.context.save(), this.context.clearRect(0, 0, this._width, this._height) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/render/backend/Renderer.js": (e, t, i) => { var s; i.r(t), i.d(t, { BlendMode: () => s }), function (e) { e.ADD = "lighter", e.COLOR = "color", e.COLOR_BURN = "color-burn", e.COLOR_DODGE = "color-dodge", e.DARKEN = "darken", e.DIFFERENCE = "difference", e.DST_OVER = "destination-over", e.EXCLUSION = "exclusion", e.HARD_LIGHT = "hard-light", e.HUE = "hue", e.LIGHTEN = "lighten", e.LUMINOSITY = "luminosity", e.MULTIPLY = "multiply", e.NORMAL = "source-over", e.OVERLAY = "overlay", e.SATURATION = "saturation", e.SCREEN = "screen", e.SOFT_LIGHT = "soft-light", e.SRC_ATOP = "source-atop", e.XOR = "xor" }(s || (s = {})) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js": (e, t, i) => { i.r(t), i.d(t, { Pattern: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"); class a extends s.Entity { constructor() { super(...arguments), Object.defineProperty(this, "_display", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeGraphics() }), Object.defineProperty(this, "_backgroundDisplay", { enumerable: !0, configurable: !0, writable: !0, value: this._root._renderer.makeGraphics() }), Object.defineProperty(this, "_clear", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_pattern", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _afterNew() { super._afterNewApplyThemes() } get pattern() { return this._pattern } _draw() { } _beforeChanged() { super._beforeChanged(), (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fillOpacity")) && (this._clear = !0), this._checkDirtyFill() } _checkDirtyFill() { (this.isDirty("color") || this.isDirty("fill")) && (this._clear = !0) } _changed() { if (super._changed(), this._clear) { const e = this.get("repetition", ""), t = this.get("width", 100), i = this.get("height", 100), s = this.get("fill"), a = this.get("fillOpacity", 1), r = this._backgroundDisplay, n = this._display; n.clear(), r.clear(), s && a > 0 && (r.beginFill(s, a), r.drawRect(0, 0, t, i), r.endFill()), n.angle = this.get("rotation", 0), this._draw(), this._pattern = this._root._renderer.createPattern(n, r, e, t, i) } this._clear = !1 } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Pattern" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Entity.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/PicturePattern.js": (e, t, i) => { i.r(t), i.d(t, { PicturePattern: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/render/patterns/Pattern.js"); class a extends s.Pattern { constructor() { super(...arguments), Object.defineProperty(this, "_image", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _beforeChanged() { super._beforeChanged(), this._clear = !0, this.isDirty("src") && this._load(); const e = this.get("canvas"); e && (this.set("width", e.width), this.set("height", e.height)) } _draw() { super._draw(); const e = this._image; if (e) { const t = this.get("width", 100), i = this.get("height", 100), s = this.get("fit", "image"); let a = 0, r = 0; "pattern" == s ? (a = t, r = i) : (a = e.width, r = e.height, "image" == s && (this.set("width", a), this.set("height", r))); let n = 0, o = 0; this.get("centered", !0) && (n = t / 2 - a / 2, o = i / 2 - r / 2), this._display.image(e, a, r, n, o) } const t = this.get("canvas"); t && this._display.image(t, t.width, t.height, 0, 0) } _load() { const e = this.get("src"); if (e) { const t = new Image; t.src = e, t.decode().then((() => { this._image = t, this._draw(), this.events.isEnabled("loaded") && this.events.dispatch("loaded", { type: "loaded", target: this }) })).catch((e => { })) } } } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "PicturePattern" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Pattern.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js": (e, t, i) => { i.r(t), i.d(t, { AnimationState: () => s, AnimationTime: () => b, colorInterpolate: () => p, defaultInterpolate: () => d, getInterpolate: () => g, normalize: () => c, percentInterpolate: () => m, range: () => u, waitForAnimations: () => h }); var s, a = i("./node_modules/tslib/tslib.es6.mjs"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"); function h(e) { return (0, a.__awaiter)(this, void 0, void 0, (function* () { if (void 0 !== e) { const t = []; l.each(e, ((e, i) => { t.push(i.waitForStop()) })), yield Promise.all(t) } })) } function c(e, t, i) { return t === i ? 0 : Math.min(Math.max(1 / (i - t) * (e - t), 0), 1) } function u(e, t, i) { return t + e * (i - t) } function d(e, t, i) { return e >= 1 ? i : t } function m(e, t, i) { return new r.Percent(u(e, t.percent, i.percent)) } function p(e, t, i) { return n.Color.interpolate(e, t, i) } function g(e, t) { return "number" == typeof e && "number" == typeof t ? u : e instanceof r.Percent && t instanceof r.Percent ? m : e instanceof n.Color && t instanceof n.Color ? p : d } !function (e) { e[e.Stopped = 0] = "Stopped", e[e.Playing = 1] = "Playing", e[e.Paused = 2] = "Paused" }(s || (s = {})); class b { constructor(e, t) { Object.defineProperty(this, "_entity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_duration", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_playingDuration", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "_startingTime", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "_current", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_from", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_to", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new o.EventDispatcher }), Object.defineProperty(this, "easing", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._entity = e, this._duration = t } _stopEvent() { const e = "stopped"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }) } _runAnimation(e) { if (null !== this._playingDuration) { if (null === this._startingTime) return this._startingTime = e, s.Playing; { const t = (e - this._startingTime) / this._playingDuration; if (t >= 1) { this._playingDuration = null, this._startingTime = null, this._from = this._to, this._current = this._to, this._entity.markDirty(), this._stopEvent(); const e = "ended"; return this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), s.Stopped } { this._current = u(t, this._from, this._to), this._entity.markDirty(); const e = "progress"; return this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this, progress: t }), s.Playing } } } return s.Stopped } _play() { if (this._from = this._current, null === this._playingDuration) { this._entity._root._addAnimation(this); const e = "started"; this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }) } else this._startingTime = null; this._playingDuration = Math.abs(this._to - this._from) * this._duration } get duration() { return this._duration } set duration(e) { this._duration !== e && (this._duration = e, 0 === e ? this.jumpTo(this._to) : this._current !== this._to && this._play()) } get current() { return this.easing ? this.easing(this._current) : this._current } stop() { this.jumpTo(this._current) } jumpTo(e) { this._current !== e && this._entity.markDirty(), null !== this._playingDuration && this._stopEvent(), this._playingDuration = null, this._startingTime = null, this._current = e, this._from = e, this._to = e } tweenTo(e) { this._current === e || 0 === this._duration ? this.jumpTo(e) : this._to !== e && (this._to = e, this._play()) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js": (e, t, i) => { i.r(t), i.d(t, { add: () => y, any: () => r, copy: () => T, each: () => o, eachContinue: () => h, eachReverse: () => l, find: () => S, findIndex: () => C, findIndexReverse: () => O, findMap: () => M, findReverse: () => A, first: () => d, getFirstSortedIndex: () => R, getSortedIndex: () => E, has: () => P, indexOf: () => a, insert: () => m, insertIndex: () => k, keepIf: () => I, last: () => u, map: () => n, move: () => f, pushAll: () => g, pushOne: () => v, remove: () => b, removeFirst: () => _, removeIndex: () => j, replace: () => x, setIndex: () => p, shiftLeft: () => c, shuffle: () => L, slice: () => D, toArray: () => w }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); function a(e, t) { const i = e.length; for (let s = 0; s < i; ++s)if (e[s] === t) return s; return -1 } function r(e, t) { const i = e.length; for (let s = 0; s < i; ++s)if (t(e[s])) return !0; return !1 } function n(e, t) { const i = e.length, s = new Array(i); for (let a = 0; a < i; ++a)s[a] = t(e[a], a); return s } function o(e, t) { const i = e.length; for (let s = 0; s < i; ++s)t(e[s], s) } function l(e, t) { let i = e.length; for (; i > 0;)--i, t(e[i], i) } function h(e, t) { const i = e.length; for (let s = 0; s < i && t(e[s], s); ++s); } function c(e, t) { const i = e.length; for (let s = t; s < i; ++s)e[s - t] = e[s]; e.length = i - t } function u(e) { const t = e.length; return t ? e[t - 1] : void 0 } function d(e) { return e[0] } function m(e, t, i) { i = Math.max(0, Math.min(i, e.length)), e.splice(i, 0, t) } function p(e, t, i) { b(e, t), m(e, t, i) } function g(e, t) { const i = t.length; for (let s = 0; s < i; ++s)e.push(t[s]) } function b(e, t) { let i = !1, s = 0; for (; ;) { if (s = e.indexOf(t, s), -1 === s) return i; i = !0, e.splice(s, 1) } } function _(e, t) { let i = e.indexOf(t); return -1 !== i && (e.splice(i, 1), !0) } function f(e, t, i) { let s = a(e, t); -1 !== s && j(e, s), null == i ? e.push(t) : k(e, i, t) } function y(e, t, i) { s.isNumber(i) ? 0 === i ? e.unshift(t) : e.splice(i, 0, t) : e.push(t) } function v(e, t) { -1 === e.indexOf(t) && e.push(t) } function x(e, t, i) { let a = e.indexOf(t); -1 !== a && e.splice(a, 1), s.isNumber(i) ? e.splice(i, 0, t) : e.push(t) } function w(e) { return Array.isArray(e) ? e : [e] } function P(e, t) { return -1 !== a(e, t) } function T(e) { const t = e.length, i = new Array(t); for (let s = 0; s < t; ++s)i[s] = e[s]; return i } function D(e, t, i = e.length) { const s = new Array(i - t); for (let a = t; a < i; ++a)s[a - t] = e[a]; return s } function k(e, t, i) { e.splice(t, 0, i) } function j(e, t) { e.splice(t, 1) } function C(e, t) { const i = e.length; for (let s = 0; s < i; ++s)if (t(e[s], s)) return s; return -1 } function O(e, t) { let i = e.length; for (; i > 0;)if (--i, t(e[i], i)) return i; return -1 } function S(e, t) { const i = C(e, t); if (-1 !== i) return e[i] } function A(e, t) { const i = O(e, t); if (-1 !== i) return e[i] } function M(e, t) { const i = e.length; for (let s = 0; s < i; ++s) { const i = t(e[s], s); if (void 0 !== i) return i } } function L(e) { let t, i, s = e.length; for (; 0 !== s;)i = Math.floor(Math.random() * s), s -= 1, t = e[s], e[s] = e[i], e[i] = t } function E(e, t) { let i = 0, s = e.length, a = !1; for (; i < s;) { const r = i + s >> 1, n = t(e[r]); n < 0 ? i = r + 1 : 0 === n ? (a = !0, i = r + 1) : s = r } return { found: a, index: a ? i - 1 : i } } function R(e, t) { let i = 0, s = e.length, a = !1; for (; i < s;) { const r = i + s >> 1, n = t(e[r]); n < 0 ? i = r + 1 : 0 === n ? (a = !0, s = r) : s = r } return { found: a, index: i } } function I(e, t) { let i = e.length; for (; i > 0;)--i, t(e[i]) || e.splice(i, 1) } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Children.js": (e, t, i) => { i.r(t), i.d(t, { Children: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); class r extends s.List { constructor(e) { super(), Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_container", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_events", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._container = e, this._events = this.events.onAll((e => { if ("clear" === e.type) a.each(e.oldValues, (e => { this._onRemoved(e) })); else if ("push" === e.type) this._onInserted(e.newValue); else if ("setIndex" === e.type) this._onRemoved(e.oldValue), this._onInserted(e.newValue, e.index); else if ("insertIndex" === e.type) this._onInserted(e.newValue, e.index); else if ("removeIndex" === e.type) this._onRemoved(e.oldValue); else { if ("moveIndex" !== e.type) throw new Error("Unknown IListEvent type"); this._onRemoved(e.value), this._onInserted(e.value, e.newIndex) } })) } _onInserted(e, t) { e._setParent(this._container, !0); const i = this._container._childrenDisplay; void 0 === t ? i.addChild(e._display) : i.addChildAt(e._display, t) } _onRemoved(e) { this._container._childrenDisplay.removeChild(e._display), this._container.markDirtyBounds(), this._container.markDirty() } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this._events.dispose(), a.each(this.values, (e => { e.dispose() }))) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js": (e, t, i) => { i.r(t), i.d(t, { Color: () => h, color: () => l, rgba2hex: () => o }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); function n(e) { return "#" === e[0] && (e = e.substr(1)), 3 == e.length && (e = e[0].repeat(2) + e[1].repeat(2) + e[2].repeat(2)), parseInt(e, 16) } function o(e) { let t = (e = e.replace(/[ ]/g, "")).match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i); if (t) t.push("1"); else if (t = e.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i), !t) return 0; let i = ""; for (let e = 1; e <= 3; e++) { let s = parseInt(t[e]).toString(16); 1 == s.length && (s = "0" + s), i += s } return n(i) } function l(e) { return h.fromAny(e) } class h { constructor(e) { Object.defineProperty(this, "_hex", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._hex = 0 | e } get hex() { return this._hex } get r() { return this._hex >>> 16 } get g() { return this._hex >> 8 & 255 } get b() { return 255 & this._hex } toCSS(e = 1) { return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + e + ")" } toCSSHex() { return "#" + a.padString(this.r.toString(16), 2) + a.padString(this.g.toString(16), 2) + a.padString(this.b.toString(16), 2) } toHSL(e = 1) { return a.rgbToHsl({ r: this.r, g: this.g, b: this.b, a: e }) } static fromHSL(e, t, i) { const s = a.hslToRgb({ h: e, s: t, l: i }); return this.fromRGB(s.r, s.g, s.b) } toString() { return this.toCSSHex() } static fromHex(e) { return new h(e) } static fromRGB(e, t, i) { return new h((0 | i) + (t << 8) + (e << 16)) } static fromString(e) { return new h(n(e)) } static fromCSS(e) { return new h(o(e)) } static fromAny(e) { if (r.isString(e)) { if ("#" == e[0]) return h.fromString(e); if ("rgb" == e.substr(0, 3)) return h.fromCSS(e) } else { if (r.isNumber(e)) return h.fromHex(e); if (e instanceof h) return h.fromHex(e.hex) } throw new Error("Unknown color syntax: " + e) } static alternative(e, t, i) { const s = a.alternativeColor({ r: e.r, g: e.g, b: e.b }, t ? { r: t.r, g: t.g, b: t.b } : void 0, i ? { r: i.r, g: i.g, b: i.b } : void 0); return this.fromRGB(s.r, s.g, s.b) } static interpolate(e, t, i, a = "rgb") { if ("hsl" == a) { const a = t.toHSL(), r = i.toHSL(); return h.fromHSL((0, s.range)(e, a.h, r.h), (0, s.range)(e, a.s, r.s), (0, s.range)(e, a.l, r.l)) } return h.fromRGB((0, s.range)(e, t.r, i.r), (0, s.range)(e, t.g, i.g), (0, s.range)(e, t.b, i.b)) } static lighten(e, t) { const i = a.lighten({ r: e.r, g: e.g, b: e.b }, t); return h.fromRGB(i.r, i.g, i.b) } static brighten(e, t) { const i = a.brighten({ r: e.r, g: e.g, b: e.b }, t); return h.fromRGB(i.r, i.g, i.b) } static saturate(e, t) { const i = a.saturate({ r: e.r, g: e.g, b: e.b }, t); return h.fromRGB(i.r, i.g, i.b) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/ColorSet.js": (e, t, i) => { i.r(t), i.d(t, { ColorSet: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"); class r extends s.Entity { _afterNew() { super._afterNewApplyThemes(), this._dirty.colors = !1 } _beforeChanged() { this.isDirty("colors") && this.reset() } generateColors() { this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1); const e = this.getPrivate("currentPass"), t = this.get("colors", [this.get("baseColor", a.Color.fromHex(16711680))]); this.getPrivate("numColors") || this.setPrivate("numColors", t.length); const i = this.getPrivate("numColors"), s = this.get("passOptions"), r = this.get("reuse"); for (let n = 0; n < i; n++)if (r) t.push(t[n]); else { const i = t[n].toHSL(); let r = i.h + (s.hue || 0) * e; for (; r > 1;)r -= 1; let o = i.s + (s.saturation || 0) * e; o > 1 && (o = 1), o < 0 && (o = 0); let l = i.l + (s.lightness || 0) * e; for (; l > 1;)l -= 1; t.push(a.Color.fromHSL(r, o, l)) } } getIndex(e) { const t = this.get("colors", []), i = this.get("saturation"); return e >= t.length ? (this.generateColors(), this.getIndex(e)) : null != i ? a.Color.saturate(t[e], i) : t[e] } next() { let e = this.getPrivate("currentStep", this.get("startIndex", 0)); return this.setPrivate("currentStep", e + this.get("step", 1)), this.getIndex(e) } reset() { this.setPrivate("currentStep", this.get("startIndex", 0)), this.setPrivate("currentPass", 0) } } Object.defineProperty(r, "className", { enumerable: !0, configurable: !0, writable: !0, value: "ColorSet" }), Object.defineProperty(r, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Entity.classNames.concat([r.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Data.js": (e, t, i) => { i.r(t), i.d(t, { JsonData: () => r, ListData: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/List.js"); class a extends s.List { constructor() { super(...arguments), Object.defineProperty(this, "processor", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } incrementRef() { } decrementRef() { } _onPush(e) { this.processor && this.processor.processRow(e), super._onPush(e) } _onInsertIndex(e, t) { this.processor && this.processor.processRow(t), super._onInsertIndex(e, t) } _onSetIndex(e, t, i) { this.processor && this.processor.processRow(i), super._onSetIndex(e, t, i) } } class r { constructor(e) { Object.defineProperty(this, "processor", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_value", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._value = e } incrementRef() { } decrementRef() { } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/DateFormatter.js": (e, t, i) => { i.r(t), i.d(t, { DateFormatter: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class l extends s.Entity { _setDefaults() { this._setDefault("capitalize", !0), this._setDefault("dateFormat", "yyyy-MM-dd"), super._setDefaults() } _beforeChanged() { super._beforeChanged() } format(e, t, i = !1) { let s; void 0 !== t && "" !== t || (t = this.get("dateFormat", "yyyy-MM-dd")); let a = e; if (n.isObject(t)) try { const e = this.get("intlLocales"); return e ? new Intl.DateTimeFormat(e, t).format(a) : new Intl.DateTimeFormat(void 0, t).format(a) } catch (e) { return "Invalid" } let r = this.parseFormat(t); const o = this._root.timezone; return !o || this._root.utc || i || (a = o.convertLocal(a)), n.isNumber(a.getTime()) ? (s = this.applyFormat(a, r, i), this.get("capitalize") && (s = s.replace(/^.{1}/, s.substr(0, 1).toUpperCase())), s) : "Invalid date" } applyFormat(e, t, i = !1) { let s, a, l, h, c, u, d, m, p = t.template, g = e.getTime(); this._root.utc && !i ? (s = e.getUTCFullYear(), a = e.getUTCMonth(), l = e.getUTCDay(), h = e.getUTCDate(), c = e.getUTCHours(), u = e.getUTCMinutes(), d = e.getUTCSeconds(), m = e.getUTCMilliseconds()) : (s = e.getFullYear(), a = e.getMonth(), l = e.getDay(), h = e.getDate(), c = e.getHours(), u = e.getMinutes(), d = e.getSeconds(), m = e.getMilliseconds()); for (let i = 0, b = t.parts.length; i < b; i++) { let b = ""; switch (t.parts[i]) { case "G": b = this._t(s < 0 ? "_era_bc" : "_era_ad"); break; case "yyyy": b = Math.abs(s).toString(), s < 0 && (b += this._t("_era_bc")); break; case "yyy": case "yy": case "y": b = Math.abs(s).toString().substr(-t.parts[i].length), s < 0 && (b += this._t("_era_bc")); break; case "YYYY": case "YYY": case "YY": case "Y": let n = o.getWeekYear(e, this._root.utc); b = "YYYY" == t.parts[i] ? Math.abs(n).toString() : Math.abs(n).toString().substr(-t.parts[i].length), n < 0 && (b += this._t("_era_bc")); break; case "u": case "F": case "g": break; case "q": b = "" + Math.ceil((e.getMonth() + 1) / 3); break; case "MMMMM": b = this._t(this._getMonth(a)).substr(0, 1); break; case "MMMM": b = this._t(this._getMonth(a)); break; case "MMM": b = this._t(this._getShortMonth(a)); break; case "MM": b = o.padString(a + 1, 2, "0"); break; case "M": b = (a + 1).toString(); break; case "ww": b = o.padString(o.getWeek(e, this._root.utc), 2, "0"); break; case "w": b = o.getWeek(e, this._root.utc).toString(); break; case "W": b = o.getMonthWeek(e, this._root.utc).toString(); break; case "dd": b = o.padString(h, 2, "0"); break; case "d": b = h.toString(); break; case "DD": case "DDD": b = o.padString(o.getYearDay(e, this._root.utc).toString(), t.parts[i].length, "0"); break; case "D": b = o.getYearDay(e, this._root.utc).toString(); break; case "t": b = this._root.language.translateFunc("_dateOrd").call(this, h); break; case "E": b = (l || 7).toString(); break; case "EE": b = o.padString((l || 7).toString(), 2, "0"); break; case "EEE": case "eee": b = this._t(this._getShortWeekday(l)); break; case "EEEE": case "eeee": b = this._t(this._getWeekday(l)); break; case "EEEEE": case "eeeee": b = this._t(this._getShortWeekday(l)).substr(0, 1); break; case "e": case "ee": b = (l - (this._root.locale.firstDayOfWeek || 1) + 1).toString(), "ee" == t.parts[i] && (b = o.padString(b, 2, "0")); break; case "a": b = c >= 12 ? this._t("PM") : this._t("AM"); break; case "aa": b = c >= 12 ? this._t("P.M.") : this._t("A.M."); break; case "aaa": b = c >= 12 ? this._t("P") : this._t("A"); break; case "h": b = o.get12Hours(c).toString(); break; case "hh": b = o.padString(o.get12Hours(c), 2, "0"); break; case "H": b = c.toString(); break; case "HH": b = o.padString(c, 2, "0"); break; case "K": b = o.get12Hours(c, 0).toString(); break; case "KK": b = o.padString(o.get12Hours(c, 0), 2, "0"); break; case "k": b = (c + 1).toString(); break; case "kk": b = o.padString(c + 1, 2, "0"); break; case "m": b = u.toString(); break; case "mm": b = o.padString(u, 2, "0"); break; case "s": b = d.toString(); break; case "ss": b = o.padString(d, 2, "0"); break; case "S": case "SS": case "SSS": b = Math.round(m / 1e3 * Math.pow(10, t.parts[i].length)).toString(); break; case "x": b = g.toString(); break; case "n": case "nn": case "nnn": b = o.padString(m, t.parts[i].length, "0"); break; case "z": b = o.getTimeZone(e, !1, !1, this._root.utc, this._root.timezone ? this._root.timezone.name : void 0).replace(/[+-]+[0-9]+$/, ""); break; case "zz": b = o.getTimeZone(e, !0, !1, this._root.utc, this._root.timezone ? this._root.timezone.name : void 0); break; case "zzz": b = o.getTimeZone(e, !1, !0, this._root.utc, this._root.timezone ? this._root.timezone.name : void 0).replace(/[+-]+[0-9]+$/, ""); break; case "zzzz": b = o.getTimeZone(e, !0, !0, this._root.utc, this._root.timezone ? this._root.timezone.name : void 0); break; case "Z": case "ZZ": let p = this._root.utc ? "UTC" : this._root.timezone; p instanceof r.Timezone && (p = p.name); const _ = p ? o.getTimezoneOffset(p) : e.getTimezoneOffset(); let f = Math.abs(_) / 60, y = Math.floor(f), v = 60 * f - 60 * y; this._root.utc && (y = 0, v = 0), "Z" == t.parts[i] ? (b = "GMT", b += _ > 0 ? "-" : "+", b += o.padString(y, 2) + ":" + o.padString(v, 2)) : (b = _ > 0 ? "-" : "+", b += o.padString(y, 2) + o.padString(v, 2)); break; case "i": b = e.toISOString(); break; case "I": b = e.toUTCString() }p = p.replace(n.PLACEHOLDER, b) } return p } parseFormat(e) { let t = { template: "", parts: [] }, i = a.TextFormatter.chunk(e, !0); for (let e = 0; e < i.length; e++) { let s = i[e]; if ("value" === s.type) { if (s.text.match(/^date$/i)) { let e = this.get("dateFormat", "yyyy-MM-dd"); n.isString(e) || (e = "yyyy-MM-dd"), s.text = e } let e = s.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g); if (e) for (let i = 0; i < e.length; i++)t.parts.push(e[i]), s.text = s.text.replace(e[i], n.PLACEHOLDER) } t.template += s.text } return t } _months() { return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] } _getMonth(e) { return this._months()[e] } _shortMonths() { return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"] } _getShortMonth(e) { return this._shortMonths()[e] } _weekdays() { return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] } _getWeekday(e) { return this._weekdays()[e] } _shortWeekdays() { return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] } _getShortWeekday(e) { return this._shortWeekdays()[e] } parse(e, t) { if (e instanceof Date) return e; if (n.isNumber(e)) return new Date(e); if ("x" == t) return new Date(parseInt(e)); let i; n.isString(e) || (e = e.toString()); let s = ""; t = (t = o.cleanFormat(t)).substr(0, e.length); let a = this.parseFormat(t), r = { year: -1, year3: -1, year2: -1, year1: -1, month: -1, monthShort: -1, monthLong: -1, weekdayShort: -1, weekdayLong: -1, day: -1, yearDay: -1, week: -1, hourBase0: -1, hour12Base0: -1, hourBase1: -1, hour12Base1: -1, minute: -1, second: -1, millisecond: -1, millisecondDigits: -1, am: -1, zone: -1, timestamp: -1, iso: -1 }, l = { year: 1970, month: 0, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0, timestamp: null, offset: 0, utc: this._root.utc }, h = 0, c = 0; for (let e = 0; e < a.parts.length; e++) { switch (c = e + h + 1, a.parts[e]) { case "yyyy": case "YYYY": s += "([0-9]{4})", r.year = c; break; case "yyy": case "YYY": s += "([0-9]{3})", r.year3 = c; break; case "yy": case "YY": s += "([0-9]{2})", r.year2 = c; break; case "y": case "Y": s += "([0-9]{1})", r.year1 = c; break; case "MMMM": s += "(" + this.getStringList(this._months()).join("|") + ")", r.monthLong = c; break; case "MMM": s += "(" + this.getStringList(this._shortMonths()).join("|") + ")", r.monthShort = c; break; case "MM": case "M": s += "([0-9]{2}|[0-9]{1})", r.month = c; break; case "ww": case "w": s += "([0-9]{2}|[0-9]{1})", r.week = c; break; case "dd": case "d": s += "([0-9]{2}|[0-9]{1})", r.day = c; break; case "DDD": case "DD": case "D": s += "([0-9]{3}|[0-9]{2}|[0-9]{1})", r.yearDay = c; break; case "dddd": s += "(" + this.getStringList(this._weekdays()).join("|") + ")", r.weekdayLong = c; break; case "ddd": s += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")", r.weekdayShort = c; break; case "aaa": case "aa": case "a": s += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")", r.am = c; break; case "hh": case "h": s += "([0-9]{2}|[0-9]{1})", r.hour12Base1 = c; break; case "HH": case "H": s += "([0-9]{2}|[0-9]{1})", r.hourBase0 = c; break; case "KK": case "K": s += "([0-9]{2}|[0-9]{1})", r.hour12Base0 = c; break; case "kk": case "k": s += "([0-9]{2}|[0-9]{1})", r.hourBase1 = c; break; case "mm": case "m": s += "([0-9]{2}|[0-9]{1})", r.minute = c; break; case "ss": case "s": s += "([0-9]{2}|[0-9]{1})", r.second = c; break; case "SSS": case "SS": case "S": s += "([0-9]{3}|[0-9]{2}|[0-9]{1})", r.millisecond = c, r.millisecondDigits = a.parts[e].length; break; case "nnn": case "nn": case "n": s += "([0-9]{3}|[0-9]{2}|[0-9]{1})", r.millisecond = c; break; case "x": s += "([0-9]{1,})", r.timestamp = c; break; case "Z": s += "GMT([-+]+[0-9]{2}:[0-9]{2})", r.zone = c; break; case "ZZ": s += "([\\-+]+[0-9]{2}[0-9]{2})", r.zone = c; break; case "i": s += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)", r.iso = c, h += 7; break; case "G": case "YYYY": case "YYY": case "YY": case "Y": case "MMMMM": case "W": case "EEEEE": case "EEEE": case "EEE": case "EE": case "E": case "eeeee": case "eeee": case "eee": case "ee": case "e": case "zzzz": case "zzz": case "zz": case "z": case "t": h-- }s += "[^0-9]*" } let u = new RegExp(s), d = e.match(u); if (d) { if (r.year > -1 && (l.year = parseInt(d[r.year])), r.year3 > -1) { let e = parseInt(d[r.year3]); e += 1e3, l.year = e } if (r.year2 > -1) { let e = parseInt(d[r.year2]); e += e > 50 ? 1e3 : 2e3, l.year = e } if (r.year1 > -1) { let e = parseInt(d[r.year1]); e = 10 * Math.floor((new Date).getFullYear() / 10) + e, l.year = e } if (r.monthLong > -1 && (l.month = this.resolveMonth(d[r.monthLong])), r.monthShort > -1 && (l.month = this.resolveShortMonth(d[r.monthShort])), r.month > -1 && (l.month = parseInt(d[r.month]) - 1), r.week > -1 && -1 === r.day && (l.month = 0, l.day = o.getDayFromWeek(parseInt(d[r.week]), l.year, 1, this._root.utc)), r.day > -1 && (l.day = parseInt(d[r.day])), r.yearDay > -1 && (l.month = 0, l.day = parseInt(d[r.yearDay])), r.hourBase0 > -1 && (l.hour = parseInt(d[r.hourBase0])), r.hourBase1 > -1 && (l.hour = parseInt(d[r.hourBase1]) - 1), r.hour12Base0 > -1) { let e = parseInt(d[r.hour12Base0]); 11 == e && (e = 0), r.am > -1 && !this.isAm(d[r.am]) && (e += 12), l.hour = e } if (r.hour12Base1 > -1) { let e = parseInt(d[r.hour12Base1]); 12 == e && (e = 0), r.am > -1 && !this.isAm(d[r.am]) && (e += 12), l.hour = e } if (r.minute > -1 && (l.minute = parseInt(d[r.minute])), r.second > -1 && (l.second = parseInt(d[r.second])), r.millisecond > -1) { let e = parseInt(d[r.millisecond]); 2 == r.millisecondDigits ? e *= 10 : 1 == r.millisecondDigits && (e *= 100), l.millisecond = e } if (r.timestamp > -1) { l.timestamp = parseInt(d[r.timestamp]); const e = new Date(l.timestamp); l.year = e.getUTCFullYear(), l.month = e.getUTCMonth(), l.day = e.getUTCDate(), l.hour = e.getUTCHours(), l.minute = e.getUTCMinutes(), l.second = e.getUTCSeconds(), l.millisecond = e.getUTCMilliseconds() } r.zone > -1 && (l.offset = this.resolveTimezoneOffset(new Date(l.year, l.month, l.day), d[r.zone])), r.iso > -1 && (l.year = n.toNumber(d[r.iso + 0]), l.month = n.toNumber(d[r.iso + 1]) - 1, l.day = n.toNumber(d[r.iso + 2]), l.hour = n.toNumber(d[r.iso + 3]), l.minute = n.toNumber(d[r.iso + 4]), l.second = n.toNumber(d[r.iso + 5]), l.millisecond = n.toNumber(d[r.iso + 6]), "Z" == d[r.iso + 7] || "z" == d[r.iso + 7] ? l.utc = !0 : "" != d[r.iso + 7] && (l.offset = this.resolveTimezoneOffset(new Date(l.year, l.month, l.day), d[r.iso + 7]))), i = l.utc ? new Date(Date.UTC(l.year, l.month, l.day, l.hour, l.minute, l.second, l.millisecond)) : new Date(l.year, l.month, l.day, l.hour, l.minute + l.offset, l.second, l.millisecond) } else i = new Date(e); return i } resolveTimezoneOffset(e, t) { if (t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/)) { let i = t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/), s = i[1], a = i[2], r = i[3], n = 60 * parseInt(a) + parseInt(r); return "+" == s && (n *= -1), n - (e || new Date).getTimezoneOffset() } return 0 } resolveMonth(e) { let t = this._months().indexOf(e); return t > -1 || !this._root.language.isDefault() && (t = this._root.language.translateAll(this._months()).indexOf(e), t > -1) ? t : 0 } resolveShortMonth(e) { let t = this._shortMonths().indexOf(e); return t > -1 ? t : (t = this._months().indexOf(e), t > -1 || this._root.language && !this._root.language.isDefault() && (t = this._root.language.translateAll(this._shortMonths()).indexOf(e), t > -1) ? t : 0) } isAm(e) { return this.getStringList(["AM", "A.M.", "A"]).indexOf(e.toUpperCase()) > -1 } getStringList(e) { let t = []; for (let i = 0; i < e.length; i++)this._root.language ? t.push(o.escapeForRgex(this._t(e[i]))) : t.push(o.escapeForRgex(e[i])); return t } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js": (e, t, i) => { i.r(t), i.d(t, { ArrayDisposer: () => n, CounterDisposer: () => h, Disposer: () => r, DisposerClass: () => a, MultiDisposer: () => o, MutableValueDisposer: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); class a { constructor() { Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._disposed = !1 } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this._dispose()) } } class r { constructor(e) { Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_dispose", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._disposed = !1, this._dispose = e } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this._dispose()) } } class n extends a { constructor() { super(...arguments), Object.defineProperty(this, "_disposers", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } _dispose() { s.each(this._disposers, (e => { e.dispose() })) } } class o extends a { constructor(e) { super(), Object.defineProperty(this, "_disposers", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._disposers = e } _dispose() { s.each(this._disposers, (e => { e.dispose() })) } get disposers() { return this._disposers } } class l extends a { constructor() { super(...arguments), Object.defineProperty(this, "_disposer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_value", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }) } _dispose() { null != this._disposer && (this._disposer.dispose(), this._disposer = void 0) } get() { return this._value } set(e, t) { null != this._disposer && this._disposer.dispose(), this._disposer = t, this._value = e } reset() { this.set(void 0, void 0) } } class h extends r { constructor() { super(...arguments), Object.defineProperty(this, "_counter", { enumerable: !0, configurable: !0, writable: !0, value: 0 }) } increment() { return ++this._counter, new r((() => { --this._counter, 0 === this._counter && this.dispose() })) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Draw.js": (e, t, i) => { i.r(t), i.d(t, { clear: () => o, line: () => r, moveTo: () => n, segmentedLine: () => a, smoothedLine: () => h, smoothedSegmentedline: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); function a(e, t) { for (let i = 0, s = t.length; i < s; i++) { const s = t[i]; if (s.length > 0) { let t = s[0]; if (t.length > 0) { let i = t[0]; e.moveTo(i.x, i.y); for (let t = 0, i = s.length; t < i; t++)r(e, s[t]) } } } } function r(e, t) { for (let i = 0, s = t.length; i < s; i++) { const s = t[i]; e.lineTo(s.x, s.y) } } function n(e, t) { e.moveTo(t.x, t.y) } function o(e) { e.clear() } function l(e, t, i, s) { for (let a = 0, r = t.length; a < r; a++) { const r = t[a]; if (r.length > 0) { let t = r[0]; if (t.length > 0) { let a = t[0]; e.moveTo(a.x, a.y); for (let t = 0, a = r.length; t < a; t++) { const a = r[t]; a.length > 0 && e.lineTo(a[0].x, a[0].y), h(e, a, i, s) } } } } } function h(e, t, i, a) { for (let e = t.length - 1; e > 0; e--) { let i = t[e], s = t[e - 1]; Math.abs(i.x - s.x) < .1 && Math.abs(i.y - s.y) < .1 && t.splice(e - 1, 1) } if (t.length < 3 || i >= 1 && a >= 1) return void r(e, t); i = 1 - i + 1e-5, a = 1 - a + 1e-5; let n = t[0], o = t[t.length - 1], l = !1; s.round(n.x, 3) == s.round(o.x) && s.round(n.y) == s.round(o.y) && (l = !0); for (let r = 0, n = t.length - 1; r < n; r++) { let o = t[r - 1], h = t[r], c = t[r + 1], u = t[r + 2]; 0 === r ? o = l ? t[n - 2] : t[0] : r == n - 1 && (u = l ? t[1] : c); let d = s.getCubicControlPointA(o, h, c, i, a), m = s.getCubicControlPointB(h, c, u, i, a); e.bezierCurveTo(d.x, d.y, m.x, m.y, c.x, c.y) } return "" } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/DurationFormatter.js": (e, t, i) => { i.r(t), i.d(t, { DurationFormatter: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class l extends s.Entity { constructor() { super(...arguments), Object.defineProperty(this, "_unitAliases", { enumerable: !0, configurable: !0, writable: !0, value: { Y: "y", D: "d", H: "h", K: "h", k: "h", n: "S" } }) } _setDefaults() { const e = "_duration_millisecond", t = "_duration_second", i = "_duration_minute", s = "_duration_hour", a = "_duration_day", r = "_duration_week", n = "_duration_month", o = "_minute", l = "_hour", h = "_day", c = "_week", u = "_week", d = "_year"; this._setDefault("negativeBase", 0), this._setDefault("baseUnit", "second"), this._setDefault("durationFormats", { millisecond: { millisecond: this._t(e), second: this._t(e + "_second"), minute: this._t(e + o), hour: this._t(e + l), day: this._t(e + h), week: this._t(e + c), month: this._t(e + u), year: this._t(e + d) }, second: { second: this._t(t), minute: this._t(t + o), hour: this._t(t + l), day: this._t(t + h), week: this._t(t + c), month: this._t(t + u), year: this._t(t + d) }, minute: { minute: this._t(i), hour: this._t(i + l), day: this._t(i + h), week: this._t(i + c), month: this._t(i + u), year: this._t(i + d) }, hour: { hour: this._t(s), day: this._t(s + h), week: this._t(s + c), month: this._t(s + u), year: this._t(s + d) }, day: { day: this._t(a), week: this._t(a + c), month: this._t(a + u), year: this._t(a + d) }, week: { week: this._t(r), month: this._t(r + u), year: this._t(r + d) }, month: { month: this._t(n), year: this._t(n + d) }, year: { year: this._t("_duration_year") } }), super._setDefaults() } _beforeChanged() { super._beforeChanged() } format(e, t, i) { let s = i || this.get("baseUnit"); void 0 !== t && "" !== t || (t = null != this.get("durationFormat") ? this.get("durationFormat") : this.getFormat(o.toNumber(e), void 0, s)), t = n.cleanFormat(t); let a, r = this.parseFormat(t, s), l = Number(e); a = l > this.get("negativeBase") ? r.positive : l < this.get("negativeBase") ? r.negative : r.zero; let h = this.applyFormat(l, a); return "" !== a.color && (h = "[" + a.color + "]" + h + "[/]"), h } parseFormat(e, t) { let i = t || this.get("baseUnit"), s = { positive: { color: "", template: "", parts: [], source: "", baseUnit: i, parsed: !1, absolute: !1 }, negative: { color: "", template: "", parts: [], source: "", baseUnit: i, parsed: !1, absolute: !1 }, zero: { color: "", template: "", parts: [], source: "", baseUnit: i, parsed: !1, absolute: !1 } }, n = (e = e.replace("||", o.PLACEHOLDER2)).split("|"); return s.positive.source = n[0], void 0 === n[2] ? s.zero = s.positive : s.zero.source = n[2], void 0 === n[1] ? s.negative = s.positive : s.negative.source = n[1], r.each(s, ((e, t) => { if (t.parsed) return; let i = t.source, s = []; s = t.source.match(/^\[([^\]]*)\]/), s && s.length && "" !== s[0] && (i = t.source.substr(s[0].length), t.color = s[1]); let r = a.TextFormatter.chunk(i, !0); for (let e = 0; e < r.length; e++) { let i = r[e]; if (i.text = i.text.replace(o.PLACEHOLDER2, "|"), "value" === i.type) { i.text.match(/[yYMdDwhHKkmsSn]+a/) && (t.absolute = !0, i.text = i.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1")); let e = i.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g); if (e) for (let s = 0; s < e.length; s++)null == e[s] && (e[s] = this._unitAliases[e[s]]), t.parts.push(e[s]), i.text = i.text.replace(e[s], o.PLACEHOLDER) } t.template += i.text } t.parsed = !0 })), s } applyFormat(e, t) { let i = !t.absolute && e < this.get("negativeBase"); e = Math.abs(e); let s = this.toTimeStamp(e, t.baseUnit), a = t.template; for (let e = 0, i = t.parts.length; e < i; e++) { let r, l = t.parts[e], h = this._toTimeUnit(l.substr(0, 1)), c = l.length; const u = this._getUnitValue(h); r = e < i - 1 ? Math.floor(s / u) : Math.round(s / u), a = a.replace(o.PLACEHOLDER, n.padString(r, c, "0")), s -= r * u } return i && (a = "-" + a), a } toTimeStamp(e, t) { return e * this._getUnitValue(t) } _toTimeUnit(e) { switch (e) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": return "hour"; case "d": return "day"; case "w": return "week"; case "M": return "month"; case "y": return "year" } } getFormat(e, t, i) { if (null != this.get("durationFormat")) return this.get("durationFormat"); if (i || (i = this.get("baseUnit")), null != t && e != t) { e = Math.abs(e), t = Math.abs(t); let s = this.getValueUnit(Math.max(e, t), i); return this.get("durationFormats")[i][s] } { let t = this.getValueUnit(e, i); return this.get("durationFormats")[i][t] } } getValueUnit(e, t) { let i; t || (t = this.get("baseUnit")); let s = this.getMilliseconds(e, t); return r.eachContinue(this._getUnitValues(), ((e, a) => { if (e == t || i) { if (s / a <= 1) return i || (i = e), !1; i = e } return !0 })), i } getMilliseconds(e, t) { return t || (t = this.get("baseUnit")), e * this._getUnitValue(t) } _getUnitValue(e) { return this._getUnitValues()[e] } _getUnitValues() { return { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 2592e6, year: 31536e6 } } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js": (e, t, i) => { i.r(t), i.d(t, { bounce: () => T, circle: () => c, cubic: () => n, elastic: () => O, exp: () => l, inOut: () => m, linear: () => a, out: () => d, pow: () => o, quad: () => r, sine: () => h, yoyo: () => u }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js"); function a(e) { return e } function r(e) { return e * e } function n(e) { return e * e * e } function o(e, t) { return Math.pow(e, t) } function l(e) { return Math.pow(2, 10 * e - 10) } function h(e) { return 1 - Math.cos(e * s.HALFPI) } function c(e) { return 1 - Math.sqrt(1 - e * e) } function u(e) { return function (t) { return e(t < .5 ? 2 * t : 2 * (1 - t)) } } function d(e) { return function (t) { return 1 - e(1 - t) } } function m(e) { return function (t) { return t <= .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2 } } let p = 4 / 11, g = 6 / 11, b = 8 / 11, _ = 3 / 4, f = 9 / 11, y = 10 / 11, v = 15 / 16, x = 21 / 22, w = 63 / 64, P = 1 / p / p; function T(e) { return 1 - function (e) { return e < p ? P * e * e : e < b ? P * (e -= g) * e + _ : e < y ? P * (e -= f) * e + v : P * (e -= x) * e + w }(1 - e) } let D = 2 * Math.PI, k = 1, j = .3 / D, C = Math.asin(1 / k) * j; function O(e) { let t = e; return k * Math.pow(2, 10 * --t) * Math.sin((C - t) / j) } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js": (e, t, i) => { i.r(t), i.d(t, { Adapters: () => d, Animation: () => m, Entity: () => b, Settings: () => g }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Animation.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/States.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/Registry.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js"); class d { constructor(e) { Object.defineProperty(this, "_entity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_callbacks", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_disabled", { enumerable: !0, configurable: !0, writable: !0, value: {} }), this._entity = e } add(e, t) { let i = this._callbacks[e]; return void 0 === i && (i = this._callbacks[e] = []), i.push(t), this._entity._markDirtyKey(e), new s.Disposer((() => { c.removeFirst(i, t) && this._entity._markDirtyKey(e) })) } remove(e) { const t = this._callbacks[e]; void 0 !== t && (delete this._callbacks[e], 0 !== t.length && this._entity._markDirtyKey(e)) } enable(e) { this._disabled[e] && (delete this._disabled[e], this._entity._markDirtyKey(e)) } disable(e) { this._disabled[e] || (this._disabled[e] = !0, this._entity._markDirtyKey(e)) } fold(e, t) { if (!this._disabled[e]) { const i = this._callbacks[e]; if (void 0 !== i) for (let s = 0, a = i.length; s < a; ++s)t = i[s](t, this._entity, e) } return t } } class m { constructor(e, t, i, s, n, o, l) { Object.defineProperty(this, "_animation", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_from", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_to", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_duration", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_easing", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_loops", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_interpolate", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_oldTime", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_time", { enumerable: !0, configurable: !0, writable: !0, value: 0 }), Object.defineProperty(this, "_stopped", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_playing", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new a.EventDispatcher }), this._animation = e, this._from = t, this._to = i, this._duration = s, this._easing = n, this._loops = o, this._interpolate = (0, r.getInterpolate)(t, i), this._oldTime = l } get to() { return this._to } get from() { return this._from } get playing() { return this._playing } get stopped() { return this._stopped } stop() { this._stopped || (this._stopped = !0, this._playing = !1, this.events.isEnabled("stopped") && this.events.dispatch("stopped", { type: "stopped", target: this })) } pause() { this._playing = !1, this._oldTime = null } play() { this._stopped || this._playing || (this._playing = !0, this._animation._startAnimation()) } get percentage() { return this._time / this._duration } waitForStop() { return new Promise(((e, t) => { if (this._stopped) e(); else { const t = () => { i.dispose(), e() }, i = this.events.on("stopped", t) } })) } _checkEnded() { return !(this._loops > 1) || (--this._loops, !1) } _run(e) { null !== this._oldTime && (this._time += e - this._oldTime, this._time > this._duration && (this._time = this._duration)), this._oldTime = e } _reset(e) { this._oldTime = e, this._time = 0 } _value(e) { return this._interpolate(this._easing(e), this._from, this._to) } } let p = 0; class g { constructor(e) { Object.defineProperty(this, "uid", { enumerable: !0, configurable: !0, writable: !0, value: ++p }), Object.defineProperty(this, "_settings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_privateSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_settingEvents", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_privateSettingEvents", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_prevSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_prevPrivateSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_animatingSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_animatingPrivateSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), Object.defineProperty(this, "_userProperties", { enumerable: !0, configurable: !0, writable: !0, value: {} }), this._settings = e } _checkDirty() { l.keys(this._settings).forEach((e => { this._userProperties[e] = !0, this._markDirtyKey(e) })) } resetUserSettings() { this._userProperties = {} } _runAnimation(e) { let t = r.AnimationState.Stopped; if (!this.isDisposed()) { let i = !1, s = !1; l.each(this._animatingSettings, ((t, a) => { if (a.stopped) this._stopAnimation(t); else if (a.playing) { a._run(e); const s = a.percentage; s >= 1 ? a._checkEnded() ? this.set(t, a._value(1)) : (i = !0, a._reset(e), this._set(t, a._value(1))) : (i = !0, this._set(t, a._value(s))) } else s = !0 })), l.each(this._animatingPrivateSettings, ((t, a) => { if (a.stopped) this._stopAnimationPrivate(t); else if (a.playing) { a._run(e); const s = a.percentage; s >= 1 ? a._checkEnded() ? this.setPrivate(t, a._value(1)) : (i = !0, a._reset(e), this._setPrivate(t, a._value(1))) : (i = !0, this._setPrivate(t, a._value(s))) } else s = !0 })), i ? t = r.AnimationState.Playing : s && (t = r.AnimationState.Paused) } return t } _markDirtyKey(e) { this.markDirty() } _markDirtyPrivateKey(e) { this.markDirty() } on(e, t) { let i = this._settingEvents[e]; return void 0 === i && (i = this._settingEvents[e] = []), i.push(t), new s.Disposer((() => { c.removeFirst(i, t), 0 === i.length && delete this._settingEvents[e] })) } off(e, t) { let i = this._settingEvents[e]; void 0 !== i && void 0 !== t ? c.removeFirst(i, t) : delete this._settingEvents[e] } onPrivate(e, t) { let i = this._privateSettingEvents[e]; return void 0 === i && (i = this._privateSettingEvents[e] = []), i.push(t), new s.Disposer((() => { c.removeFirst(i, t), 0 === i.length && delete this._privateSettingEvents[e] })) } offPrivate(e, t) { let i = this._privateSettingEvents[e]; void 0 !== i && void 0 !== t ? c.removeFirst(i, t) : delete this._privateSettingEvents[e] } getRaw(e, t) { const i = this._settings[e]; return void 0 !== i ? i : t } has(e) { return e in this._settings } get(e, t) { return this.getRaw(e, t) } _sendKeyEvent(e, t) { const i = this._settingEvents[e]; void 0 !== i && c.each(i, (i => { i(t, this, e) })) } _sendPrivateKeyEvent(e, t) { const i = this._privateSettingEvents[e]; void 0 !== i && c.each(i, (i => { i(t, this, e) })) } _setRaw(e, t, i) { this._prevSettings[e] = t, this._sendKeyEvent(e, i) } setRaw(e, t) { const i = this._settings[e]; this._settings[e] = t, i !== t && this._setRaw(e, i, t) } _set(e, t) { const i = this._settings[e]; this._settings[e] = t, i !== t && (this._setRaw(e, i, t), this._markDirtyKey(e)) } _stopAnimation(e) { const t = this._animatingSettings[e]; t && (delete this._animatingSettings[e], t.stop()) } set(e, t) { return this._set(e, t), this._stopAnimation(e), t } remove(e) { e in this._settings && (this._prevSettings[e] = this._settings[e], delete this._settings[e], this._sendKeyEvent(e, void 0), this._markDirtyKey(e)), this._stopAnimation(e) } removeAll() { c.each(l.keys(this._settings), (e => { this.remove(e) })) } getPrivate(e, t) { const i = this._privateSettings[e]; return void 0 !== i ? i : t } _setPrivateRaw(e, t, i) { this._prevPrivateSettings[e] = t, this._sendPrivateKeyEvent(e, i) } setPrivateRaw(e, t) { const i = this._privateSettings[e]; this._privateSettings[e] = t, i !== t && this._setPrivateRaw(e, i, t) } _setPrivate(e, t) { const i = this._privateSettings[e]; this._privateSettings[e] = t, i !== t && (this._setPrivateRaw(e, i, t), this._markDirtyPrivateKey(e)) } _stopAnimationPrivate(e) { const t = this._animatingPrivateSettings[e]; t && (t.stop(), delete this._animatingPrivateSettings[e]) } setPrivate(e, t) { return this._setPrivate(e, t), this._stopAnimationPrivate(e), t } removePrivate(e) { e in this._privateSettings && (this._prevPrivateSettings[e] = this._privateSettings[e], delete this._privateSettings[e], this._markDirtyPrivateKey(e)), this._stopAnimationPrivate(e) } setAll(e) { l.each(e, ((e, t) => { this.set(e, t) })) } animate(e) { const t = e.key, i = e.to, s = e.duration || 0, a = e.loops || 1, r = void 0 === e.from ? this.get(t) : e.from, n = void 0 === e.easing ? h.linear : e.easing; if (0 === s) this.set(t, i); else { if (void 0 !== r && r !== i) { this.set(t, r); const e = this._animatingSettings[t] = new m(this, r, i, s, n, a, this._animationTime()); return this._startAnimation(), e } this.set(t, i) } const o = new m(this, r, i, s, n, a, null); return o.stop(), o } animatePrivate(e) { const t = e.key, i = e.to, s = e.duration || 0, a = e.loops || 1, r = void 0 === e.from ? this.getPrivate(t) : e.from, n = void 0 === e.easing ? h.linear : e.easing; if (0 === s) this.setPrivate(t, i); else { if (void 0 !== r && r !== i) { this.setPrivate(t, r); const e = this._animatingPrivateSettings[t] = new m(this, r, i, s, n, a, this._animationTime()); return this._startAnimation(), e } this.setPrivate(t, i) } const o = new m(this, r, i, s, n, a, null); return o.stop(), o } _dispose() { } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this._dispose()) } } class b extends g { constructor(e, t, i, s = []) { if (super(t), Object.defineProperty(this, "_root", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_user_id", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "states", { enumerable: !0, configurable: !0, writable: !0, value: new n.States(this) }), Object.defineProperty(this, "adapters", { enumerable: !0, configurable: !0, writable: !0, value: new d(this) }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: this._createEvents() }), Object.defineProperty(this, "_userPrivateProperties", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dirty", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_dirtyPrivate", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_template", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_templates", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_internalTemplates", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_defaultThemes", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_templateDisposers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_disposers", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "_runSetup", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_disposerProperties", { enumerable: !0, configurable: !0, writable: !0, value: {} }), !i) throw new Error("You cannot use `new Class()`, instead use `Class.new()`"); this._root = e, this._internalTemplates = s, t.id && this._registerId(t.id) } static new(e, t, i) { const s = new this(e, t, !0); return s._template = i, s._afterNew(), s } static _new(e, t, i = []) { const s = new this(e, t, !0, i); return s._afterNew(), s } _afterNew() { this._checkDirty(); let e = !1; const t = this._template; t && (e = !0, t._setObjectTemplate(this)), c.each(this._internalTemplates, (t => { e = !0, t._setObjectTemplate(this) })), e && this._applyTemplates(!1), this.states.create("default", {}), this._setDefaults() } _afterNewApplyThemes() { this._checkDirty(); const e = this._template; e && e._setObjectTemplate(this), c.each(this._internalTemplates, (e => { e._setObjectTemplate(this) })), this.states.create("default", {}), this._setDefaults(), this._applyThemes() } _createEvents() { return new a.EventDispatcher } get classNames() { return this.constructor.classNames } get className() { return this.constructor.className } _setDefaults() { } _setDefaultFn(e, t) { const i = this.get(e); if (i) return i; { const i = t(); return this.set(e, i), i } } _setDefault(e, t) { this.has(e) || super.set(e, t) } _setRawDefault(e, t) { this.has(e) || super.setRaw(e, t) } _clearDirty() { l.keys(this._dirty).forEach((e => { this._dirty[e] = !1 })), l.keys(this._dirtyPrivate).forEach((e => { this._dirtyPrivate[e] = !1 })) } isDirty(e) { return !!this._dirty[e] } isPrivateDirty(e) { return !!this._dirtyPrivate[e] } _markDirtyKey(e) { this._dirty[e] = !0, super._markDirtyKey(e) } _markDirtyPrivateKey(e) { this._dirtyPrivate[e] = !0, super._markDirtyKey(e) } isType(e) { return -1 !== this.classNames.indexOf(e) } _pushPropertyDisposer(e, t) { let i = this._disposerProperties[e]; return void 0 === i && (i = this._disposerProperties[e] = []), i.push(t), t } _disposeProperty(e) { const t = this._disposerProperties[e]; void 0 !== t && (c.each(t, (e => { e.dispose() })), delete this._disposerProperties[e]) } set template(e) { const t = this._template; t !== e && (this._template = e, t && t._removeObjectTemplate(this), e && e._setObjectTemplate(this), this._applyTemplates()) } get template() { return this._template } markDirty() { this._root._addDirtyEntity(this) } _startAnimation() { this._root._addAnimation(this) } _animationTime() { return this._root.animationTime } _applyState(e) { } _applyStateAnimated(e, t) { } get(e, t) { const i = this.adapters.fold(e, this._settings[e]); return void 0 !== i ? i : t } isUserSetting(e) { return this._userProperties[e] || !1 } set(e, t) { return this._userProperties[e] = !0, super.set(e, t) } setRaw(e, t) { this._userProperties[e] = !0, super.setRaw(e, t) } _setSoft(e, t) { return this._userProperties[e] ? t : super.set(e, t) } remove(e) { delete this._userProperties[e], this._removeTemplateProperty(e) } setPrivate(e, t) { return this._userPrivateProperties[e] = !0, super.setPrivate(e, t) } setPrivateRaw(e, t) { this._userPrivateProperties[e] = !0, super.setPrivateRaw(e, t) } removePrivate(e) { delete this._userPrivateProperties[e], this._removeTemplatePrivateProperty(e) } _setTemplateProperty(e, t, i) { if (!this._userProperties[t]) { e === this._findTemplateByKey(t) && super.set(t, i) } } _setTemplatePrivateProperty(e, t, i) { if (!this._userPrivateProperties[t]) { e === this._findTemplateByPrivateKey(t) && super.setPrivate(t, i) } } _removeTemplateProperty(e) { if (!this._userProperties[e]) { const t = this._findTemplateByKey(e); t ? super.set(e, t._settings[e]) : super.remove(e) } } _removeTemplatePrivateProperty(e) { if (!this._userPrivateProperties[e]) { const t = this._findTemplateByPrivateKey(e); t ? super.setPrivate(e, t._privateSettings[e]) : super.removePrivate(e) } } _walkParents(e) { e(this._root._rootContainer), e(this) } _applyStateByKey(e) { const t = this.states.create(e, {}), i = {}; this._eachTemplate((s => { const a = s.states.lookup(e); a && a._apply(t, i) })), l.each(t._settings, (e => { i[e] || t._userSettings[e] || t.remove(e) })) } _applyTemplate(e, t) { this._templateDisposers.push(e._apply(this, t)), l.each(e._settings, ((e, i) => { t.settings[e] || this._userProperties[e] || (t.settings[e] = !0, super.set(e, i)) })), l.each(e._privateSettings, ((e, i) => { t.privateSettings[e] || this._userPrivateProperties[e] || (t.privateSettings[e] = !0, super.setPrivate(e, i)) })), this._runSetup && e.setup && (this._runSetup = !1, e.setup(this)) } _findStaticTemplate(e) { if (this._template && e(this._template)) return this._template } _eachTemplate(e) { this._findStaticTemplate((t => (e(t), !1))), c.eachReverse(this._internalTemplates, e), c.each(this._templates, e) } _applyTemplates(e = !0) { e && this._disposeTemplates(); const t = { settings: {}, privateSettings: {}, states: {} }; this._eachTemplate((e => { this._applyTemplate(e, t) })), e && (l.each(this._settings, (e => { this._userProperties[e] || t.settings[e] || super.remove(e) })), l.each(this._privateSettings, (e => { this._userPrivateProperties[e] || t.privateSettings[e] || super.removePrivate(e) }))) } _findTemplate(e) { const t = this._findStaticTemplate(e); if (void 0 === t) { const t = c.findReverse(this._internalTemplates, e); return void 0 === t ? c.find(this._templates, e) : t } return t } _findTemplateByKey(e) { return this._findTemplate((t => e in t._settings)) } _findTemplateByPrivateKey(e) { return this._findTemplate((t => e in t._privateSettings)) } _disposeTemplates() { c.each(this._templateDisposers, (e => { e.dispose() })), this._templateDisposers.length = 0 } _removeTemplates() { c.each(this._templates, (e => { e._removeObjectTemplate(this) })), this._templates.length = 0 } _applyThemes(e = !1) { let t = !1; const i = []; let s = []; const a = new Set, r = this.get("themeTagsSelf"); return r && c.each(r, (e => { a.add(e) })), this._walkParents((e => { e === this._root._rootContainer && (t = !0), e._defaultThemes.length > 0 && i.push(e._defaultThemes); const r = e.get("themes"); r && s.push(r); const n = e.get("themeTags"); n && c.each(n, (e => { a.add(e) })) })), s = i.concat(s), this._removeTemplates(), (t || e) && c.eachReverse(this.classNames, (e => { const t = []; c.each(s, (i => { c.each(i, (i => { const s = i._lookupRules(e); s && c.eachReverse(s, (e => { if (e.tags.every((e => a.has(e)))) { const i = c.getFirstSortedIndex(t, (t => { const i = u.compare(e.tags.length, t.tags.length); return 0 === i ? u.compareArray(e.tags, t.tags, u.compare) : i })); t.splice(i.index, 0, e) } })) })) })), c.each(t, (e => { this._templates.push(e.template), e.template._setObjectTemplate(this) })) })), this._applyTemplates(), (t || e) && (this._runSetup = !1), t || e } _changed() { } _beforeChanged() { if (this.isDirty("id")) { const e = this.get("id"); e && this._registerId(e); const t = this._prevSettings.id; t && delete o.registry.entitiesById[t] } } _registerId(e) { if (o.registry.entitiesById[e] && o.registry.entitiesById[e] !== this) throw new Error('An entity with id "' + e + '" already exists.'); o.registry.entitiesById[e] = this } _afterChanged() { } addDisposer(e) { return this._disposers.push(e), e } _dispose() { super._dispose(); const e = this._template; e && e._removeObjectTemplate(this), c.each(this._internalTemplates, (e => { e._removeObjectTemplate(this) })), this._removeTemplates(), this._disposeTemplates(), this.events.dispose(), this._disposers.forEach((e => { e.dispose() })), l.each(this._disposerProperties, ((e, t) => { c.each(t, (e => { e.dispose() })) })); const t = this.get("id"); t && delete o.registry.entitiesById[t] } setTimeout(e, t) { const i = setTimeout((() => { this.removeDispose(a), e() }), t), a = new s.Disposer((() => { clearTimeout(i) })); return this._disposers.push(a), a } removeDispose(e) { if (!this.isDisposed()) { let t = c.indexOf(this._disposers, e); t > -1 && this._disposers.splice(t, 1) } e.dispose() } hasTag(e) { return -1 !== c.indexOf(this.get("themeTags", []), e) } addTag(e) { if (!this.hasTag(e)) { const t = this.get("themeTags", []); t.push(e), this.set("themeTags", t) } } removeTag(e) { if (this.hasTag(e)) { const t = this.get("themeTags", []); c.remove(t, e), this.set("themeTags", t) } } _t(e, t, ...i) { return this._root.language.translate(e, t, ...i) } get root() { return this._root } } Object.defineProperty(b, "className", { enumerable: !0, configurable: !0, writable: !0, value: "Entity" }), Object.defineProperty(b, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: ["Entity"] }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js": (e, t, i) => { i.r(t), i.d(t, { EventDispatcher: () => n, TargetedEventDispatcher: () => o }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class n { constructor() { Object.defineProperty(this, "_listeners", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_killed", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_disabled", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_iterating", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_enabled", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._listeners = [], this._killed = [], this._disabled = {}, this._iterating = 0, this._enabled = !0, this._disposed = !1 } isDisposed() { return this._disposed } dispose() { if (!this._disposed) { this._disposed = !0; const e = this._listeners; this._iterating = 1, this._listeners = null, this._disabled = null; try { a.each(e, (e => { e.disposer.dispose() })) } finally { this._killed = null, this._iterating = null } } } hasListeners() { return 0 !== this._listeners.length } hasListenersByType(e) { return a.any(this._listeners, (t => (null === t.type || t.type === e) && !t.killed)) } enable() { this._enabled = !0 } disable() { this._enabled = !1 } enableType(e) { delete this._disabled[e] } disableType(e, t = 1 / 0) { this._disabled[e] = t } _removeListener(e) { if (0 === this._iterating) { const t = this._listeners.indexOf(e); if (-1 === t) throw new Error("Invalid state: could not remove listener"); this._listeners.splice(t, 1) } else this._killed.push(e) } _removeExistingListener(e, t, i, s) { if (this._disposed) throw new Error("EventDispatcher is disposed"); this._eachListener((a => { a.once !== e || a.type !== t || void 0 !== i && a.callback !== i || a.context !== s || a.disposer.dispose() })) } isEnabled(e) { if (this._disposed) throw new Error("EventDispatcher is disposed"); return this._enabled && this._listeners.length > 0 && this.hasListenersByType(e) && void 0 === this._disabled[e] } removeType(e) { if (this._disposed) throw new Error("EventDispatcher is disposed"); this._eachListener((t => { t.type === e && t.disposer.dispose() })) } has(e, t, i) { return -1 !== a.findIndex(this._listeners, (s => !0 !== s.once && s.type === e && (void 0 === t || s.callback === t) && s.context === i)) } _shouldDispatch(e) { if (this._disposed) throw new Error("EventDispatcher is disposed"); const t = this._disabled[e]; return r.isNumber(t) ? (t <= 1 ? delete this._disabled[e] : --this._disabled[e], !1) : this._enabled } _eachListener(e) { ++this._iterating; try { a.each(this._listeners, e) } finally { --this._iterating, 0 === this._iterating && 0 !== this._killed.length && (a.each(this._killed, (e => { this._removeListener(e) })), this._killed.length = 0) } } dispatch(e, t) { this._shouldDispatch(e) && this._eachListener((i => { i.killed || null !== i.type && i.type !== e || i.dispatch(e, t) })) } _on(e, t, i, a, r, n) { if (this._disposed) throw new Error("EventDispatcher is disposed"); this._removeExistingListener(e, t, i, a); const o = { type: t, callback: i, context: a, shouldClone: r, dispatch: n, killed: !1, once: e, disposer: new s.Disposer((() => { o.killed = !0, this._removeListener(o) })) }; return this._listeners.push(o), o } onAll(e, t, i = !0) { return this._on(!1, null, e, t, i, ((i, s) => e.call(t, s))).disposer } on(e, t, i, s = !0) { return this._on(!1, e, t, i, s, ((e, s) => t.call(i, s))).disposer } once(e, t, i, s = !0) { const a = this._on(!0, e, t, i, s, ((e, s) => { a.disposer.dispose(), t.call(i, s) })); return a.disposer } off(e, t, i) { this._removeExistingListener(!1, e, t, i) } copyFrom(e) { if (this._disposed) throw new Error("EventDispatcher is disposed"); if (e === this) throw new Error("Cannot copyFrom the same TargetedEventDispatcher"); const t = []; return a.each(e._listeners, (e => { !e.killed && e.shouldClone && (null === e.type ? t.push(this.onAll(e.callback, e.context)) : e.once ? t.push(this.once(e.type, e.callback, e.context)) : t.push(this.on(e.type, e.callback, e.context))) })), new s.MultiDisposer(t) } } class o extends n { constructor(e) { super(), Object.defineProperty(this, "target", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.target = e } copyFrom(e) { if (this._disposed) throw new Error("EventDispatcher is disposed"); if (e === this) throw new Error("Cannot copyFrom the same TargetedEventDispatcher"); const t = []; return a.each(e._listeners, (i => { i.context !== e.target && !i.killed && i.shouldClone && (null === i.type ? t.push(this.onAll(i.callback, i.context)) : i.once ? t.push(this.once(i.type, i.callback, i.context)) : t.push(this.on(i.type, i.callback, i.context))) })), new s.MultiDisposer(t) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/InterfaceColors.js": (e, t, i) => { i.r(t), i.d(t, { InterfaceColors: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"); class a extends s.Entity { } Object.defineProperty(a, "className", { enumerable: !0, configurable: !0, writable: !0, value: "InterfaceColors" }), Object.defineProperty(a, "classNames", { enumerable: !0, configurable: !0, writable: !0, value: s.Entity.classNames.concat([a.className]) }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Language.js": (e, t, i) => { i.r(t), i.d(t, { Language: () => o }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), n = i("./node_modules/@amcharts/amcharts5/locales/en.js"); class o extends s.Entity { _setDefaults() { this.setPrivate("defaultLocale", n.default), super._setDefaults() } translate(e, t, ...i) { t || (t = this._root.locale || this.getPrivate("defaultLocale")); let s = e, a = t[e]; if (null === a) s = ""; else if (null != a) a && (s = a); else if (t !== this.getPrivate("defaultLocale")) return this.translate(e, this.getPrivate("defaultLocale"), ...i); if (i.length) for (let e = i.length, t = 0; t < e; ++t)s = s.split("%" + (t + 1)).join(i[t]); return s } translateAny(e, t, ...i) { return this.translate(e, t, ...i) } setTranslationAny(e, t, i) { (i || this._root.locale)[e] = t } setTranslationsAny(e, t) { r.each(e, ((e, i) => { this.setTranslationAny(e, i, t) })) } translateEmpty(e, t, ...i) { let s = this.translate(e, t, ...i); return s == e ? "" : s } translateFunc(e, t) { return this._root.locale[e] ? this._root.locale[e] : t !== this.getPrivate("defaultLocale") ? this.translateFunc(e, this.getPrivate("defaultLocale")) : () => "" } translateAll(e, t) { return this.isDefault() ? e : a.map(e, (e => this.translate(e, t))) } isDefault() { return this.getPrivate("defaultLocale") === this._root.locale } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/List.js": (e, t, i) => { i.r(t), i.d(t, { List: () => n, ListAutoDispose: () => o, ListTemplate: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); function r(e, t) { if (!(e >= 0 && e < t)) throw new Error("Index out of bounds: " + e) } class n { constructor(e = []) { Object.defineProperty(this, "_values", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new s.EventDispatcher }), this._values = e } get values() { return this._values } contains(e) { return -1 !== this._values.indexOf(e) } removeValue(e) { let t = 0, i = this._values.length; for (; t < i;)this._values[t] === e ? (this.removeIndex(t), --i) : ++t } indexOf(e) { return a.indexOf(this._values, e) } get length() { return this._values.length } hasIndex(e) { return e >= 0 && e < this._values.length } getIndex(e) { return this._values[e] } _onPush(e) { this.events.isEnabled("push") && this.events.dispatch("push", { type: "push", target: this, newValue: e }) } _onInsertIndex(e, t) { this.events.isEnabled("insertIndex") && this.events.dispatch("insertIndex", { type: "insertIndex", target: this, index: e, newValue: t }) } _onSetIndex(e, t, i) { this.events.isEnabled("setIndex") && this.events.dispatch("setIndex", { type: "setIndex", target: this, index: e, oldValue: t, newValue: i }) } _onRemoveIndex(e, t) { this.events.isEnabled("removeIndex") && this.events.dispatch("removeIndex", { type: "removeIndex", target: this, index: e, oldValue: t }) } _onMoveIndex(e, t, i) { this.events.isEnabled("moveIndex") && this.events.dispatch("moveIndex", { type: "moveIndex", target: this, oldIndex: e, newIndex: t, value: i }) } _onClear(e) { this.events.isEnabled("clear") && this.events.dispatch("clear", { type: "clear", target: this, oldValues: e }) } setIndex(e, t) { r(e, this._values.length); const i = this._values[e]; return i !== t && (this._values[e] = t, this._onSetIndex(e, i, t)), i } insertIndex(e, t) { return r(e, this._values.length + 1), a.insertIndex(this._values, e, t), this._onInsertIndex(e, t), t } swap(e, t) { const i = this._values.length; if (r(e, i), r(t, i), e !== t) { const i = this._values[e], s = this._values[t]; this._values[e] = s, this._onSetIndex(e, i, s), this._values[t] = i, this._onSetIndex(t, s, i) } } removeIndex(e) { r(e, this._values.length); const t = this._values[e]; return a.removeIndex(this._values, e), this._onRemoveIndex(e, t), t } moveValue(e, t) { let i = this.indexOf(e); if (-1 !== i) if (a.removeIndex(this._values, i), null == t) { const t = this._values.length; this._values.push(e), this._onMoveIndex(i, t, e) } else a.insertIndex(this._values, t, e), this._onMoveIndex(i, t, e); else null == t ? (this._values.push(e), this._onPush(e)) : (a.insertIndex(this._values, t, e), this._onInsertIndex(t, e)); return e } push(e) { return this._values.push(e), this._onPush(e), e } unshift(e) { return this.insertIndex(0, e), e } pushAll(e) { a.each(e, (e => { this.push(e) })) } copyFrom(e) { this.pushAll(e._values) } pop() { return this._values.length - 1 < 0 ? void 0 : this.removeIndex(this._values.length - 1) } shift() { return this._values.length ? this.removeIndex(0) : void 0 } setAll(e) { const t = this._values; this._values = [], this._onClear(t), a.each(e, (e => { this._values.push(e), this._onPush(e) })) } clear() { this.setAll([]) } *[Symbol.iterator]() { const e = this._values.length; for (let t = 0; t < e; ++t)yield this._values[t] } each(e) { a.each(this._values, e) } eachReverse(e) { a.eachReverse(this._values, e) } } class o extends n { constructor() { super(...arguments), Object.defineProperty(this, "autoDispose", { enumerable: !0, configurable: !0, writable: !0, value: !0 }), Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }) } _onSetIndex(e, t, i) { this.autoDispose && t.dispose(), super._onSetIndex(e, t, i) } _onRemoveIndex(e, t) { this.autoDispose && t.dispose(), super._onRemoveIndex(e, t) } _onClear(e) { this.autoDispose && a.each(e, (e => { e.dispose() })), super._onClear(e) } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this.autoDispose && a.each(this._values, (e => { e.dispose() }))) } } class l extends o { constructor(e, t) { super(), Object.defineProperty(this, "template", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "make", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.template = e, this.make = t } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Math.js": (e, t, i) => { i.r(t), i.d(t, { DEGREES: () => o, HALFPI: () => r, PI: () => a, RADIANS: () => n, boundsOverlap: () => k, ceil: () => h, circlesOverlap: () => C, closest: () => D, cos: () => g, fitAngleToRange: () => v, fitToRange: () => d, getAngle: () => w, getArcBounds: () => _, getArcPoint: () => f, getCubicControlPointA: () => c, getCubicControlPointB: () => u, getPointOnLine: () => T, getPointOnQuadraticCurve: () => P, inBounds: () => x, mergeBounds: () => y, normalizeAngle: () => b, round: () => l, sin: () => m, spiralPoints: () => j, tan: () => p }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); const a = Math.PI, r = a / 2, n = a / 180, o = 180 / a; function l(e, t, i) { if (!(0, s.isNumber)(t) || t <= 0) { let t = Math.round(e); return i && t - e == .5 && t--, t } { let i = Math.pow(10, t); return Math.round(e * i) / i } } function h(e, t) { if (!(0, s.isNumber)(t) || t <= 0) return Math.ceil(e); { let i = Math.pow(10, t); return Math.ceil(e * i) / i } } function c(e, t, i, s, a) { return { x: (-e.x + t.x / s + i.x) * s, y: (-e.y + t.y / a + i.y) * a } } function u(e, t, i, s, a) { return { x: (e.x + t.x / s - i.x) * s, y: (e.y + t.y / a - i.y) * a } } function d(e, t, i) { return Math.min(Math.max(e, t), i) } function m(e) { return Math.sin(n * e) } function p(e) { return Math.tan(n * e) } function g(e) { return Math.cos(n * e) } function b(e) { return (e %= 360) < 0 && (e += 360), e } function _(e, t, i, s, a) { let r = Number.MAX_VALUE, n = Number.MAX_VALUE, o = -Number.MAX_VALUE, l = -Number.MAX_VALUE, h = []; h.push(f(a, i)), h.push(f(a, s)); let c = Math.min(90 * Math.floor(i / 90), 90 * Math.floor(s / 90)), u = Math.max(90 * Math.ceil(i / 90), 90 * Math.ceil(s / 90)); for (let e = c; e <= u; e += 90)e >= i && e <= s && h.push(f(a, e)); for (let e = 0; e < h.length; e++) { let t = h[e]; t.x < r && (r = t.x), t.y < n && (n = t.y), t.x > o && (o = t.x), t.y > l && (l = t.y) } return { left: e + r, top: t + n, right: e + o, bottom: t + l } } function f(e, t) { return { x: e * g(t), y: e * m(t) } } function y(e) { const t = e.length; if (t > 0) { let i = e[0], s = i.left, a = i.top, r = i.right, n = i.bottom; if (t > 1) for (let o = 1; o < t; o++)i = e[o], s = Math.min(i.left, s), r = Math.max(i.right, r), a = Math.min(i.top, a), n = Math.max(i.bottom, n); return { left: s, right: r, top: a, bottom: n } } return { left: 0, right: 0, top: 0, bottom: 0 } } function v(e, t, i) { if (t > i) { let e = t; t = i, i = e } e = b(e); let s = (t - b(t)) / 360; return e < t && (e += 360 * (s + 1)), e > i && (e - 360 > t ? e -= 360 : e = e < t + (i - t) / 2 + 180 ? i : t), e < t && (e = e > t + (i - t) / 2 - 180 ? t : i), e } function x(e, t) { return e.x >= t.left && e.y >= t.top && e.x <= t.right && e.y <= t.bottom } function w(e, t) { t || (t = { x: 2 * e.x, y: 2 * e.y }); let i = t.x - e.x, s = t.y - e.y, a = Math.atan2(s, i) * o; return a < 0 && (a += 360), b(a) } function P(e, t, i, s) { return { x: (1 - s) * (1 - s) * e.x + 2 * (1 - s) * s * i.x + s * s * t.x, y: (1 - s) * (1 - s) * e.y + 2 * (1 - s) * s * i.y + s * s * t.y } } function T(e, t, i) { return { x: e.x + (t.x - e.x) * i, y: e.y + (t.y - e.y) * i } } function D(e, t) { return e.reduce((function (e, i) { return Math.abs(i - t) < Math.abs(e - t) ? i : e })) } function k(e, t) { const i = e.left < t.right && e.right > t.left, s = e.top < t.bottom && e.bottom > t.top; return i && s } function j(e, t, i, s, a, r, l, h, c) { let u = a + .01, d = h * n, m = []; for (; u < i + l;) { let n = r; if (n / 2 > u && (n = 2 * u), d += 2 * Math.asin(n / 2 / u), d * o > c + (i - a) / l * 360) break; let h = d * o, p = { x: e + u * Math.cos(d), y: t + u * s / i * Math.sin(d) }; m.push(p), u = a + h / 360 * l } return m.shift(), m } function C(e, t) { return Math.hypot(e.x - t.x, e.y - t.y) <= e.radius + t.radius } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Matrix.js": (e, t, i) => { i.r(t), i.d(t, { Matrix: () => s }); class s { constructor(e = 1, t = 0, i = 0, s = 1, a = 0, r = 0) { Object.defineProperty(this, "a", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "b", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "c", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "d", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "tx", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "ty", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this.a = e, this.b = t, this.c = i, this.d = s, this.tx = a, this.ty = r } setTransform(e, t, i, s, a, r = 1) { this.a = Math.cos(a) * r, this.b = Math.sin(a) * r, this.c = -Math.sin(a) * r, this.d = Math.cos(a) * r, this.tx = e - (i * this.a + s * this.c), this.ty = t - (i * this.b + s * this.d) } apply(e) { return { x: this.a * e.x + this.c * e.y + this.tx, y: this.b * e.x + this.d * e.y + this.ty } } applyInverse(e) { const t = 1 / (this.a * this.d + this.c * -this.b); return { x: this.d * t * e.x + -this.c * t * e.y + (this.ty * this.c - this.tx * this.d) * t, y: this.a * t * e.y + -this.b * t * e.x + (-this.ty * this.a + this.tx * this.b) * t } } append(e) { const t = this.a, i = this.b, s = this.c, a = this.d; this.a = e.a * t + e.b * s, this.b = e.a * i + e.b * a, this.c = e.c * t + e.d * s, this.d = e.c * i + e.d * a, this.tx = e.tx * t + e.ty * s + this.tx, this.ty = e.tx * i + e.ty * a + this.ty } prepend(e) { const t = this.tx; if (1 !== e.a || 0 !== e.b || 0 !== e.c || 1 !== e.d) { const t = this.a, i = this.c; this.a = t * e.a + this.b * e.c, this.b = t * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d } this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty } copyFrom(e) { this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/NumberFormatter.js": (e, t, i) => { i.r(t), i.d(t, { NumberFormatter: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Entity.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class l extends s.Entity { _setDefaults() { this._setDefault("negativeBase", 0), this._setDefault("numberFormat", "#,###.#####"), this._setDefault("smallNumberThreshold", 1); const e = "_big_number_suffix_", t = "_small_number_suffix_", i = "_byte_suffix_"; this._setDefault("bigNumberPrefixes", [{ number: 1e3, suffix: this._t(e + "3") }, { number: 1e6, suffix: this._t(e + "6") }, { number: 1e9, suffix: this._t(e + "9") }, { number: 1e12, suffix: this._t(e + "12") }, { number: 1e15, suffix: this._t(e + "15") }, { number: 1e18, suffix: this._t(e + "18") }, { number: 1e21, suffix: this._t(e + "21") }, { number: 1e24, suffix: this._t(e + "24") }]), this._setDefault("smallNumberPrefixes", [{ number: 1e-24, suffix: this._t(t + "24") }, { number: 1e-21, suffix: this._t(t + "21") }, { number: 1e-18, suffix: this._t(t + "18") }, { number: 1e-15, suffix: this._t(t + "15") }, { number: 1e-12, suffix: this._t(t + "12") }, { number: 1e-9, suffix: this._t(t + "9") }, { number: 1e-6, suffix: this._t(t + "6") }, { number: .001, suffix: this._t(t + "3") }]), this._setDefault("bytePrefixes", [{ number: 1, suffix: this._t(i + "B") }, { number: 1024, suffix: this._t(i + "KB") }, { number: 1048576, suffix: this._t(i + "MB") }, { number: 1073741824, suffix: this._t(i + "GB") }, { number: 1099511627776, suffix: this._t(i + "TB") }, { number: 0x4000000000000, suffix: this._t(i + "PB") }]), super._setDefaults() } _beforeChanged() { super._beforeChanged() } format(e, t, i) { let s; (null == t || o.isString(t) && "number" === t.toLowerCase()) && (t = this.get("numberFormat", "")); let a = Number(e); if (o.isObject(t)) try { return this.get("intlLocales") ? new Intl.NumberFormat(this.get("intlLocales"), t).format(a) : new Intl.NumberFormat(void 0, t).format(a) } catch (e) { return "Invalid" } else { t = n.cleanFormat(t); let e, l = this.parseFormat(t, this._root.language); e = a > this.get("negativeBase") ? l.positive : a < this.get("negativeBase") ? l.negative : l.zero, null == i || e.mod || (e = r.copy(e), e.decimals.active = 0 == a ? 0 : i), s = e.template.split(o.PLACEHOLDER).join(this.applyFormat(a, e)) } return !0 === this.get("forceLTR") && (s = "" + s), s } parseFormat(e, t) { const i = t.translateEmpty("_thousandSeparator"), s = t.translateEmpty("_decimalSeparator"); let n = { positive: { thousands: { active: -1, passive: -1, interval: -1, separator: i }, decimals: { active: -1, passive: -1, separator: s }, template: "", source: "", parsed: !1 }, negative: { thousands: { active: -1, passive: -1, interval: -1, separator: i }, decimals: { active: -1, passive: -1, separator: s }, template: "", source: "", parsed: !1 }, zero: { thousands: { active: -1, passive: -1, interval: -1, separator: i }, decimals: { active: -1, passive: -1, separator: s }, template: "", source: "", parsed: !1 } }, l = (e = e.replace("||", o.PLACEHOLDER2)).split("|"); return n.positive.source = l[0], void 0 === l[2] ? n.zero = n.positive : n.zero.source = l[2], void 0 === l[1] ? n.negative = n.positive : n.negative.source = l[1], r.each(n, ((e, t) => { if (t.parsed) return; let i = t.source; "number" === i.toLowerCase() && (i = this.get("numberFormat", "#,###.#####")); let s = a.TextFormatter.chunk(i, !0); for (let e = 0; e < s.length; e++) { let i = s[e]; if (i.text = i.text.replace(o.PLACEHOLDER2, "|"), "value" === i.type) { let e = i.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP!]?/); if (e) if (null === e || "" === e[0]) t.template += i.text; else { let s = e[0].match(/[abespABESP%!]{2}|[abespABESP%]{1}$/); s && (t.mod = s[0].toLowerCase(), t.modSpacing = !!e[0].match(/[ ]{1}[abespABESP%!]{1}$/)); let a = e[0].split("."); if ("" === a[0]); else { t.thousands.active = (a[0].match(/0/g) || []).length, t.thousands.passive = (a[0].match(/\#/g) || []).length + t.thousands.active; let e = a[0].split(","); 1 === e.length || (t.thousands.interval = (e.pop() || "").length, 0 === t.thousands.interval && (t.thousands.interval = -1)) } void 0 === a[1] || (t.decimals.active = (a[1].match(/0/g) || []).length, t.decimals.passive = (a[1].match(/\#/g) || []).length + t.decimals.active), t.template += i.text.split(e[0]).join(o.PLACEHOLDER) } } else t.template += i.text } t.parsed = !0 })), n } applyFormat(e, t) { let i = e < 0; e = Math.abs(e); let s = "", a = "", r = t.mod ? t.mod.split("") : []; if (-1 !== r.indexOf("b")) { let i = this.applyPrefix(e, this.get("bytePrefixes"), -1 !== r.indexOf("!")); e = i[0], s = i[1], a = i[2], t.modSpacing && (a = " " + a) } else if (-1 !== r.indexOf("a")) { let i = this.applyPrefix(e, e < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), -1 !== r.indexOf("!")); e = i[0], s = i[1], a = i[2], t.modSpacing && (a = " " + a) } else if (-1 !== r.indexOf("p")) { let t = Math.min(e.toString().length + 2, 21); e = parseFloat(e.toPrecision(t)), s = this._root.language.translate("_percentPrefix"), a = this._root.language.translate("_percentSuffix"), "" == s && "" == a && (a = "%") } else if (-1 !== r.indexOf("%")) { let t = Math.min(e.toString().length + 2, 21); e *= 100, e = parseFloat(e.toPrecision(t)), a = "%" } else if (-1 !== r.indexOf("")) { let t = Math.min(e.toString().length + 3, 21); e *= 1e3, e = parseFloat(e.toPrecision(t)), a = "" } if (-1 !== r.indexOf("e")) { let i; i = t.decimals.passive >= 0 ? e.toExponential(t.decimals.passive).split("e") : e.toExponential().split("e"), e = Number(i[0]), a = "e" + i[1], t.modSpacing && (a = " " + a) } else if (0 === t.decimals.passive) e = Math.round(e); else if (t.decimals.passive > 0) { const i = n.decimalPlaces(e); if (i > 0) { const s = Math.pow(10, t.decimals.passive); e = Math.round(parseFloat((e * s).toFixed(i))) / s } } let l = "", h = o.numberToString(e).split("."), c = h[0]; if (c.length < t.thousands.active && (c = Array(t.thousands.active - c.length + 1).join("0") + c), t.thousands.interval > 0) { let e = [], i = c.split("").reverse().join(""); for (let s = 0, a = c.length; s <= a; s += t.thousands.interval) { let a = i.substr(s, t.thousands.interval).split("").reverse().join(""); "" !== a && e.unshift(a) } c = e.join(t.thousands.separator) } l += c, 1 === h.length && h.push(""); let u = h[1]; return u.length < t.decimals.active && (u += Array(t.decimals.active - u.length + 1).join("0")), "" !== u && (l += t.decimals.separator + u), "" === l && (l = "0"), 0 !== e && i && -1 === r.indexOf("s") && (l = "-" + l), s && (l = s + l), a && (l += a), l } applyPrefix(e, t, i = !1) { let s = e, a = "", r = "", n = !1, o = 1; for (let i = 0, l = t.length; i < l; i++)t[i].number <= e && (0 === t[i].number ? s = 0 : (s = e / t[i].number, o = t[i].number), a = t[i].prefix, r = t[i].suffix, n = !0); return !n && i && t.length && 0 != e && (s = e / t[0].number, a = t[0].prefix, r = t[0].suffix, n = !0), n && (s = parseFloat(s.toPrecision(Math.min(o.toString().length + Math.floor(s).toString().replace(/[^0-9]*/g, "").length, 21)))), [s, a, r] } escape(e) { return e.replace("||", o.PLACEHOLDER2) } unescape(e) { return e.replace(o.PLACEHOLDER2, "|") } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js": (e, t, i) => { i.r(t), i.d(t, { copy: () => n, each: () => o, eachContinue: () => l, eachOrdered: () => h, hasKey: () => c, keys: () => a, keysOrdered: () => r, softCopyProperties: () => u }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"); function a(e) { return Object.keys(e) } function r(e, t) { return a(e).sort(t) } function n(e) { return Object.assign({}, e) } function o(e, t) { a(e).forEach((i => { t(i, e[i]) })) } function l(e, t) { for (let i in e) if (c(e, i) && !t(i, e[i])) break } function h(e, t, i) { s.each(r(e, i), (i => { t(i, e[i]) })) } function c(e, t) { return {}.hasOwnProperty.call(e, t) } function u(e, t) { return o(e, ((e, i) => { null != i && null == t[e] && (t[e] = i) })), t } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Order.js": (e, t, i) => { function s(e, t) { return e === t ? 0 : e < t ? -1 : 1 } function a(e, t, i) { const a = e.length, r = t.length, n = Math.min(a, r); for (let s = 0; s < n; ++s) { const a = i(e[s], t[s]); if (0 !== a) return a } return s(a, r) } function r(e) { return e < 0 ? 1 : e > 0 ? -1 : 0 } function n(e, t) { return e === t ? 0 : e < t ? -1 : 1 } i.r(t), i.d(t, { compare: () => s, compareArray: () => a, compareNumber: () => n, reverse: () => r }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js": (e, t, i) => { i.r(t), i.d(t, { Percent: () => s, isPercent: () => l, p0: () => r, p100: () => n, p50: () => o, percent: () => a }); class s { constructor(e) { Object.defineProperty(this, "_value", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._value = e } get value() { return this._value / 100 } get percent() { return this._value } toString() { return this._value + "%" } interpolate(e, t) { return e + this.value * (t - e) } static normalize(e, t, i) { return e instanceof s ? e : new s(t === i ? 0 : 100 * Math.min(Math.max(1 / (i - t) * (e - t), 0), 1)) } } function a(e) { return new s(e) } const r = a(0), n = a(100), o = a(50); function l(e) { return e instanceof s } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/PopulateString.js": (e, t, i) => { i.r(t), i.d(t, { getTagValueFromObject: () => c, populateString: () => o }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Sprite.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js"); function o(e, t) { if (null != t) { t = "" + t; let i, s = (t = n.TextFormatter.escape(t)).match(/\{([^}]+)\}/g); if (s) for (i = 0; i < s.length; i++) { let a = l(e, s[i].replace(/\{([^}]+)\}/, "$1"), ""); null == a && (a = ""), t = t.split(s[i]).join(a) } t = n.TextFormatter.unescape(t) } else t = ""; return t } function l(e, t, i) { let r; const n = e.dataItem; let o, h = [], u = /(format[a-zA-Z]*)\((.*)\)|([^.]+)/g; for (; o = u.exec(t), null !== o;)if (o[3]) { h.push({ prop: o[3] }); const t = e.getDateFormatter().get("dateFields", []), i = e.getNumberFormatter().get("numericFields", []), s = e.getDurationFormatter().get("durationFields", []); -1 !== t.indexOf(o[3]) ? h.push({ method: "formatDate", params: [] }) : -1 !== i.indexOf(o[3]) ? h.push({ method: "formatNumber", params: [] }) : -1 !== s.indexOf(o[3]) && h.push({ method: "formatDuration", params: [] }) } else { let e = []; if ("" != a.trim(o[2])) { let t, i = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g; for (; t = i.exec(o[2]), null !== t;)e.push(t[1] || t[2] || t[3]) } h.push({ method: o[1], params: e }) } if (n) { r = c(e, h, n._settings), (null == r || s.isObject(r)) && (r = c(e, h, n)); let a = n.dataContext; null == r && a && (r = c(e, h, a), null == r && (r = c(e, [{ prop: t }], a)), null == r && a.dataContext && (r = c(e, h, a.dataContext))), null == r && n.component && n.component.dataItem !== n && (r = l(n.component, t, i)) } return null == r && (r = c(e, h, e)), null == r && e.parent && (r = l(e.parent, t, i)), r } function h(e, t) { const i = e.getPrivate("customData"); if (s.isObject(i)) return i[t] } function c(e, t, i, n) { let o = i, l = !1; for (let a = 0, c = t.length; a < c; a++) { let c = t[a]; if (c.prop) { if (o instanceof r.Sprite) { let e = o.get(c.prop); null == e && (e = o.getPrivate(c.prop)), null == e && (e = h(o, c.prop)), null == e && (e = o[c.prop]), o = e } else if (o.get) { let e = o.get(c.prop); null == e && (e = o[c.prop]), o = e } else o = o[c.prop]; if (null == o) return } else switch (c.method) { case "formatNumber": let t = s.toNumber(o); null != t && (o = e.getNumberFormatter().format(t, n || c.params[0] || void 0), l = !0); break; case "formatDate": let a = s.toDate(o); if (!s.isDate(a) || s.isNaN(a.getTime())) return; null != a && (o = e.getDateFormatter().format(a, n || c.params[0] || void 0), l = !0); break; case "formatDuration": let r = s.toNumber(o); null != r && (o = e.getDurationFormatter().format(r, n || c.params[0] || void 0, c.params[1] || void 0), l = !0); break; case "urlEncode": case "encodeURIComponent": o = encodeURIComponent(o); break; default: o[c.method] && o[c.method].apply(i, c.params) } } if (!l) { let t = [{ method: "", params: n }]; if (null == n) s.isNumber(o) ? (t[0].method = "formatNumber", t[0].params = "") : s.isDate(o) && (t[0].method = "formatDate", t[0].params = ""); else { let e = a.getFormat(n); "number" === e ? t[0].method = "formatNumber" : "date" === e ? t[0].method = "formatDate" : "duration" === e && (t[0].method = "formatDuration") } t[0].method && (o = c(e, t, o)) } return o } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/ResizeSensor.js": (e, t, i) => { i.r(t), i.d(t, { ResizeSensor: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); class r { constructor() { Object.defineProperty(this, "_observer", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_targets", { enumerable: !0, configurable: !0, writable: !0, value: [] }), this._observer = new ResizeObserver((e => { s.each(e, (e => { s.each(this._targets, (t => { t.target === e.target && t.callback() })) })) })) } addTarget(e, t) { this._observer.observe(e, { box: "border-box" }), this._targets.push({ target: e, callback: t }) } removeTarget(e) { this._observer.unobserve(e), s.keepIf(this._targets, (t => t.target !== e)) } } class n { constructor() { Object.defineProperty(this, "_timer", { enumerable: !0, configurable: !0, writable: !0, value: null }), Object.defineProperty(this, "_targets", { enumerable: !0, configurable: !0, writable: !0, value: [] }) } addTarget(e, t) { if (null === this._timer) { let e = null; const t = () => { const i = Date.now(); (null === e || i > e + n.delay) && (e = i, s.each(this._targets, (e => { let t = e.target.getBoundingClientRect(); t.width === e.size.width && t.height === e.size.height || (e.size = t, e.callback()) }))), 0 === this._targets.length ? this._timer = null : this._timer = requestAnimationFrame(t) }; this._timer = requestAnimationFrame(t) } this._targets.push({ target: e, callback: t, size: { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 } }) } removeTarget(e) { s.keepIf(this._targets, (t => t.target !== e)), 0 === this._targets.length && null !== this._timer && (cancelAnimationFrame(this._timer), this._timer = null) } } Object.defineProperty(n, "delay", { enumerable: !0, configurable: !0, writable: !0, value: 200 }); let o = null; class l { constructor(e, t) { Object.defineProperty(this, "_sensor", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_element", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_listener", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_disposed", { enumerable: !0, configurable: !0, writable: !0, value: !1 }), this._sensor = (null === o && (o = "undefined" != typeof ResizeObserver ? new r : new n), o), this._element = e, this._listener = a.onZoom(t), this._sensor.addTarget(e, t) } isDisposed() { return this._disposed } dispose() { this._disposed || (this._disposed = !0, this._sensor.removeTarget(this._element), this._listener.dispose()) } get sensor() { return this._sensor } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/States.js": (e, t, i) => { i.r(t), i.d(t, { State: () => r, States: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js"); class r { constructor(e, t) { Object.defineProperty(this, "_entity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_settings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_userSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), this._entity = e, this._settings = t, s.each(t, (e => { this._userSettings[e] = !0 })) } get(e, t) { const i = this._settings[e]; return void 0 !== i ? i : t } setRaw(e, t) { this._settings[e] = t } set(e, t) { this._userSettings[e] = !0, this.setRaw(e, t) } remove(e) { delete this._userSettings[e], delete this._settings[e] } setAll(e) { s.keys(e).forEach((t => { this.set(t, e[t]) })) } _eachSetting(e) { s.each(this._settings, e) } apply() { const e = { stateAnimationEasing: !0, stateAnimationDuration: !0 }, t = this._entity.states.lookup("default"); this._eachSetting(((i, s) => { e[i] || (e[i] = !0, this !== t && (i in t._settings || (t._settings[i] = this._entity.get(i))), this._entity.set(i, s)) })) } applyAnimate(e) { null == e && (e = this._settings.stateAnimationDuration), null == e && (e = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0))); let t = this._settings.stateAnimationEasing; null == t && (t = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", a.cubic))); const i = this._entity.states.lookup("default"), s = { stateAnimationEasing: !0, stateAnimationDuration: !0 }, r = {}; return this._eachSetting(((a, n) => { if (!s[a]) { s[a] = !0, this != i && (a in i._settings || (i._settings[a] = this._entity.get(a))); const o = this._entity.animate({ key: a, to: n, duration: e, easing: t }); o && (r[a] = o) } })), r } } class n { constructor(e) { Object.defineProperty(this, "_states", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_entity", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._entity = e } lookup(e) { return this._states[e] } create(e, t) { const i = this._states[e]; if (i) return i.setAll(t), i; { const i = new r(this._entity, t); return this._states[e] = i, i } } remove(e) { delete this._states[e] } apply(e) { const t = this._states[e]; t && t.apply(), this._entity._applyState(e) } applyAnimate(e, t) { let i; const s = this._states[e]; return s && (i = s.applyAnimate(t)), this._entity._applyStateAnimated(e, t), i } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Template.js": (e, t, i) => { i.r(t), i.d(t, { Template: () => c, TemplateAdapters: () => h, TemplateState: () => o, TemplateStates: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"); class o { constructor(e, t, i) { Object.defineProperty(this, "_settings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_name", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_template", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._name = e, this._template = t, this._settings = i } get(e, t) { const i = this._settings[e]; return void 0 !== i ? i : t } set(e, t) { this._settings[e] = t, this._template._stateChanged(this._name) } remove(e) { delete this._settings[e], this._template._stateChanged(this._name) } setAll(e) { n.keys(e).forEach((t => { this._settings[t] = e[t] })), this._template._stateChanged(this._name) } _apply(e, t) { n.each(this._settings, ((i, s) => { t[i] || e._userSettings[i] || (t[i] = !0, e.setRaw(i, s)) })) } } class l { constructor(e) { Object.defineProperty(this, "_template", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_states", { enumerable: !0, configurable: !0, writable: !0, value: {} }), this._template = e } lookup(e) { return this._states[e] } create(e, t) { const i = this._states[e]; if (i) return i.setAll(t), i; { const i = new o(e, this._template, t); return this._states[e] = i, this._template._stateChanged(e), i } } remove(e) { delete this._states[e], this._template._stateChanged(e) } _apply(e, t) { n.each(this._states, ((i, s) => { let a = t.states[i]; null == a && (a = t.states[i] = {}); const r = e.states.create(i, {}); s._apply(r, a) })) } } class h { constructor() { Object.defineProperty(this, "_callbacks", { enumerable: !0, configurable: !0, writable: !0, value: {} }) } add(e, t) { let i = this._callbacks[e]; return void 0 === i && (i = this._callbacks[e] = []), i.push(t), new a.Disposer((() => { r.removeFirst(i, t), 0 === i.length && delete this._callbacks[e] })) } remove(e) { void 0 !== this._callbacks[e] && delete this._callbacks[e] } _apply(e) { const t = []; return n.each(this._callbacks, ((i, s) => { r.each(s, (s => { t.push(e.adapters.add(i, s)) })) })), new a.MultiDisposer(t) } } class c { constructor(e, t) { if (Object.defineProperty(this, "_settings", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_privateSettings", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_settingEvents", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_privateSettingEvents", { enumerable: !0, configurable: !0, writable: !0, value: {} }), Object.defineProperty(this, "_entities", { enumerable: !0, configurable: !0, writable: !0, value: [] }), Object.defineProperty(this, "states", { enumerable: !0, configurable: !0, writable: !0, value: new l(this) }), Object.defineProperty(this, "adapters", { enumerable: !0, configurable: !0, writable: !0, value: new h }), Object.defineProperty(this, "events", { enumerable: !0, configurable: !0, writable: !0, value: new s.EventDispatcher }), Object.defineProperty(this, "setup", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), !t) throw new Error("You cannot use `new Class()`, instead use `Class.new()`"); this._settings = e } static new(e) { return new c(e, !0) } get entities() { return this._entities } get(e, t) { const i = this._settings[e]; return void 0 !== i ? i : t } setRaw(e, t) { this._settings[e] = t } set(e, t) { this._settings[e] !== t && (this.setRaw(e, t), this._entities.forEach((i => { i._setTemplateProperty(this, e, t) }))) } remove(e) { e in this._settings && (delete this._settings[e], this._entities.forEach((t => { t._removeTemplateProperty(e) }))) } removeAll() { n.each(this._settings, ((e, t) => { this.remove(e) })) } getPrivate(e, t) { const i = this._privateSettings[e]; return void 0 !== i ? i : t } setPrivateRaw(e, t) { return this._privateSettings[e] = t, t } setPrivate(e, t) { return this._privateSettings[e] !== t && (this.setPrivateRaw(e, t), this._entities.forEach((i => { i._setTemplatePrivateProperty(this, e, t) }))), t } removePrivate(e) { e in this._privateSettings && (delete this._privateSettings[e], this._entities.forEach((t => { t._removeTemplatePrivateProperty(e) }))) } setAll(e) { n.each(e, ((e, t) => { this.set(e, t) })) } on(e, t) { let i = this._settingEvents[e]; return void 0 === i && (i = this._settingEvents[e] = []), i.push(t), new a.Disposer((() => { r.removeFirst(i, t), 0 === i.length && delete this._settingEvents[e] })) } onPrivate(e, t) { let i = this._privateSettingEvents[e]; return void 0 === i && (i = this._privateSettingEvents[e] = []), i.push(t), new a.Disposer((() => { r.removeFirst(i, t), 0 === i.length && delete this._privateSettingEvents[e] })) } _apply(e, t) { const i = []; return n.each(this._settingEvents, ((t, s) => { r.each(s, (s => { i.push(e.on(t, s)) })) })), n.each(this._privateSettingEvents, ((t, s) => { r.each(s, (s => { i.push(e.onPrivate(t, s)) })) })), this.states._apply(e, t), i.push(this.adapters._apply(e)), i.push(e.events.copyFrom(this.events)), new a.MultiDisposer(i) } _setObjectTemplate(e) { this._entities.push(e) } _removeObjectTemplate(e) { r.remove(this._entities, e) } _stateChanged(e) { this._entities.forEach((t => { t._applyStateByKey(e) })) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/TextFormatter.js": (e, t, i) => { i.r(t), i.d(t, { TextFormatter: () => r }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"); class r { static escape(e) { return e.replace(/\[\[/g, this.prefix + "1").replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").replace(/\]\]/g, this.prefix + "2").replace(/\{\{/g, this.prefix + "3").replace(/\}\}/g, this.prefix + "4").replace(/\'\'/g, this.prefix + "5") } static unescape(e) { return e.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "''") } static cleanUp(e) { return e.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'") } static chunk(e, t = !1, i = !1) { let s = []; e = this.escape(e); let r = t ? e.split("'") : [e]; for (let e = 0; e < r.length; e++) { let t = r[e]; if ("" !== t) if (e % 2 == 0) { t = t.replace(/\]\[/g, "]" + a.PLACEHOLDER + "["), t = t.replace(/\[\]/g, "[ ]"); let e = t.split(/[\[\]]+/); for (let t = 0; t < e.length; t++) { let r = this.cleanUp(this.unescape(e[t])); r !== a.PLACEHOLDER && ("" !== r && (t % 2 == 0 ? s.push({ type: "value", text: r }) : s.push({ type: i ? "value" : "format", text: "[" + r + "]" }))) } } else { let e = t.split(/[\[\]]+/); for (let t = 0; t < e.length; t++) { let i = this.cleanUp(this.unescape(e[t])); "" !== i && (t % 2 == 0 ? s.push({ type: "text", text: i }) : this.isImage(i) ? s.push({ type: "image", text: "[" + i + "]" }) : s.push({ type: "format", text: "[" + i + "]" })) } } } return s } static isImage(e) { return !!e.match(/img[ ]?:/) } static getTextStyle(e) { let t = {}; if ("" == e || "[ ]" == e) return {}; const i = e.match(/('[^']*')|("[^"]*")/gi); if (i) for (let t = 0; t < i.length; t++)e = e.replace(i[t], i[t].replace(/['"]*/g, "").replace(/[ ]+/g, "+")); let a = e.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi); if (!a) return {}; for (let e = 0; e < a.length; e++)if (a[e].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) t.fontWeight = a[e]; else if (a[e].match(/^(underline|line-through)$/i)) t.textDecoration = a[e]; else if ("/" == a[e]); else if (a[e].match(/:/)) { const i = a[e].replace("+", " ").split(/:[ ]*/); t[i[0]] = i[1] } else t.fill = s.Color.fromString(a[e]); return t } } Object.defineProperty(r, "prefix", { enumerable: !0, configurable: !0, writable: !0, value: "__amcharts__" }) }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Time.js": (e, t, i) => { i.r(t), i.d(t, { add: () => g, checkChange: () => p, chooseInterval: () => f, copy: () => m, getDateIntervalDuration: () => c, getDuration: () => l, getIntervalDuration: () => h, getNextUnit: () => o, getTime: () => d, getUnitValue: () => y, now: () => u, roun: () => b, round: () => _, sleep: () => r, timeUnitDurations: () => n }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js"); function r(e) { return new Promise(((t, i) => { setTimeout(t, e) })) } let n = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 2629742400, year: 31536e6 }; function o(e) { switch (e) { case "year": return; case "month": return "year"; case "week": case "day": return "month"; case "hour": return "day"; case "minute": return "hour"; case "second": return "minute"; case "millisecond": return "second" } } function l(e, t) { return null == t && (t = 1), n[e] * t } function h(e) { return e ? n[e.timeUnit] * e.count : 0 } function c(e, t, i, s, a) { const r = e.timeUnit, o = e.count; if ("hour" == r || "minute" == r || "second" == r || "millisecond" == r) return n[e.timeUnit] * e.count; { const e = _(new Date(t.getTime()), r, o, i, s, void 0, a).getTime(); let n = e + o * l(r) * 1.05; return n = _(new Date(n), r, 1, i, s, void 0, a).getTime(), n - e } } function u() { return new Date } function d() { return u().getTime() } function m(e) { return new Date(e.getTime()) } function p(e, t, i, s, a) { if (t - e > l(i, 1.2)) return !0; let r = new Date(e), n = new Date(t); a && (r = a.convertLocal(r), n = a.convertLocal(n)); let h = 0, c = 0; s || "millisecond" == i || (h = r.getTimezoneOffset(), r.setUTCMinutes(r.getUTCMinutes() - h), c = n.getTimezoneOffset(), n.setUTCMinutes(n.getUTCMinutes() - c)); let u = !1; switch (i) { case "year": r.getUTCFullYear() != n.getUTCFullYear() && (u = !0); break; case "month": (r.getUTCFullYear() != n.getUTCFullYear() || r.getUTCMonth() != n.getUTCMonth()) && (u = !0); break; case "day": (r.getUTCMonth() != n.getUTCMonth() || r.getUTCDate() != n.getUTCDate()) && (u = !0); break; case "hour": r.getUTCHours() != n.getUTCHours() && (u = !0); break; case "minute": r.getUTCMinutes() != n.getUTCMinutes() && (u = !0); break; case "second": r.getUTCSeconds() != n.getUTCSeconds() && (u = !0); break; case "millisecond": r.getTime() != n.getTime() && (u = !0) }if (u) return u; let d = o(i); return !!d && p(e, t, d, s, a) } function g(e, t, i, s, a) { let r = 0; switch (s || "millisecond" == t || (r = e.getTimezoneOffset(), a && (r -= a.offsetUTC(e)), e.setUTCMinutes(e.getUTCMinutes() - r)), t) { case "day": let t = e.getUTCDate(); e.setUTCDate(t + i); break; case "second": let s = e.getUTCSeconds(); e.setUTCSeconds(s + i); break; case "millisecond": let a = e.getUTCMilliseconds(); e.setUTCMilliseconds(a + i); break; case "hour": let r = e.getUTCHours(); e.setUTCHours(r + i); break; case "minute": let n = e.getUTCMinutes(); e.setUTCMinutes(n + i); break; case "year": let o = e.getUTCFullYear(); e.setUTCFullYear(o + i); break; case "month": const l = e.getUTCDate(), h = new Date(e.getUTCFullYear(), e.getUTCMonth(), 0).getUTCDate(); let c = e.getUTCMonth(); l > h ? e.setUTCMonth(c + i, h) : e.setUTCMonth(c + i); break; case "week": let u = e.getUTCDate(); e.setUTCDate(u + 7 * i) }if (!s && "millisecond" != t && (e.setUTCMinutes(e.getUTCMinutes() + r), "day" == t || "week" == t || "month" == t || "year" == t)) { let t = e.getTimezoneOffset(); if (a && (t += a.offsetUTC(e)), t != r) { let i = t - r; e.setUTCMinutes(e.getUTCMinutes() + i), e.getTimezoneOffset() != t && e.setUTCMinutes(e.getUTCMinutes() - i) } } return e } function b(e, t, i, s, a) { let r; return null != a && (r = new Date(a)), _(new Date(e), t, i, s.locale.firstDayOfWeek, s.utc, r, s.timezone).getTime() } function _(e, t, i, a, r, n, o) { if (!o || r) { let o = 0; switch (r || "millisecond" == t || (o = e.getTimezoneOffset(), e.setUTCMinutes(e.getUTCMinutes() - o)), t) { case "day": let t = e.getUTCDate(); if (i > 1) { if (n) { n = _(n, "day", 1); let t = e.getTime() - n.getTime(), s = Math.floor(t / l("day") / i), a = l("day", s * i); e.setTime(n.getTime() + a - o * l("minute")) } } else e.setUTCDate(t); e.setUTCHours(0, 0, 0, 0); break; case "second": let r = e.getUTCSeconds(); i > 1 && (r = Math.floor(r / i) * i), e.setUTCSeconds(r, 0); break; case "millisecond": if (1 == i) return e; let h = e.getUTCMilliseconds(); h = Math.floor(h / i) * i, e.setUTCMilliseconds(h); break; case "hour": let c = e.getUTCHours(); i > 1 && (c = Math.floor(c / i) * i), e.setUTCHours(c, 0, 0, 0); break; case "minute": let u = e.getUTCMinutes(); i > 1 && (u = Math.floor(u / i) * i), e.setUTCMinutes(u, 0, 0); break; case "month": let d = e.getUTCMonth(); i > 1 && (d = Math.floor(d / i) * i), e.setUTCMonth(d, 1), e.setUTCHours(0, 0, 0, 0); break; case "year": let m = e.getUTCFullYear(); i > 1 && (m = Math.floor(m / i) * i), e.setUTCFullYear(m, 0, 1), e.setUTCHours(0, 0, 0, 0); break; case "week": if (i > 1 && n) { n = _(n, "week", 1); let t = e.getTime() - n.getTime(), s = Math.floor(t / l("week") / i), a = l("week", s * i); e.setTime(n.getTime() + a - o * l("minute")) } let p = e.getUTCDate(), g = e.getUTCDay(); s.isNumber(a) || (a = 1), p = g >= a ? p - g + a : p - (7 + g) + a, e.setUTCDate(p), e.setUTCHours(0, 0, 0, 0) }if (!r && "millisecond" != t && (e.setUTCMinutes(e.getUTCMinutes() + o), "day" == t || "week" == t || "month" == t || "year" == t)) { let t = e.getTimezoneOffset(); if (t != o) { let i = t - o; e.setUTCMinutes(e.getUTCMinutes() + i) } } return e } { if (isNaN(e.getTime())) return e; let h = o.offsetUTC(e), c = e.getTimezoneOffset(), u = o.parseDate(e), d = u.year, m = u.month, p = u.day, g = u.hour, b = u.minute, f = u.second, y = u.millisecond, v = u.weekday, x = h - c; switch (t) { case "day": if (i > 1 && n) { n = _(n, "day", 1, a, r, void 0, o); let t = e.getTime() - n.getTime(), s = Math.floor(t / l("day") / i), h = l("day", s * i); e.setTime(n.getTime() + h), u = o.parseDate(e), d = u.year, m = u.month, p = u.day } g = 0, b = x, f = 0, y = 0; break; case "second": b += x, i > 1 && (f = Math.floor(f / i) * i), y = 0; break; case "millisecond": b += x, i > 1 && (y = Math.floor(y / i) * i); break; case "hour": i > 1 && (g = Math.floor(g / i) * i), b = x, f = 0, y = 0; break; case "minute": i > 1 && (b = Math.floor(b / i) * i), b += x, f = 0, y = 0; break; case "month": i > 1 && (m = Math.floor(m / i) * i), p = 1, g = 0, b = x, f = 0, y = 0; break; case "year": i > 1 && (d = Math.floor(d / i) * i), m = 0, p = 1, g = 0, b = x, f = 0, y = 0; break; case "week": s.isNumber(a) || (a = 1), p = v >= a ? p - v + a : p - (7 + v) + a, g = 0, b = x, f = 0, y = 0 }let w = (e = new Date(d, m, p, g, b, f, y)).getTimezoneOffset(), P = o.offsetUTC(e) - w; return P != x && e.setTime(e.getTime() + 6e4 * (P - x)), e } } function f(e, t, i, s) { let a = h(s[e]), r = s.length - 1; if (e >= r) return Object.assign({}, s[r]); let n = Math.ceil(t / a); return t < a && e > 0 ? Object.assign({}, s[e - 1]) : n <= i ? Object.assign({}, s[e]) : e + 1 < s.length ? f(e + 1, t, i, s) : Object.assign({}, s[e]) } function y(e, t) { switch (t) { case "day": return e.getDate(); case "second": return e.getSeconds(); case "millisecond": return e.getMilliseconds(); case "hour": return e.getHours(); case "minute": return e.getMinutes(); case "month": return e.getMonth(); case "year": return e.getFullYear(); case "week": return a.getWeek(e) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Timezone.js": (e, t, i) => { function s(e, t) { let i = 0, s = 0, a = 1, r = 0, n = 0, o = 0, l = 0, h = 0; return e.formatToParts(t).forEach((e => { switch (e.type) { case "year": i = +e.value; break; case "month": s = +e.value - 1; break; case "day": a = +e.value; break; case "hour": r = +e.value; break; case "minute": n = +e.value; break; case "second": o = +e.value; break; case "fractionalSecond": l = +e.value; break; case "weekday": switch (e.value) { case "Sun": h = 0; break; case "Mon": h = 1; break; case "Tue": h = 2; break; case "Wed": h = 3; break; case "Thu": h = 4; break; case "Fri": h = 5; break; case "Sat": h = 6 } } })), 24 === r && (r = 0), { year: i, month: s, day: a, hour: r, minute: n, second: o, millisecond: l, weekday: h } } function a(e, t) { const { year: i, month: a, day: r, hour: n, minute: o, second: l, millisecond: h } = s(e, t); return Date.UTC(i, a, r, n, o, l, h) } i.r(t), i.d(t, { Timezone: () => r }); class r { constructor(e, t) { if (Object.defineProperty(this, "_utc", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_dtf", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "name", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), !t) throw new Error("You cannot use `new Class()`, instead use `Class.new()`"); this.name = e, this._utc = new Intl.DateTimeFormat("UTC", { hour12: !1, timeZone: "UTC", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "short", fractionalSecondDigits: 3 }), this._dtf = new Intl.DateTimeFormat("UTC", { hour12: !1, timeZone: e, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "short", fractionalSecondDigits: 3 }) } static new(e) { return new this(e, !0) } convertLocal(e) { const t = this.offsetUTC(e), i = e.getTimezoneOffset(), s = new Date(e); s.setUTCMinutes(s.getUTCMinutes() - (t - i)); const a = s.getTimezoneOffset(); return i != a && s.setUTCMinutes(s.getUTCMinutes() + a - i), s } offsetUTC(e) { return (a(this._utc, e) - a(this._dtf, e)) / 6e4 } parseDate(e) { return s(this._dtf, e) } } }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js": (e, t, i) => { function s(e) { return Number(e) !== e } function a(e) { return {}.toString.call(e) } function r(e, t = "Assertion failed") { if (!e) throw new Error(t) } function n(e) { if (null != e && !d(e)) { let t = Number(e); return s(t) && u(e) && "" != e ? n(e.replace(/[^0-9.\-]+/g, "")) : t } return e } function o(e) { if (c(e)) return new Date(e); if (d(e)) return new Date(e); { let t = Number(e); return d(t) ? new Date(t) : new Date(e) } } function l(e) { if (s(e)) return "NaN"; if (e === 1 / 0) return "Infinity"; if (e === -1 / 0) return "-Infinity"; if (0 === e && 1 / e == -1 / 0) return "-0"; let t = e < 0; e = Math.abs(e); let i, a = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + e), r = a[1], n = a[2] || ""; if (void 0 === a[3]) i = "" === n ? r : r + "." + n; else { let t = +a[3]; if (e < 1) { i = "0." + h("0", t - 1) + r + n } else { let e = t - n.length; i = 0 === e ? r + n : e < 0 ? r + n.slice(0, e) + "." + n.slice(e) : r + n + h("0", e) } } return t ? "-" + i : i } function h(e, t) { return new Array(t + 1).join(e) } function c(e) { return "[object Date]" === a(e) } function u(e) { return "string" == typeof e } function d(e) { return "number" == typeof e && Number(e) == e } function m(e) { return "object" == typeof e && null !== e } function p(e) { return Array.isArray(e) } i.r(t), i.d(t, { PLACEHOLDER: () => g, PLACEHOLDER2: () => b, assert: () => r, getType: () => a, isArray: () => p, isDate: () => c, isNaN: () => s, isNumber: () => d, isObject: () => m, isString: () => u, numberToString: () => l, repeat: () => h, toDate: () => o, toNumber: () => n }); const g = "____", b = "____" }, "./node_modules/@amcharts/amcharts5/.internal/core/util/Utils.js": (e, t, i) => { i.r(t), i.d(t, { StyleRule: () => j, StyleSheet: () => C, addClass: () => O, addEventListener: () => h, addSpacing: () => U, alternativeColor: () => de, blur: () => m, brighten: () => le, capitalizeFirst: () => te, cleanFormat: () => H, contains: () => v, decimalPlaces: () => E, escapeForRgex: () => V, focus: () => p, get12Hours: () => $, getBrightnessStep: () => he, getDayFromWeek: () => J, getEventKey: () => P, getEventTarget: () => y, getFormat: () => Y, getLightnessStep: () => oe, getMonthWeek: () => q, getPointerId: () => d, getRendererEvent: () => g, getSafeResolution: () => M, getShadowRoot: () => T, getStyle: () => f, getTimeZone: () => Q, getTimezoneOffset: () => ee, getWeek: () => K, getWeekYear: () => Z, getYearDay: () => W, hslToHsv: () => re, hslToRgb: () => ie, hsvToHsl: () => ae, iOS: () => A, isLight: () => ce, isLocalEvent: () => x, isTouchEvent: () => b, lighten: () => ne, mergeTags: () => me, onZoom: () => c, padString: () => R, plainText: () => z, ready: () => o, relativeToValue: () => L, removeClass: () => S, removeElement: () => l, rgbToHsl: () => se, sameBounds: () => pe, saturate: () => ue, setInteractive: () => w, setStyle: () => _, splitString: () => G, stripTags: () => X, supports: () => u, trim: () => F, trimLeft: () => I, trimRight: () => B, truncateTextWithEllipsis: () => N }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Type.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Array.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Object.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Disposer.js"); function o(e) { if ("loading" !== document.readyState) e(); else { const t = () => { "loading" !== document.readyState && (document.removeEventListener("readystatechange", t), e()) }; document.addEventListener("readystatechange", t) } } function l(e) { e.parentNode && e.parentNode.removeChild(e) } function h(e, t, i, s) { return e.addEventListener(t, i, s || !1), new n.Disposer((() => { e.removeEventListener(t, i, s || !1) })) } function c(e) { return h(window, "resize", (t => { e() })) } function u(e) { switch (e) { case "touchevents": return window.hasOwnProperty("TouchEvent"); case "pointerevents": return window.hasOwnProperty("PointerEvent"); case "mouseevents": return window.hasOwnProperty("MouseEvent"); case "wheelevents": return window.hasOwnProperty("WheelEvent"); case "keyboardevents": return window.hasOwnProperty("KeyboardEvent") }return !1 } function d(e) { return e.pointerId || 0 } function m() { if (document.activeElement && document.activeElement != document.body) if (document.activeElement.blur) document.activeElement.blur(); else { let e = document.createElement("button"); e.style.position = "fixed", e.style.top = "0px", e.style.left = "-10000px", document.body.appendChild(e), e.focus(), e.blur(), document.body.removeChild(e) } } function p(e) { e && e.focus() } function g(e) { if (u("pointerevents")) return e; if (u("touchevents")) switch (e) { case "pointerover": case "pointerdown": return "touchstart"; case "pointerout": case "pointerleave": case "pointerup": return "touchend"; case "pointermove": return "touchmove"; case "click": return "click"; case "dblclick": return "dblclick" } else if (u("mouseevents")) switch (e) { case "pointerover": return "mouseover"; case "pointerout": return "mouseout"; case "pointerleave": return "mouseleave"; case "pointerdown": return "mousedown"; case "pointermove": return "mousemove"; case "pointerup": return "mouseup"; case "click": return "click"; case "dblclick": return "dblclick" }return e } function b(e) { if ("undefined" != typeof Touch && e instanceof Touch) return !0; if ("undefined" != typeof PointerEvent && e instanceof PointerEvent && null != e.pointerType) switch (e.pointerType) { case "touch": case "pen": case 2: return !0; case "mouse": case 4: return !1; default: return !(e instanceof MouseEvent) } else if (null != e.type && e.type.match(/^mouse/)) return !1; return !0 } function _(e, t, i) { e.style[t] = i } function f(e, t) { return e.style[t] } function y(e) { if (e.composedPath) { const t = e.composedPath(); return 0 === t.length ? null : t[0] } return e.target } function v(e, t) { let i = t; for (; ;) { if (e === i) return !0; if (null === i.parentNode) { if (null == i.host) return !1; i = i.host } else i = i.parentNode } } function x(e, t) { return e.target && v(t.root.dom, e.target) } function w(e, t) { e.style.pointerEvents = t ? "auto" : "none" } function P(e) { if (void 0 !== e.key) return e.key; switch (e.keyCode) { case 9: return "Tab"; case 13: return "Enter"; case 16: return "Shift"; case 17: return "Control"; case 27: return "Escape"; case 32: return " "; case 37: return "ArrowLeft"; case 38: return "ArrowUp"; case 39: return "ArrowRight"; case 40: return "ArrowDown"; case 46: return "Delete" }return "" + e.keyCode } function T(e) { let t = e; for (; ;) { if (null === t.parentNode) return null != t.host ? t : null; t = t.parentNode } } let D; function k(e, t) { const i = e.cssRules.length; return e.insertRule(t + "{}", i), e.cssRules[i] } class j extends n.DisposerClass { constructor(e, t, i, s = "") { super(), Object.defineProperty(this, "_root", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), Object.defineProperty(this, "_rule", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._root = function (e, t = "") { if (null === e) { if (null == D) { const e = document.createElement("style"); e.type = "text/css", "" != t && e.setAttribute("nonce", t), document.head.appendChild(e), D = e.sheet } return D } { const i = document.createElement("style"); return i.type = "text/css", "" != t && i.setAttribute("nonce", t), e.appendChild(i), i.sheet } }(e, s); try { this._rule = k(this._root, t) } catch (e) { this._rule = k(this._root, ":not(*)") } r.each(i, ((e, t) => { this.setStyle(e, t) })) } set selector(e) { this._rule.selectorText = e } get selector() { return this._rule.selectorText } _dispose() { const e = a.indexOf(this._root.cssRules, this._rule); if (-1 === e) throw new Error("Could not dispose StyleRule"); this._root.deleteRule(e) } _setVendorPrefixName(e, t) { const i = this._rule.style; i.setProperty("-webkit-" + e, t, ""), i.setProperty("-moz-" + e, t, ""), i.setProperty("-ms-" + e, t, ""), i.setProperty("-o-" + e, t, ""), i.setProperty(e, t, "") } setStyle(e, t) { "transition" === e ? this._setVendorPrefixName(e, t) : this._rule.style.setProperty(e, t, "") } } class C extends n.DisposerClass { constructor(e, t, i = "") { super(), Object.defineProperty(this, "_element", { enumerable: !0, configurable: !0, writable: !0, value: void 0 }), this._element = function (e, t, i = "") { const s = document.createElement("style"); return s.type = "text/css", "" != i && s.setAttribute("nonce", i), s.textContent = t, null === e ? document.head.appendChild(s) : e.appendChild(s), s }(e, t, i) } _dispose() { this._element.parentNode && this._element.parentNode.removeChild(this._element) } } function O(e, t) { if (e) if (e.classList) { const i = t.split(" "); a.each(i, (t => { e.classList.add(t) })) } else { let i = e.getAttribute("class"); i ? e.setAttribute("class", i.split(" ").filter((e => e !== t)).join(" ") + " " + t) : e.setAttribute("class", t) } } function S(e, t) { if (e) if (e.classList) e.classList.remove(t); else { let i = e.getAttribute("class"); i && e.setAttribute("class", i.split(" ").filter((e => e !== t)).join(" ")) } } function A() { return /apple/i.test(navigator.vendor) && "ontouchend" in document } function M() { return A() ? 1 : void 0 } function L(e, t) { return s.isNumber(e) ? e : null != e && s.isNumber(e.value) && s.isNumber(t) ? t * e.value : 0 } function E(e) { let t = ("" + e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/); return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0 } function R(e, t = 0, i = "0") { return "string" != typeof e && (e = e.toString()), t > e.length ? Array(t - e.length + 1).join(i) + e : e } function I(e) { return e.replace(/^[\s]*/, "") } function B(e) { return e.replace(/[\s]*$/, "") } function F(e) { return I(B(e)) } function N(e, t, i = !1, s = "...") { if (e.length > t) { let a = t - 1; for (; a >= 0 && e.charAt(a).match(/\w/);)a--; return a >= 0 && 0 == i ? e.substring(0, a + 1) + "..." : e.substring(0, t) + s } return e } function Y(e) { if (void 0 === e) return "string"; let t = (e = (e = (e = e.toLowerCase().replace(/^\[[^\]]*\]/, "")).replace(/\[[^\]]+\]/, "")).trim()).match(/\/(date|number|duration)$/); return t ? t[1] : "number" === e ? "number" : "date" === e ? "date" : "duration" === e ? "duration" : e.match(/[#0]/) ? "number" : e.match(/[ymwdhnsqaxkzgtei]/) ? "date" : "string" } function H(e) { return e.replace(/\/(date|number|duration)$/i, "") } function X(e) { return e ? e.replace(/<[^>]*>/g, "") : e } function z(e) { return e ? X(("" + e).replace(/[\n\r]+/g, ". ")) : e } function V(e) { return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") } function U(e) { let t = ""; for (let i = 0; i < e.length; i++) { const s = e.charAt(i); s.toUpperCase() == s && 0 != i && (t += " "), t += s } return t } function G(e) { const t = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/, i = /([^]*[])/gi; let s = e.split(/(\s+)/), a = []; return s.forEach((e => { if (e.match(/^\s+$/)) (e = " ") && (e = "  "), a.push(e); else if (t.test(e)) { let t = e.split(i).filter((e => "" !== e)); a = a.concat(t) } else a = a.concat([...e]) })), a } function W(e, t = !1) { const i = new Date(e.getFullYear(), 0, 0), s = e.getTime() - i.getTime() + 60 * (i.getTimezoneOffset() - e.getTimezoneOffset()) * 1e3; return Math.floor(s / 864e5) } function K(e, t = !1) { const i = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())), s = i.getUTCDay() || 7; i.setUTCDate(i.getUTCDate() + 4 - s); const a = new Date(Date.UTC(i.getUTCFullYear(), 0, 1)); return Math.ceil(((i.getTime() - a.getTime()) / 864e5 + 1) / 7) } function Z(e, t = !1) { const i = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate())), s = i.getUTCDay() || 7; i.setUTCDate(i.getUTCDate() + 4 - s); return new Date(Date.UTC(i.getUTCFullYear(), 0, 1)).getFullYear() } function q(e, t = !1) { const i = K(new Date(e.getFullYear(), e.getMonth(), 1), t); let s = K(e, t); return 1 == s && (s = 53), s - i + 1 } function J(e, t, i = 1, s = !1) { let a = new Date(t, 0, 4, 0, 0, 0, 0); return s && a.setUTCFullYear(t), 7 * e + i - ((a.getDay() || 7) + 3) } function $(e, t) { return e > 12 ? e -= 12 : 0 === e && (e = 12), null != t ? e + (t - 1) : e } function Q(e, t = !1, i = !1, s = !1, a) { if (s) return t ? "Coordinated Universal Time" : "UTC"; if (a) { const i = e.toLocaleString("en-US", { timeZone: a }); return F(e.toLocaleString("en-US", { timeZone: a, timeZoneName: t ? "long" : "short" }).substr(i.length)) } let r = e.toLocaleString("UTC"), n = e.toLocaleString("UTC", { timeZoneName: t ? "long" : "short" }).substr(r.length); return !1 === i && (n = n.replace(/ (standard|daylight|summer|winter) /i, " ")), F(n) } function ee(e) { const t = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0)), i = new Date(t.toLocaleString("en-US", { timeZone: "UTC" })); return (new Date(t.toLocaleString("en-US", { timeZone: e })).getTime() - i.getTime()) / 6e4 * -1 } function te(e) { return e.charAt(0).toUpperCase() + e.slice(1) } function ie(e) { let t, i, s, a = e.h, r = e.s, n = e.l; if (0 == r) t = i = s = n; else { let e = function (e, t, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e }, o = n < .5 ? n * (1 + r) : n + r - n * r, l = 2 * n - o; t = e(l, o, a + 1 / 3), i = e(l, o, a), s = e(l, o, a - 1 / 3) } return { r: Math.round(255 * t), g: Math.round(255 * i), b: Math.round(255 * s) } } function se(e) { let t = e.r / 255, i = e.g / 255, s = e.b / 255, a = Math.max(t, i, s), r = Math.min(t, i, s), n = 0, o = 0, l = (a + r) / 2; if (a === r) n = o = 0; else { let e = a - r; switch (o = l > .5 ? e / (2 - a - r) : e / (a + r), a) { case t: n = (i - s) / e + (i < s ? 6 : 0); break; case i: n = (s - t) / e + 2; break; case s: n = (t - i) / e + 4 }n /= 6 } return { h: n, s: o, l } } function ae(e) { const t = e.v * (1 - e.s / 2), i = 0 === t || 1 === t ? 0 : (e.v - t) / Math.min(t, 1 - t); return { h: e.h, s: i, l: t, a: e.a } } function re(e) { const t = e.l + e.s * Math.min(e.l, 1 - e.l), i = 0 === t ? 0 : 2 * (1 - e.l / t); return { h: e.h, s: i, v: t, a: e.a } } function ne(e, t) { return e ? { r: Math.max(0, Math.min(255, e.r + oe(e.r, t))), g: Math.max(0, Math.min(255, e.g + oe(e.g, t))), b: Math.max(0, Math.min(255, e.b + oe(e.b, t))), a: e.a } : e } function oe(e, t) { let i = t > 0 ? 255 - e : e; return Math.round(i * t) } function le(e, t) { if (e) { let i = oe(Math.min(Math.max(e.r, e.g, e.b), 230), t); return { r: Math.max(0, Math.min(255, Math.round(e.r + i))), g: Math.max(0, Math.min(255, Math.round(e.g + i))), b: Math.max(0, Math.min(255, Math.round(e.b + i))), a: e.a } } return e } function he(e, t) { return Math.round(255 * t) } function ce(e) { return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 >= 128 } function ue(e, t) { if (void 0 === e || 1 == t) return e; let i = se(e); return i.s = t, ie(i) } function de(e, t = { r: 255, g: 255, b: 255 }, i = { r: 255, g: 255, b: 255 }) { let s = t, a = i; return ce(i) && (s = i, a = t), ce(e) ? a : s } function me(e, t) { return e || (e = []), [...e, ...t].filter(((e, t, i) => i.indexOf(e) === t)) } function pe(e, t) { return !!t && (e.left == t.left && (e.right == t.right && (e.top == t.top && e.bottom == t.bottom))) } }, "./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js": (e, t, i) => { i.r(t), i.d(t, { AnimatedTheme: () => a }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/Theme.js"); class a extends s.Theme { setupDefaultRules() { super.setupDefaultRules(), this.rule("Component").setAll({ interpolationDuration: 600 }), this.rule("Hierarchy").set("animationDuration", 600), this.rule("Scrollbar").set("animationDuration", 600), this.rule("Tooltip").set("animationDuration", 300), this.rule("MapChart").set("animationDuration", 1e3), this.rule("MapChart").set("wheelDuration", 300), this.rule("Entity").setAll({ stateAnimationDuration: 600 }), this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 }), this.rule("Tooltip", ["axis"]).setAll({ animationDuration: 200 }), this.rule("WordCloud").set("animationDuration", 500), this.rule("Polygon").set("animationDuration", 600), this.rule("ArcDiagram").set("animationDuration", 600) } } }, "./node_modules/@amcharts/amcharts5/.internal/themes/DefaultTheme.js": (e, t, i) => { i.r(t), i.d(t, { DefaultTheme: () => h, setColor: () => l }); var s = i("./node_modules/@amcharts/amcharts5/.internal/core/Theme.js"), a = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Percent.js"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Color.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/GridLayout.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/core/util/Ease.js"); function l(e, t, i, s) { e.set(t, i.get(s)), i.on(s, (i => { e.set(t, i) })) } class h extends s.Theme { setupDefaultRules() { super.setupDefaultRules(); const e = this._root.language, t = this._root.interfaceColors, i = this._root.horizontalLayout, s = this._root.verticalLayout, h = this.rule.bind(this); h("InterfaceColors").setAll({ stroke: r.Color.fromHex(15066597), fill: r.Color.fromHex(15987699), primaryButton: r.Color.fromHex(6788316), primaryButtonHover: r.Color.fromHex(6779356), primaryButtonDown: r.Color.fromHex(6872182), primaryButtonActive: r.Color.fromHex(6872182), primaryButtonDisabled: r.Color.fromHex(14342874), primaryButtonTextDisabled: r.Color.fromHex(16777215), primaryButtonText: r.Color.fromHex(16777215), primaryButtonStroke: r.Color.fromHex(16777215), secondaryButton: r.Color.fromHex(14277081), secondaryButtonHover: r.Color.fromHex(10724259), secondaryButtonDown: r.Color.fromHex(9276813), secondaryButtonActive: r.Color.fromHex(15132390), secondaryButtonText: r.Color.fromHex(0), secondaryButtonStroke: r.Color.fromHex(16777215), grid: r.Color.fromHex(0), background: r.Color.fromHex(16777215), alternativeBackground: r.Color.fromHex(0), text: r.Color.fromHex(0), alternativeText: r.Color.fromHex(16777215), disabled: r.Color.fromHex(11382189), positive: r.Color.fromHex(5288704), negative: r.Color.fromHex(11730944) }); { const e = h("ColorSet"); e.setAll({ passOptions: { hue: .05, saturation: 0, lightness: 0 }, colors: [r.Color.fromHex(6797276)], step: 1, reuse: !1, startIndex: 0 }), e.setPrivate("currentStep", 0), e.setPrivate("currentPass", 0) } h("Entity").setAll({ stateAnimationDuration: 0, stateAnimationEasing: o.out(o.cubic) }), h("Component").setAll({ interpolationDuration: 0, interpolationEasing: o.out(o.cubic) }), h("Sprite").setAll({ visible: !0, scale: 1, opacity: 1, rotation: 0, position: "relative", tooltipX: a.p50, tooltipY: a.p50, tooltipPosition: "fixed", isMeasured: !0 }), h("Sprite").states.create("default", { visible: !0, opacity: 1 }), h("Container").setAll({ interactiveChildren: !0, setStateOnChildren: !1 }), h("Graphics").setAll({ strokeWidth: 1 }), h("Chart").setAll({ width: a.p100, height: a.p100, interactiveChildren: !1 }), h("ZoomableContainer").setAll({ width: a.p100, height: a.p100, wheelable: !0, pinchZoom: !0, maxZoomLevel: 32, minZoomLevel: 1, zoomStep: 2, animationEasing: o.out(o.cubic), animationDuration: 600, maxPanOut: .4 }), h("Sprite", ["horizontal", "center"]).setAll({ centerX: a.p50, x: a.p50 }), h("Sprite", ["vertical", "center"]).setAll({ centerY: a.p50, y: a.p50 }), h("Container", ["horizontal", "layout"]).setAll({ layout: i }), h("Container", ["vertical", "layout"]).setAll({ layout: s }), h("Pattern").setAll({ repetition: "repeat", width: 50, height: 50, rotation: 0, fillOpacity: 1 }), h("LinePattern").setAll({ gap: 6, colorOpacity: 1, width: 49, height: 49 }), h("RectanglePattern").setAll({ gap: 6, checkered: !1, centered: !0, maxWidth: 5, maxHeight: 5, width: 48, height: 48, strokeWidth: 0 }), h("CirclePattern").setAll({ gap: 5, checkered: !1, centered: !1, radius: 3, strokeWidth: 0, width: 45, height: 45 }), h("GrainPattern").setAll({ width: 200, height: 200, colors: [r.Color.fromHex(0)], size: 1, horizontalGap: 0, verticalGap: 0, density: 1, minOpacity: 0, maxOpacity: .2 }); { const e = h("PatternSet"); e.setAll({ step: 1 }), l(e, "color", t, "stroke") } h("LinearGradient").setAll({ rotation: 90 }), h("Legend").setAll({ fillField: "fill", strokeField: "stroke", nameField: "name", layout: n.GridLayout.new(this._root, {}), layer: 30, clickTarget: "itemContainer" }), h("Container", ["legend", "item", "itemcontainer"]).setAll({ paddingLeft: 5, paddingRight: 5, paddingBottom: 5, paddingTop: 5, layout: i, setStateOnChildren: !0, interactiveChildren: !1, ariaChecked: !0, focusable: !0, ariaLabel: e.translate("Press ENTER to toggle"), role: "checkbox" }); { const e = h("Rectangle", ["legend", "item", "background"]); e.setAll({ fillOpacity: 0 }), l(e, "fill", t, "background") } h("Container", ["legend", "marker"]).setAll({ setStateOnChildren: !0, centerY: a.p50, paddingLeft: 0, paddingRight: 0, paddingBottom: 0, paddingTop: 0, width: 18, height: 18 }), h("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({ width: a.p100, height: a.p100, cornerRadiusBL: 3, cornerRadiusTL: 3, cornerRadiusBR: 3, cornerRadiusTR: 3 }); { const e = h("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {}); l(e, "fill", t, "disabled"), l(e, "stroke", t, "disabled") } h("Label", ["legend", "label"]).setAll({ centerY: a.p50, marginLeft: 5, paddingRight: 0, paddingLeft: 0, paddingTop: 0, paddingBottom: 0, populateText: !0 }); l(h("Label", ["legend", "label"]).states.create("disabled", {}), "fill", t, "disabled"); h("Label", ["legend", "value", "label"]).setAll({ centerY: a.p50, marginLeft: 5, paddingRight: 0, paddingLeft: 0, paddingTop: 0, paddingBottom: 0, width: 50, centerX: a.p100, populateText: !0 }); l(h("Label", ["legend", "value", "label"]).states.create("disabled", {}), "fill", t, "disabled"); h("HeatLegend").setAll({ stepCount: 1 }), h("RoundedRectangle", ["heatlegend", "marker"]).setAll({ cornerRadiusTR: 0, cornerRadiusBR: 0, cornerRadiusTL: 0, cornerRadiusBL: 0 }), h("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({ height: a.p100, width: 15 }), h("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({ width: a.p100, height: 15 }), h("HeatLegend", ["vertical"]).setAll({ height: a.p100 }), h("HeatLegend", ["horizontal"]).setAll({ width: a.p100 }), h("Label", ["heatlegend", "start"]).setAll({ paddingLeft: 5, paddingRight: 5, paddingTop: 5, paddingBottom: 5 }), h("Label", ["heatlegend", "end"]).setAll({ paddingLeft: 5, paddingRight: 5, paddingTop: 5, paddingBottom: 5 }); { const e = h("Label"); e.setAll({ paddingTop: 8, paddingBottom: 8, paddingLeft: 10, paddingRight: 10, fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', fontSize: "1em", populateText: !1 }), l(e, "fill", t, "text") } h("RadialLabel").setAll({ textType: "regular", centerY: a.p50, centerX: a.p50, inside: !1, radius: 0, baseRadius: a.p100, orientation: "auto", textAlign: "center" }), h("EditableLabel").setAll({ editOn: "click", themeTags: ["editablelabel"], multiLine: !0 }), h("RoundedRectangle", ["editablelabel", "background"]).setAll({ fillOpacity: 0, fill: r.Color.fromHex(0), cornerRadiusBL: 3, cornerRadiusBR: 3, cornerRadiusTL: 3, cornerRadiusTR: 3, strokeOpacity: 0, stroke: r.Color.fromHex(0) }), h("RoundedRectangle", ["editablelabel", "background"]).states.create("active", { strokeOpacity: .2 }), h("RoundedRectangle").setAll({ cornerRadiusTL: 8, cornerRadiusBL: 8, cornerRadiusTR: 8, cornerRadiusBR: 8 }), h("PointedRectangle").setAll({ pointerBaseWidth: 15, pointerLength: 10, cornerRadius: 8 }), h("Slice").setAll({ shiftRadius: 0, dRadius: 0, dInnerRadius: 0 }); { const e = h("Tick"); e.setAll({ strokeOpacity: .15, isMeasured: !1, length: 4.5, position: "absolute", crisp: !0 }), l(e, "stroke", t, "grid") } h("Bullet").setAll({ locationX: .5, locationY: .5 }), h("Tooltip").setAll({ position: "absolute", getFillFromSprite: !0, getStrokeFromSprite: !1, autoTextColor: !0, paddingTop: 9, paddingBottom: 8, paddingLeft: 10, paddingRight: 10, marginBottom: 5, pointerOrientation: "vertical", centerX: a.p50, centerY: a.p50, animationEasing: o.out(o.cubic), exportable: !1 }), h("Polygon").setAll({ animationEasing: o.out(o.cubic) }); h("PointedRectangle", ["tooltip", "background"]).setAll({ strokeOpacity: .9, cornerRadius: 4, pointerLength: 4, pointerBaseWidth: 8, fillOpacity: .9, stroke: r.Color.fromHex(16777215) }); { const e = h("Label", ["tooltip"]); e.setAll({ role: "tooltip", populateText: !0, paddingRight: 0, paddingTop: 0, paddingLeft: 0, paddingBottom: 0 }), l(e, "fill", t, "alternativeText") } h("Button").setAll({ paddingTop: 8, paddingBottom: 8, paddingLeft: 10, paddingRight: 10, interactive: !0, layout: i, interactiveChildren: !1, setStateOnChildren: !0, focusable: !0 }), h("Button").states.create("hover", {}), h("Button").states.create("down", { stateAnimationDuration: 0 }), h("Button").states.create("active", {}), h("Button").states.create("disabled", { forceInactive: !0 }); { const e = h("RoundedRectangle", ["button", "background"]); l(e, "fill", t, "primaryButton"), l(e, "stroke", t, "primaryButtonStroke") } l(h("RoundedRectangle", ["button", "background"]).states.create("hover", {}), "fill", t, "primaryButtonHover"); l(h("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 }), "fill", t, "primaryButtonDown"); l(h("RoundedRectangle", ["button", "background"]).states.create("active", {}), "fill", t, "primaryButtonActive"); l(h("RoundedRectangle", ["button", "background"]).states.create("disabled", {}), "fill", t, "primaryButtonDisabled"); l(h("Graphics", ["button", "icon"]).states.create("disabled", {}), "fill", t, "primaryButtonTextDisabled"); l(h("Label", ["button"]).states.create("disabled", {}), "fill", t, "primaryButtonTextDisabled"); { const e = h("Graphics", ["button", "icon"]); e.setAll({ forceInactive: !0 }), l(e, "stroke", t, "primaryButtonText") } l(h("Label", ["button"]), "fill", t, "primaryButtonText"); h("Button", ["zoom"]).setAll({ paddingTop: 18, paddingBottom: 18, paddingLeft: 12, paddingRight: 12, centerX: 46, centerY: -10, y: 0, x: a.p100, role: "button", ariaLabel: e.translate("Zoom Out"), layer: 30 }); { const e = h("RoundedRectangle", ["background", "button", "zoom"]); e.setAll({ cornerRadiusBL: 40, cornerRadiusBR: 40, cornerRadiusTL: 40, cornerRadiusTR: 40 }), l(e, "fill", t, "primaryButton") } l(h("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {}), "fill", t, "primaryButtonHover"); l(h("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 }), "fill", t, "primaryButtonDown"); { const e = h("Graphics", ["icon", "button", "zoom"]); e.setAll({ crisp: !0, strokeOpacity: .7, draw: e => { e.moveTo(0, 0), e.lineTo(12, 0) } }), l(e, "stroke", t, "primaryButtonText") } h("Button", ["resize"]).setAll({ paddingTop: 9, paddingBottom: 9, paddingLeft: 13, paddingRight: 13, draggable: !0, centerX: a.p50, centerY: a.p50, position: "absolute", role: "slider", ariaValueMin: "0", ariaValueMax: "100", ariaLabel: e.translate("Use up and down arrows to move selection") }); { const e = h("RoundedRectangle", ["background", "resize", "button"]); e.setAll({ cornerRadiusBL: 40, cornerRadiusBR: 40, cornerRadiusTL: 40, cornerRadiusTR: 40 }), l(e, "fill", t, "secondaryButton"), l(e, "stroke", t, "secondaryButtonStroke") } l(h("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {}), "fill", t, "secondaryButtonHover"); l(h("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 }), "fill", t, "secondaryButtonDown"); { const e = h("Graphics", ["resize", "button", "icon"]); e.setAll({ interactive: !1, crisp: !0, strokeOpacity: .5, draw: e => { e.moveTo(0, .5), e.lineTo(0, 12.5), e.moveTo(4, .5), e.lineTo(4, 12.5) } }), l(e, "stroke", t, "secondaryButtonText") } h("Button", ["resize", "vertical"]).setAll({ rotation: 90, cursorOverStyle: "ns-resize" }), h("Button", ["resize", "horizontal"]).setAll({ cursorOverStyle: "ew-resize" }), h("Button", ["play"]).setAll({ paddingTop: 13, paddingBottom: 13, paddingLeft: 14, paddingRight: 14, ariaLabel: e.translate("Play"), toggleKey: "active" }); { const e = h("RoundedRectangle", ["play", "background"]); e.setAll({ strokeOpacity: .5, cornerRadiusBL: 100, cornerRadiusBR: 100, cornerRadiusTL: 100, cornerRadiusTR: 100 }), l(e, "fill", t, "primaryButton") } { const e = h("Graphics", ["play", "icon"]); e.setAll({ stateAnimationDuration: 0, dx: 1, draw: e => { e.moveTo(0, -5), e.lineTo(8, 0), e.lineTo(0, 5), e.lineTo(0, -5) } }), l(e, "fill", t, "primaryButtonText") } h("Graphics", ["play", "icon"]).states.create("default", { stateAnimationDuration: 0 }), h("Graphics", ["play", "icon"]).states.create("active", { stateAnimationDuration: 0, draw: e => { e.moveTo(-4, -5), e.lineTo(-1, -5), e.lineTo(-1, 5), e.lineTo(-4, 5), e.lineTo(-4, -5), e.moveTo(4, -5), e.lineTo(1, -5), e.lineTo(1, 5), e.lineTo(4, 5), e.lineTo(4, -5) } }), h("Button", ["switch"]).setAll({ paddingTop: 4, paddingBottom: 4, paddingLeft: 4, paddingRight: 4, ariaLabel: e.translate("Press ENTER to toggle"), toggleKey: "active", width: 40, height: 24, layout: null }); { const e = h("RoundedRectangle", ["switch", "background"]); e.setAll({ strokeOpacity: .5, cornerRadiusBL: 100, cornerRadiusBR: 100, cornerRadiusTL: 100, cornerRadiusTR: 100 }), l(e, "fill", t, "primaryButton") } { const e = h("Circle", ["switch", "icon"]); e.setAll({ radius: 8, centerY: 0, centerX: 0, dx: 0 }), l(e, "fill", t, "primaryButtonText") } h("Graphics", ["switch", "icon"]).states.create("active", { dx: 16 }), h("Scrollbar").setAll({ start: 0, end: 1, layer: 30, animationEasing: o.out(o.cubic) }), h("Scrollbar", ["vertical"]).setAll({ marginRight: 13, marginLeft: 13, minWidth: 12, height: a.p100 }), h("Scrollbar", ["horizontal"]).setAll({ marginTop: 13, marginBottom: 13, minHeight: 12, width: a.p100 }), this.rule("Button", ["scrollbar"]).setAll({ exportable: !1 }); { const e = h("RoundedRectangle", ["scrollbar", "main", "background"]); e.setAll({ cornerRadiusTL: 8, cornerRadiusBL: 8, cornerRadiusTR: 8, cornerRadiusBR: 8, fillOpacity: .8 }), l(e, "fill", t, "fill") } { const e = h("RoundedRectangle", ["scrollbar", "thumb"]); e.setAll({ role: "slider", ariaLive: "polite", position: "absolute", draggable: !0 }), l(e, "fill", t, "secondaryButton") } l(h("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {}), "fill", t, "secondaryButtonHover"); l(h("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 }), "fill", t, "secondaryButtonDown"); h("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({ x: a.p50, width: a.p100, centerX: a.p50, ariaLabel: e.translate("Use up and down arrows to move selection") }), h("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({ y: a.p50, centerY: a.p50, height: a.p100, ariaLabel: e.translate("Use left and right arrows to move selection") }); { const e = h("PointedRectangle", ["axis", "tooltip", "background"]); e.setAll({ cornerRadius: 0 }), l(e, "fill", t, "alternativeBackground") } h("Label", ["axis", "tooltip"]).setAll({ role: void 0 }), h("Label", ["axis", "tooltip", "y"]).setAll({ textAlign: "right" }), h("Label", ["axis", "tooltip", "y", "opposite"]).setAll({ textAlign: "left" }), h("Label", ["axis", "tooltip", "x"]).setAll({ textAlign: "center" }), h("Tooltip", ["categoryaxis"]).setAll({ labelText: "{category}" }), h("Star").setAll({ spikes: 5, innerRadius: 5, radius: 10 }), h("Tooltip", ["stock"]).setAll({ paddingTop: 6, paddingBottom: 5, paddingLeft: 7, paddingRight: 7 }), h("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({ pointerLength: 0, pointerBaseWidth: 0, cornerRadius: 3 }), h("Label", ["tooltip", "stock"]).setAll({ fontSize: "0.8em" }), h("SpriteResizer").setAll({ rotationStep: 10, isMeasured: !1 }); h("Container", ["resizer", "grip"]).states.create("hover", {}); { const e = h("RoundedRectangle", ["resizer", "grip"]); e.setAll({ strokeOpacity: .7, strokeWidth: 1, fillOpacity: 1, width: 12, height: 12 }), l(e, "fill", t, "background"), l(e, "stroke", t, "alternativeBackground") } { const e = h("RoundedRectangle", ["resizer", "grip", "outline"]); e.setAll({ strokeOpacity: 0, fillOpacity: 0, width: 20, height: 20 }), e.states.create("hover", { fillOpacity: .3 }), l(e, "fill", t, "alternativeBackground") } h("RoundedRectangle", ["resizer", "grip", "left"]).setAll({ cornerRadiusBL: 0, cornerRadiusBR: 0, cornerRadiusTL: 0, cornerRadiusTR: 0 }), h("RoundedRectangle", ["resizer", "grip", "right"]).setAll({ cornerRadiusBL: 0, cornerRadiusBR: 0, cornerRadiusTL: 0, cornerRadiusTR: 0 }); { const e = h("Rectangle", ["resizer", "rectangle"]); e.setAll({ strokeDasharray: [2, 2], strokeOpacity: .5, strokeWidth: 1 }), l(e, "stroke", t, "alternativeBackground") } h("Graphics", ["button", "plus", "icon"]).setAll({ x: a.p50, y: a.p50, draw: e => { e.moveTo(-4, 0), e.lineTo(4, 0), e.moveTo(0, -4), e.lineTo(0, 4) } }), h("Graphics", ["button", "minus", "icon"]).setAll({ x: a.p50, y: a.p50, draw: e => { e.moveTo(-4, 0), e.lineTo(4, 0) } }), h("Graphics", ["button", "home", "icon"]).setAll({ x: a.p50, y: a.p50, svgPath: "M 8 -1 L 6 -1 L 6 7 L 2 7 L 2 1 L -2 1 L -2 7 L -6 7 L -6 -1 L -8 -1 L 0 -9 L 8 -1 Z M 8 -1" }), h("Button", ["zoomtools"]).setAll({ marginTop: 1, marginBottom: 2 }), h("ZoomTools").setAll({ x: a.p100, centerX: a.p100, y: a.p100, centerY: a.p100, paddingRight: 10, paddingBottom: 10 }) } } }, "./node_modules/@amcharts/amcharts5/locales/en.js": (e, t, i) => { i.r(t), i.d(t, { default: () => s }); const s = { firstDayOfWeek: 1, _decimalSeparator: ".", _thousandSeparator: ",", _percentPrefix: null, _percentSuffix: "%", _big_number_suffix_3: "k", _big_number_suffix_6: "M", _big_number_suffix_9: "G", _big_number_suffix_12: "T", _big_number_suffix_15: "P", _big_number_suffix_18: "E", _big_number_suffix_21: "Z", _big_number_suffix_24: "Y", _small_number_suffix_3: "m", _small_number_suffix_6: "", _small_number_suffix_9: "n", _small_number_suffix_12: "p", _small_number_suffix_15: "f", _small_number_suffix_18: "a", _small_number_suffix_21: "z", _small_number_suffix_24: "y", _byte_suffix_B: "B", _byte_suffix_KB: "KB", _byte_suffix_MB: "MB", _byte_suffix_GB: "GB", _byte_suffix_TB: "TB", _byte_suffix_PB: "PB", _date: "yyyy-MM-dd", _date_millisecond: "mm:ss SSS", _date_millisecond_full: "HH:mm:ss SSS", _date_second: "HH:mm:ss", _date_second_full: "HH:mm:ss", _date_minute: "HH:mm", _date_minute_full: "HH:mm - MMM dd, yyyy", _date_hour: "HH:mm", _date_hour_full: "HH:mm - MMM dd, yyyy", _date_day: "MMM dd", _date_day_full: "MMM dd, yyyy", _date_week: "ww", _date_week_full: "MMM dd, yyyy", _date_month: "MMM", _date_month_full: "MMM, yyyy", _date_year: "yyyy", _duration_millisecond: "SSS", _duration_millisecond_second: "ss.SSS", _duration_millisecond_minute: "mm:ss SSS", _duration_millisecond_hour: "hh:mm:ss SSS", _duration_millisecond_day: "d'd' mm:ss SSS", _duration_millisecond_week: "d'd' mm:ss SSS", _duration_millisecond_month: "M'm' dd'd' mm:ss SSS", _duration_millisecond_year: "y'y' MM'm' dd'd' mm:ss SSS", _duration_second: "ss", _duration_second_minute: "mm:ss", _duration_second_hour: "hh:mm:ss", _duration_second_day: "d'd' hh:mm:ss", _duration_second_week: "d'd' hh:mm:ss", _duration_second_month: "M'm' dd'd' hh:mm:ss", _duration_second_year: "y'y' MM'm' dd'd' hh:mm:ss", _duration_minute: "mm", _duration_minute_hour: "hh:mm", _duration_minute_day: "d'd' hh:mm", _duration_minute_week: "d'd' hh:mm", _duration_minute_month: "M'm' dd'd' hh:mm", _duration_minute_year: "y'y' MM'm' dd'd' hh:mm", _duration_hour: "hh'h'", _duration_hour_day: "d'd' hh'h'", _duration_hour_week: "d'd' hh'h'", _duration_hour_month: "M'm' dd'd' hh'h'", _duration_hour_year: "y'y' MM'm' dd'd' hh'h'", _duration_day: "d'd'", _duration_day_week: "d'd'", _duration_day_month: "M'm' dd'd'", _duration_day_year: "y'y' MM'm' dd'd'", _duration_week: "w'w'", _duration_week_month: "w'w'", _duration_week_year: "w'w'", _duration_month: "M'm'", _duration_month_year: "y'y' MM'm'", _duration_year: "y'y'", _era_ad: "AD", _era_bc: "BC", A: "", P: "", AM: "", PM: "", "A.M.": "", "P.M.": "", January: "", February: "", March: "", April: "", May: "", June: "", July: "", August: "", September: "", October: "", November: "", December: "", Jan: "", Feb: "", Mar: "", Apr: "", "May(short)": "May", Jun: "", Jul: "", Aug: "", Sep: "", Oct: "", Nov: "", Dec: "", Sunday: "", Monday: "", Tuesday: "", Wednesday: "", Thursday: "", Friday: "", Saturday: "", Sun: "", Mon: "", Tue: "", Wed: "", Thu: "", Fri: "", Sat: "", _dateOrd: function (e) { let t = "th"; if (e < 11 || e > 13) switch (e % 10) { case 1: t = "st"; break; case 2: t = "nd"; break; case 3: t = "rd" }return t }, "Zoom Out": "", Play: "", Stop: "", Legend: "", "Press ENTER to toggle": "", Loading: "", Home: "", Chart: "", "Serial chart": "", "X/Y chart": "", "Pie chart": "", "Gauge chart": "", "Radar chart": "", "Sankey diagram": "", "Flow diagram": "", "Chord diagram": "", "TreeMap chart": "", "Force directed tree": "", "Sliced chart": "", Series: "", "Candlestick Series": "", "OHLC Series": "", "Column Series": "", "Line Series": "", "Pie Slice Series": "", "Funnel Series": "", "Pyramid Series": "", "X/Y Series": "", Map: "", "Press ENTER to zoom in": "", "Press ENTER to zoom out": "", "Use arrow keys to zoom in and out": "", "Use plus and minus keys on your keyboard to zoom in and out": "", Export: "", Image: "", Data: "", Print: "", "Press ENTER or use arrow keys to navigate": "", "Press ENTER to open": "", "Press ENTER to print.": "", "Press ENTER to export as %1.": "", "(Press ESC to close this message)": "", "Image Export Complete": "", "Export operation took longer than expected. Something might have gone wrong.": "", "Saved from": "", PNG: "", JPG: "", GIF: "", SVG: "", PDF: "", JSON: "", CSV: "", XLSX: "", HTML: "", "Use TAB to select grip buttons or left and right arrows to change selection": "", "Use left and right arrows to move selection": "", "Use left and right arrows to move left selection": "", "Use left and right arrows to move right selection": "", "Use TAB select grip buttons or up and down arrows to change selection": "", "Use up and down arrows to move selection": "", "Use up and down arrows to move lower selection": "", "Use up and down arrows to move upper selection": "", "From %1 to %2": "", "From %1": "", "To %1": "", "No parser available for file: %1": "", "Error parsing file: %1": "", "Unable to load file: %1": "", "Invalid date": "", Close: "", Minimize: "" } }, "./node_modules/@amcharts/amcharts5/themes/Animated.js": (e, t, i) => { i.r(t), i.d(t, { default: () => s }); const s = i("./node_modules/@amcharts/amcharts5/.internal/themes/AnimatedTheme.js").AnimatedTheme }, "./node_modules/svg-arc-to-cubic-bezier/modules/index.js": (e, t, i) => { i.r(t), i.d(t, { default: () => l }); var s = function (e, t) { if (Array.isArray(e)) return e; if (Symbol.iterator in Object(e)) return function (e, t) { var i = [], s = !0, a = !1, r = void 0; try { for (var n, o = e[Symbol.iterator](); !(s = (n = o.next()).done) && (i.push(n.value), !t || i.length !== t); s = !0); } catch (e) { a = !0, r = e } finally { try { !s && o.return && o.return() } finally { if (a) throw r } } return i }(e, t); throw new TypeError("Invalid attempt to destructure non-iterable instance") }, a = 2 * Math.PI, r = function (e, t, i, s, a, r, n) { var o = e.x, l = e.y; return { x: s * (o *= t) - a * (l *= i) + r, y: a * o + s * l + n } }, n = function (e, t) { var i = 1.5707963267948966 === t ? .551915024494 : -1.5707963267948966 === t ? -.551915024494 : 4 / 3 * Math.tan(t / 4), s = Math.cos(e), a = Math.sin(e), r = Math.cos(e + t), n = Math.sin(e + t); return [{ x: s - a * i, y: a + s * i }, { x: r + n * i, y: n - r * i }, { x: r, y: n }] }, o = function (e, t, i, s) { var a = e * i + t * s; return a > 1 && (a = 1), a < -1 && (a = -1), (e * s - t * i < 0 ? -1 : 1) * Math.acos(a) }; const l = function (e) { var t = e.px, i = e.py, l = e.cx, h = e.cy, c = e.rx, u = e.ry, d = e.xAxisRotation, m = void 0 === d ? 0 : d, p = e.largeArcFlag, g = void 0 === p ? 0 : p, b = e.sweepFlag, _ = void 0 === b ? 0 : b, f = []; if (0 === c || 0 === u) return []; var y = Math.sin(m * a / 360), v = Math.cos(m * a / 360), x = v * (t - l) / 2 + y * (i - h) / 2, w = -y * (t - l) / 2 + v * (i - h) / 2; if (0 === x && 0 === w) return []; c = Math.abs(c), u = Math.abs(u); var P = Math.pow(x, 2) / Math.pow(c, 2) + Math.pow(w, 2) / Math.pow(u, 2); P > 1 && (c *= Math.sqrt(P), u *= Math.sqrt(P)); var T = function (e, t, i, s, r, n, l, h, c, u, d, m) { var p = Math.pow(r, 2), g = Math.pow(n, 2), b = Math.pow(d, 2), _ = Math.pow(m, 2), f = p * g - p * _ - g * b; f < 0 && (f = 0), f /= p * _ + g * b; var y = (f = Math.sqrt(f) * (l === h ? -1 : 1)) * r / n * m, v = f * -n / r * d, x = u * y - c * v + (e + i) / 2, w = c * y + u * v + (t + s) / 2, P = (d - y) / r, T = (m - v) / n, D = (-d - y) / r, k = (-m - v) / n, j = o(1, 0, P, T), C = o(P, T, D, k); return 0 === h && C > 0 && (C -= a), 1 === h && C < 0 && (C += a), [x, w, j, C] }(t, i, l, h, c, u, g, _, y, v, x, w), D = s(T, 4), k = D[0], j = D[1], C = D[2], O = D[3], S = Math.abs(O) / (a / 4); Math.abs(1 - S) < 1e-7 && (S = 1); var A = Math.max(Math.ceil(S), 1); O /= A; for (var M = 0; M < A; M++)f.push(n(C, O)), C += O; return f.map((function (e) { var t = r(e[0], c, u, v, y, k, j), i = t.x, s = t.y, a = r(e[1], c, u, v, y, k, j), n = a.x, o = a.y, l = r(e[2], c, u, v, y, k, j); return { x1: i, y1: s, x2: n, y2: o, x: l.x, y: l.y } })) } }, "react/jsx-runtime": e => { e.exports = window.ReactJSXRuntime }, "@wordpress/element": e => { e.exports = window.wp.element }, "./node_modules/tslib/tslib.es6.mjs": (e, t, i) => { i.r(t), i.d(t, { __addDisposableResource: () => E, __assign: () => r, __asyncDelegator: () => D, __asyncGenerator: () => T, __asyncValues: () => k, __await: () => P, __awaiter: () => p, __classPrivateFieldGet: () => A, __classPrivateFieldIn: () => L, __classPrivateFieldSet: () => M, __createBinding: () => b, __decorate: () => o, __disposeResources: () => I, __esDecorate: () => h, __exportStar: () => _, __extends: () => a, __generator: () => g, __importDefault: () => S, __importStar: () => O, __makeTemplateObject: () => j, __metadata: () => m, __param: () => l, __propKey: () => u, __read: () => y, __rest: () => n, __runInitializers: () => c, __setFunctionName: () => d, __spread: () => v, __spreadArray: () => w, __spreadArrays: () => x, __values: () => f, default: () => B }); var s = function (e, t) { return s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]) }, s(e, t) }; function a(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function i() { this.constructor = e } s(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i) } var r = function () { return r = Object.assign || function (e) { for (var t, i = 1, s = arguments.length; i < s; i++)for (var a in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]); return e }, r.apply(this, arguments) }; function n(e, t) { var i = {}; for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (i[s] = e[s]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var a = 0; for (s = Object.getOwnPropertySymbols(e); a < s.length; a++)t.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (i[s[a]] = e[s[a]]) } return i } function o(e, t, i, s) { var a, r = arguments.length, n = r < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) n = Reflect.decorate(e, t, i, s); else for (var o = e.length - 1; o >= 0; o--)(a = e[o]) && (n = (r < 3 ? a(n) : r > 3 ? a(t, i, n) : a(t, i)) || n); return r > 3 && n && Object.defineProperty(t, i, n), n } function l(e, t) { return function (i, s) { t(i, s, e) } } function h(e, t, i, s, a, r) { function n(e) { if (void 0 !== e && "function" != typeof e) throw new TypeError("Function expected"); return e } for (var o, l = s.kind, h = "getter" === l ? "get" : "setter" === l ? "set" : "value", c = !t && e ? s.static ? e : e.prototype : null, u = t || (c ? Object.getOwnPropertyDescriptor(c, s.name) : {}), d = !1, m = i.length - 1; m >= 0; m--) { var p = {}; for (var g in s) p[g] = "access" === g ? {} : s[g]; for (var g in s.access) p.access[g] = s.access[g]; p.addInitializer = function (e) { if (d) throw new TypeError("Cannot add initializers after decoration has completed"); r.push(n(e || null)) }; var b = (0, i[m])("accessor" === l ? { get: u.get, set: u.set } : u[h], p); if ("accessor" === l) { if (void 0 === b) continue; if (null === b || "object" != typeof b) throw new TypeError("Object expected"); (o = n(b.get)) && (u.get = o), (o = n(b.set)) && (u.set = o), (o = n(b.init)) && a.unshift(o) } else (o = n(b)) && ("field" === l ? a.unshift(o) : u[h] = o) } c && Object.defineProperty(c, s.name, u), d = !0 } function c(e, t, i) { for (var s = arguments.length > 2, a = 0; a < t.length; a++)i = s ? t[a].call(e, i) : t[a].call(e); return s ? i : void 0 } function u(e) { return "symbol" == typeof e ? e : "".concat(e) } function d(e, t, i) { return "symbol" == typeof t && (t = t.description ? "[".concat(t.description, "]") : ""), Object.defineProperty(e, "name", { configurable: !0, value: i ? "".concat(i, " ", t) : t }) } function m(e, t) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t) } function p(e, t, i, s) { return new (i || (i = Promise))((function (a, r) { function n(e) { try { l(s.next(e)) } catch (e) { r(e) } } function o(e) { try { l(s.throw(e)) } catch (e) { r(e) } } function l(e) { var t; e.done ? a(e.value) : (t = e.value, t instanceof i ? t : new i((function (e) { e(t) }))).then(n, o) } l((s = s.apply(e, t || [])).next()) })) } function g(e, t) { var i, s, a, r = { label: 0, sent: function () { if (1 & a[0]) throw a[1]; return a[1] }, trys: [], ops: [] }, n = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype); return n.next = o(0), n.throw = o(1), n.return = o(2), "function" == typeof Symbol && (n[Symbol.iterator] = function () { return this }), n; function o(o) { return function (l) { return function (o) { if (i) throw new TypeError("Generator is already executing."); for (; n && (n = 0, o[0] && (r = 0)), r;)try { if (i = 1, s && (a = 2 & o[0] ? s.return : o[0] ? s.throw || ((a = s.return) && a.call(s), 0) : s.next) && !(a = a.call(s, o[1])).done) return a; switch (s = 0, a && (o = [2 & o[0], a.value]), o[0]) { case 0: case 1: a = o; break; case 4: return r.label++, { value: o[1], done: !1 }; case 5: r.label++, s = o[1], o = [0]; continue; case 7: o = r.ops.pop(), r.trys.pop(); continue; default: if (!(a = r.trys, (a = a.length > 0 && a[a.length - 1]) || 6 !== o[0] && 2 !== o[0])) { r = 0; continue } if (3 === o[0] && (!a || o[1] > a[0] && o[1] < a[3])) { r.label = o[1]; break } if (6 === o[0] && r.label < a[1]) { r.label = a[1], a = o; break } if (a && r.label < a[2]) { r.label = a[2], r.ops.push(o); break } a[2] && r.ops.pop(), r.trys.pop(); continue }o = t.call(e, r) } catch (e) { o = [6, e], s = 0 } finally { i = a = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, l]) } } } var b = Object.create ? function (e, t, i, s) { void 0 === s && (s = i); var a = Object.getOwnPropertyDescriptor(t, i); a && !("get" in a ? !t.__esModule : a.writable || a.configurable) || (a = { enumerable: !0, get: function () { return t[i] } }), Object.defineProperty(e, s, a) } : function (e, t, i, s) { void 0 === s && (s = i), e[s] = t[i] }; function _(e, t) { for (var i in e) "default" === i || Object.prototype.hasOwnProperty.call(t, i) || b(t, e, i) } function f(e) { var t = "function" == typeof Symbol && Symbol.iterator, i = t && e[t], s = 0; if (i) return i.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") } function y(e, t) { var i = "function" == typeof Symbol && e[Symbol.iterator]; if (!i) return e; var s, a, r = i.call(e), n = []; try { for (; (void 0 === t || t-- > 0) && !(s = r.next()).done;)n.push(s.value) } catch (e) { a = { error: e } } finally { try { s && !s.done && (i = r.return) && i.call(r) } finally { if (a) throw a.error } } return n } function v() { for (var e = [], t = 0; t < arguments.length; t++)e = e.concat(y(arguments[t])); return e } function x() { for (var e = 0, t = 0, i = arguments.length; t < i; t++)e += arguments[t].length; var s = Array(e), a = 0; for (t = 0; t < i; t++)for (var r = arguments[t], n = 0, o = r.length; n < o; n++, a++)s[a] = r[n]; return s } function w(e, t, i) { if (i || 2 === arguments.length) for (var s, a = 0, r = t.length; a < r; a++)!s && a in t || (s || (s = Array.prototype.slice.call(t, 0, a)), s[a] = t[a]); return e.concat(s || Array.prototype.slice.call(t)) } function P(e) { return this instanceof P ? (this.v = e, this) : new P(e) } function T(e, t, i) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var s, a = i.apply(e, t || []), r = []; return s = Object.create(("function" == typeof AsyncIterator ? AsyncIterator : Object).prototype), n("next"), n("throw"), n("return", (function (e) { return function (t) { return Promise.resolve(t).then(e, h) } })), s[Symbol.asyncIterator] = function () { return this }, s; function n(e, t) { a[e] && (s[e] = function (t) { return new Promise((function (i, s) { r.push([e, t, i, s]) > 1 || o(e, t) })) }, t && (s[e] = t(s[e]))) } function o(e, t) { try { (i = a[e](t)).value instanceof P ? Promise.resolve(i.value.v).then(l, h) : c(r[0][2], i) } catch (e) { c(r[0][3], e) } var i } function l(e) { o("next", e) } function h(e) { o("throw", e) } function c(e, t) { e(t), r.shift(), r.length && o(r[0][0], r[0][1]) } } function D(e) { var t, i; return t = {}, s("next"), s("throw", (function (e) { throw e })), s("return"), t[Symbol.iterator] = function () { return this }, t; function s(s, a) { t[s] = e[s] ? function (t) { return (i = !i) ? { value: P(e[s](t)), done: !1 } : a ? a(t) : t } : a } } function k(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var t, i = e[Symbol.asyncIterator]; return i ? i.call(e) : (e = f(e), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function () { return this }, t); function s(i) { t[i] = e[i] && function (t) { return new Promise((function (s, a) { (function (e, t, i, s) { Promise.resolve(s).then((function (t) { e({ value: t, done: i }) }), t) })(s, a, (t = e[i](t)).done, t.value) })) } } } function j(e, t) { return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e } var C = Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }; function O(e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) "default" !== i && Object.prototype.hasOwnProperty.call(e, i) && b(t, e, i); return C(t, e), t } function S(e) { return e && e.__esModule ? e : { default: e } } function A(e, t, i, s) { if ("a" === i && !s) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === i ? s : "a" === i ? s.call(e) : s ? s.value : t.get(e) } function M(e, t, i, s, a) { if ("m" === s) throw new TypeError("Private method is not writable"); if ("a" === s && !a) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof t ? e !== t || !a : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === s ? a.call(e, i) : a ? a.value = i : t.set(e, i), i } function L(e, t) { if (null === t || "object" != typeof t && "function" != typeof t) throw new TypeError("Cannot use 'in' operator on non-object"); return "function" == typeof e ? t === e : e.has(t) } function E(e, t, i) { if (null != t) { if ("object" != typeof t && "function" != typeof t) throw new TypeError("Object expected."); var s, a; if (i) { if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined."); s = t[Symbol.asyncDispose] } if (void 0 === s) { if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined."); s = t[Symbol.dispose], i && (a = s) } if ("function" != typeof s) throw new TypeError("Object not disposable."); a && (s = function () { try { a.call(this) } catch (e) { return Promise.reject(e) } }), e.stack.push({ value: t, dispose: s, async: i }) } else i && e.stack.push({ async: !0 }); return t } var R = "function" == typeof SuppressedError ? SuppressedError : function (e, t, i) { var s = new Error(i); return s.name = "SuppressedError", s.error = e, s.suppressed = t, s }; function I(e) { function t(t) { e.error = e.hasError ? new R(t, e.error, "An error was suppressed during disposal.") : t, e.hasError = !0 } var i, s = 0; return function a() { for (; i = e.stack.pop();)try { if (!i.async && 1 === s) return s = 0, e.stack.push(i), Promise.resolve().then(a); if (i.dispose) { var r = i.dispose.call(i.value); if (i.async) return s |= 2, Promise.resolve(r).then(a, (function (e) { return t(e), a() })) } else s |= 1 } catch (e) { t(e) } if (1 === s) return e.hasError ? Promise.reject(e.error) : Promise.resolve(); if (e.hasError) throw e.error }() } const B = { __extends: a, __assign: r, __rest: n, __decorate: o, __param: l, __metadata: m, __awaiter: p, __generator: g, __createBinding: b, __exportStar: _, __values: f, __read: y, __spread: v, __spreadArrays: x, __spreadArray: w, __await: P, __asyncGenerator: T, __asyncDelegator: D, __asyncValues: k, __makeTemplateObject: j, __importStar: O, __importDefault: S, __classPrivateFieldGet: A, __classPrivateFieldSet: M, __classPrivateFieldIn: L, __addDisposableResource: E, __disposeResources: I } } }, t = {}; function i(s) { var a = t[s]; if (void 0 !== a) return a.exports; var r = t[s] = { exports: {} }; return e[s](r, r.exports, i), r.exports } i.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return i.d(t, { a: t }), t }, i.d = (e, t) => { for (var s in t) i.o(t, s) && !i.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: t[s] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }; var s = {}; i.r(s), i.d(s, { default: () => f }); var a = i("@wordpress/element"), r = i("./node_modules/@amcharts/amcharts5/.internal/core/Root.js"), n = i("./node_modules/@amcharts/amcharts5/.internal/core/render/Legend.js"), o = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYChart.js"), l = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/ValueAxis.js"), h = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererY.js"), c = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/CategoryAxis.js"), u = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/axes/AxisRendererX.js"), d = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/series/ColumnSeries.js"), m = i("./node_modules/@amcharts/amcharts5/.internal/charts/xy/XYCursor.js"), p = i("./node_modules/@amcharts/amcharts5/themes/Animated.js"), g = i("react/jsx-runtime"); const b = document.getElementById("#crfwc-dashboard-widget-1"); console.log(b); const _ = () => ((0, a.useLayoutEffect)((() => { let e = r.Root.new("chartdiv"); console.log(e), e.setThemes([p.default.new(e)]); let t = e.container.children.push(o.XYChart.new(e, { panY: !1, layout: e.verticalLayout })), i = [{ category: "Research", value1: 1e3, value2: 588 }, { category: "Marketing", value1: 1200, value2: 1800 }, { category: "Sales", value1: 850, value2: 1230 }], s = t.yAxes.push(l.ValueAxis.new(e, { renderer: h.AxisRendererY.new(e, {}) })), a = t.xAxes.push(c.CategoryAxis.new(e, { renderer: u.AxisRendererX.new(e, {}), categoryField: "category" })); return a.data.setAll(i), t.series.push(d.ColumnSeries.new(e, { name: "Series", xAxis: a, yAxis: s, valueYField: "value1", categoryXField: "category" })).data.setAll(i), t.series.push(d.ColumnSeries.new(e, { name: "Series", xAxis: a, yAxis: s, valueYField: "value2", categoryXField: "category" })).data.setAll(i), t.children.push(n.Legend.new(e, {})).data.setAll(t.series.values), t.set("cursor", m.XYCursor.new(e, {})), () => { e.dispose() } }), []), (0, g.jsx)("div", { id: "chartdiv", style: { width: "500px", height: "500px" } })), f = _; a.createRoot ? (0, a.createRoot)(b).render((0, g.jsx)(a.StrictMode, { children: (0, g.jsx)(_, {}) })) : (0, a.render)((0, g.jsx)(a.StrictMode, { children: (0, g.jsx)(_, {}) }), b) })();